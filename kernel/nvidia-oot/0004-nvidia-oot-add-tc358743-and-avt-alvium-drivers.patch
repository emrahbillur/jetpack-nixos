From 065af02bb76679199d75af80b46ffe447c5d9732 Mon Sep 17 00:00:00 2001
From: Emrah Billur <emrah.billur@unikie.com>
Date: Fri, 4 Apr 2025 10:57:46 +0300
Subject: [PATCH] nvidia-oot: add toshiba+alvium drivers

---
 drivers/media/i2c/Makefile                    |   30 +
 drivers/media/i2c/avt-csi2.c                  | 5556 +++++++++++++++++
 drivers/media/i2c/tc358743.c                  | 2383 +++++++
 .../tegra/camera/fusa-capture/capture-vi.c    | 1774 ++++++
 .../media/platform/tegra/camera/vi/channel.c  | 2837 +++++++++
 .../media/platform/tegra/camera/vi/vi5_fops.c | 1148 ++++
 .../platform/tegra/camera/vi/vi5_formats.h    |  159 +
 drivers/video/tegra/host/vi/vi5.c             |  474 ++
 .../nvidia/t23x/nv-public/overlay/Makefile    |    1 +
 ...-p3767-camera-p3768-2avt-tc358743-gmsl.dts |  462 ++
 ...gra234-p3767-camera-p3768-avt-tc358743.dts |  344 +
 include/media/avt-csi2-regs.h                 |  419 ++
 include/media/avt-csi2-version.h              |    1 +
 include/media/avt-csi2.h                      |  729 +++
 include/media/avt-mipi-csi2.h                 |   43 +
 include/media/fusa-capture/capture-vi.h       |  458 ++
 include/media/libcsi_ioctl.h                  |  355 ++
 include/media/tc358743.h                      |  150 +
 include/media/tc358743_regs.h                 |  681 ++
 include/media/tegra_camera_core.h             |  135 +
 include/uapi/linux/avt-csi2.h                 |  100 +
 nvidia-oot/drivers/media/i2c/Makefile         |    1 +
 nvidia-oot/drivers/media/i2c/tc358743.c       | 2383 +++++++
 nvidia-oot/include/media/tc358743.h           |  150 +
 nvidia-oot/include/media/tc358743_regs.h      |  681 ++
 25 files changed, 21454 insertions(+)
 create mode 100644 drivers/media/i2c/Makefile
 create mode 100644 drivers/media/i2c/avt-csi2.c
 create mode 100644 drivers/media/i2c/tc358743.c
 create mode 100644 drivers/media/platform/tegra/camera/fusa-capture/capture-vi.c
 create mode 100644 drivers/media/platform/tegra/camera/vi/channel.c
 create mode 100644 drivers/media/platform/tegra/camera/vi/vi5_fops.c
 create mode 100644 drivers/media/platform/tegra/camera/vi/vi5_formats.h
 create mode 100644 drivers/video/tegra/host/vi/vi5.c
 create mode 100644 hardware/nvidia/t23x/nv-public/overlay/tegra234-p3767-camera-p3768-2avt-tc358743-gmsl.dts
 create mode 100644 hardware/nvidia/t23x/nv-public/overlay/tegra234-p3767-camera-p3768-avt-tc358743.dts
 create mode 100644 include/media/avt-csi2-regs.h
 create mode 100644 include/media/avt-csi2-version.h
 create mode 100644 include/media/avt-csi2.h
 create mode 100644 include/media/avt-mipi-csi2.h
 create mode 100644 include/media/fusa-capture/capture-vi.h
 create mode 100644 include/media/libcsi_ioctl.h
 create mode 100644 include/media/tc358743.h
 create mode 100644 include/media/tc358743_regs.h
 create mode 100644 include/media/tegra_camera_core.h
 create mode 100644 include/uapi/linux/avt-csi2.h
 create mode 100644 nvidia-oot/drivers/media/i2c/tc358743.c
 create mode 100644 nvidia-oot/include/media/tc358743.h
 create mode 100644 nvidia-oot/include/media/tc358743_regs.h

diff --git a/drivers/media/i2c/Makefile b/drivers/media/i2c/Makefile
new file mode 100644
index 0000000..cf35928
--- /dev/null
+++ b/drivers/media/i2c/Makefile
@@ -0,0 +1,30 @@
+# SPDX-License-Identifier: GPL-2.0-only
+# Copyright (c) 2023-2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
+
+subdir-ccflags-y += -Werror
+
+obj-m += max9295.o
+obj-m += max9296.o
+ifeq ($(findstring ack_src,$(NV_BUILD_KERNEL_OPTIONS)),)
+obj-m += max96712.o
+
+ifdef CONFIG_MEDIA_SUPPORT
+obj-m += ar1335_common.o
+obj-m += lt6911uxc.o
+obj-m += nv_imx185.o
+obj-m += nv_imx219.o
+obj-m += nv_imx274.o
+obj-m += nv_imx318.o
+obj-m += nv_imx390.o
+obj-m += nv_imx477.o
+obj-m += nv_ov5693.o
+obj-m += nv_ar0234.o
+obj-m += nv_hawk_owl.o
+obj-m += tc358743.o
+obj-m += avt-csi2-3.o
+obj-m += max929x.o
+endif
+
+obj-m += pca9570.o
+obj-m += virtual_i2c_mux.o
+endif
diff --git a/drivers/media/i2c/avt-csi2.c b/drivers/media/i2c/avt-csi2.c
new file mode 100644
index 0000000..c77b0e6
--- /dev/null
+++ b/drivers/media/i2c/avt-csi2.c
@@ -0,0 +1,5556 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2022 Avnet EMG GmbH
+ * Copyright (C) 2022 - 2024 Allied Vision Technologies GmbH
+ */
+
+/*
+ * Allied Vision CSI2 Camera
+ *
+ * This program is free software; you may redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ */
+
+//#define DEBUG
+#define ENABLE_STEPWISE_IMAGE_SIZE
+#define AVT_MAX_FORMAT_ENTRIES 40
+
+#include <asm/unaligned.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/clkdev.h>
+#include <linux/ctype.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/kthread.h>
+#include <linux/regmap.h>
+
+//#include <linux/sched/task.h>
+#include <linux/workqueue.h>
+#include <linux/of_device.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/gpio/consumer.h>
+#include <media/v4l2-async.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-rect.h>
+#include <linux/lcm.h>
+#include <linux/crc32.h>
+#include <linux/kthread.h>
+#include <linux/semaphore.h>
+
+
+#include "avt-mipi-csi2.h"
+
+// only for dma_get_cache_alignment();
+#include <linux/dma-mapping.h>
+
+#include "avt-csi2.h"
+
+#define AVT_DBG_LVL 2
+
+#ifdef DEBUG
+static int debug = AVT_DBG_LVL;
+#else
+static int debug = 0;
+#endif
+module_param(debug, int, 0644); /* S_IRUGO */
+MODULE_PARM_DESC(debug, "Debug level (0-2)");
+
+static int add_wait_time_ms = 2000;
+module_param(add_wait_time_ms, int, 0600);
+
+
+
+
+#define avt_dbg(sd, fmt, args...)                       \
+	v4l2_dbg(AVT_DBG_LVL, debug, sd, "%s[%d]: " fmt "", \
+			 __func__, __LINE__, ##args)
+
+#define avt_err(sd, fmt, args...) \
+	v4l2_err(sd, "%s[%d]: " fmt "", __func__, __LINE__, ##args)
+
+#define avt_warn(sd, fmt, args...) \
+	v4l2_warn(sd, "%s[%d]: " fmt "", __func__, __LINE__, ##args)
+
+#define avt_info(sd, fmt, args...) \
+	v4l2_info(sd, "%s[%d]: " fmt "", __func__, __LINE__, ##args)
+
+#define adev_info(dev, fmt, args...) \
+	dev_info(dev, "%s[%d]: " fmt "", __func__, __LINE__, ##args)
+
+struct avt_val64
+{
+	union
+	{
+		__s8 s8[8];
+		__s16 s16[4];
+		__s32 s32[2];
+		__s64 s64;
+		__u8 u8[8];
+		__u16 u16[4];
+		__u32 u32[2];
+		__u64 u64;
+	};
+} __attribute__((packed));
+
+#define BCRM_WAIT_HANDSHAKE_TIMEOUT_MS 	3000
+
+#define MODE_SWITCH_TIMEOUT_US		5 * USEC_PER_SEC
+#define MODE_SWTICH_POLL_INTERVAL_US	10 * USEC_PER_MSEC
+
+//Define formats for GenICam for CSI2, if they not exist
+#ifndef V4L2_PIX_FMT_CUSTOM
+#define V4L2_PIX_FMT_CUSTOM    v4l2_fourcc('T', 'P', '3', '1') /* 0x31 mipi datatype  */
+#endif
+
+#ifndef MEDIA_BUS_FMT_CUSTOM
+#define MEDIA_BUS_FMT_CUSTOM        		0x5002
+#endif
+
+#define AVT_BINNING_MODE_FLAG_AVERAGE 		0b01
+#define AVT_BINNING_MODE_FLAG_SUM 		0b10
+
+
+enum avt_binning_type {
+	NONE = -1,
+	DIGITAL,
+	SENSOR,
+};
+
+enum avt_reset_type {
+	RESET_TYPE_SOFT,
+	RESET_TYPE_HARD
+};
+
+struct avt_binning_setting {
+	int inq;
+	u8 sel;
+	u32 hfact;
+	u32 vfact;
+	enum avt_binning_type type;
+};
+
+struct avt_mode_info
+{
+	u32 hact;
+	u32 htot;
+	u32 vact;
+	u32 vtot;
+};
+
+
+static const long binning_modes_enabled[AVT_BINNING_TYPE_CNT] = {
+	[DIGITAL] = AVT_BINNING_MODE_FLAG_AVERAGE | AVT_BINNING_MODE_FLAG_SUM,
+	[SENSOR] = AVT_BINNING_MODE_FLAG_SUM,
+};
+
+static const char * binning_type_str[AVT_BINNING_TYPE_CNT] = {
+	[DIGITAL] = "Digital",
+	[SENSOR] = "Sensor",
+};
+
+static const struct avt_binning_setting avt_binning_settings[] = {
+	{
+		.inq = -1,
+		.sel = 0,
+		.vfact = 1,
+		.hfact = 1,
+		.type = NONE,
+	}, {
+		.inq = 0,
+		.sel = 1,
+		.vfact = 2,
+		.hfact = 2,
+		.type = DIGITAL,
+	}, {
+		.inq = 1,
+		.sel = 2,
+		.vfact = 3,
+		.hfact = 3,
+		.type = DIGITAL,
+	}, {
+		.inq = 2,
+		.sel = 3,
+		.vfact = 4,
+		.hfact = 4,
+		.type = DIGITAL,
+	}, {
+		.inq = 3,
+		.sel = 4,
+		.vfact = 5,
+		.hfact = 5,
+		.type = DIGITAL,
+	}, {
+		.inq = 4,
+		.sel = 5,
+		.vfact = 6,
+		.hfact = 6,
+		.type = DIGITAL,
+	}, {
+		.inq = 5,
+		.sel = 6,
+		.vfact = 7,
+		.hfact = 7,
+		.type = DIGITAL,
+	}, {
+		.inq = 6,
+		.sel = 7,
+		.vfact = 8,
+		.hfact = 8,
+		.type = DIGITAL,
+	}, {
+		.inq = 7,
+		.sel = 8,
+		.vfact = 2,
+		.hfact = 2,
+		.type = SENSOR,
+	}, {
+		.inq = 8,
+		.sel = 9,
+		.vfact = 4,
+		.hfact = 4,
+		.type = SENSOR,
+	},
+};
+
+static const size_t avt_binning_setting_cnt = ARRAY_SIZE(avt_binning_settings);
+
+static int bcrm_write(struct avt_dev *camera, u16 reg, u64 val, size_t len);
+
+static int avt_detect(struct i2c_client *client);
+static int avt_reset(struct avt_dev *camera, enum avt_reset_type reset_type);
+static void avt_dphy_reset(struct avt_dev *camera, bool bResetPhy);
+
+static void avt_ctrl_changed(struct avt_dev *camera, const struct v4l2_ctrl * const ctrl);
+static struct v4l2_ctrl* avt_ctrl_find(struct avt_dev *camera,u32 id);
+static int avt_write_media_bus_format(struct avt_dev *camera, int code);
+static int avt_get_sensor_capabilities(struct v4l2_subdev *sd);
+
+
+#define DUMP_BCRM_REG8(CLIENT, BCRM_REG) dump_bcrm_reg(CLIENT, (BCRM_REG), (#BCRM_REG), AV_CAM_DATA_SIZE_8)
+#define DUMP_BCRM_REG16(CLIENT, BCRM_REG) dump_bcrm_reg(CLIENT, (BCRM_REG), (#BCRM_REG), AV_CAM_DATA_SIZE_16)
+#define DUMP_BCRM_REG32(CLIENT, BCRM_REG) dump_bcrm_reg(CLIENT, (BCRM_REG), (#BCRM_REG), AV_CAM_DATA_SIZE_32)
+#define DUMP_BCRM_REG64(CLIENT, BCRM_REG) dump_bcrm_reg(CLIENT, (BCRM_REG), (#BCRM_REG), AV_CAM_DATA_SIZE_64)
+
+static void dump_bcrm_reg(struct i2c_client *client, u16 nOffset, const char *pRegName, int regsize);
+
+static inline struct avt_dev* to_avt_dev(struct v4l2_subdev *sd)
+{
+#ifdef NVIDIA
+	return container_of(sd, struct avt_dev, s_data.subdev);
+#else
+	return container_of(sd, struct avt_dev, subdev);
+#endif
+}
+
+static inline struct avt_dev* client_to_avt_dev(struct i2c_client *client)
+{
+	return to_avt_dev(i2c_get_clientdata(client));
+}
+
+static inline struct v4l2_subdev* get_sd(struct avt_dev *priv)
+{
+#ifdef NVIDIA
+	return &priv->s_data.subdev;
+#else
+	return &priv->subdev;
+#endif // #ifdef NVIDIA
+}
+
+
+static ssize_t avt_read_raw(struct avt_dev *camera, u16 reg,
+	u8 *buf, size_t len)
+{
+	int ret;
+
+	dev_dbg(&camera->i2c_client->dev, "read raw reg %x len %lu", reg, len);
+
+	ret = regmap_bulk_read(camera->regmap, reg, buf, len);
+	if (ret) {
+		return ret;
+	}
+
+	return len;
+}
+
+static ssize_t avt_write_raw(struct avt_dev *camera, u16 reg,
+	const u8 *buf, size_t len)
+{
+	int ret;
+
+	dev_dbg(&camera->i2c_client->dev, "write raw reg %x len %lu", reg, len);
+
+	ret = regmap_bulk_write(camera->regmap, reg, buf, len);
+	if (ret) {
+		return ret;
+	}
+
+	return len;
+}
+
+static ssize_t avt_read(struct avt_dev *camera, u16 reg, void *val, size_t len)
+{
+	u8 tmp[8];
+	int ret;
+
+	ret = avt_read_raw(camera, reg, tmp, len);
+	if (ret < 0)
+		goto out;
+
+	switch (len)
+	{
+	case 1:
+		*((u8*)val) = tmp[0];
+		break;
+	case 2:
+		*((u16*)val) = get_unaligned_be16(tmp);
+		break;
+	case 4:
+		*((u32*)val) = get_unaligned_be32(tmp);
+		break;
+	case 8:
+		*((u64*)val) = get_unaligned_be64(tmp);
+		break;
+	default:
+		break;
+	}
+
+	// TODO: For compatibility reason, check if can be removed
+	ret = 0;
+
+out:
+	return ret;
+}
+
+static inline ssize_t avt_read8(struct avt_dev *camera, u16 reg, u8 *val)
+{
+	return avt_read(camera, reg, (u8*)val, sizeof(*val));
+}
+
+static inline ssize_t avt_read16(struct avt_dev *camera, u16 reg, u16 *val)
+{
+	return avt_read(camera, reg, (u8*)val, sizeof(*val));
+}
+
+static inline ssize_t avt_read32(struct avt_dev *camera, u16 reg, u32 *val)
+{
+	return avt_read(camera, reg, (u8*)val, sizeof(*val));
+}
+
+static inline ssize_t avt_read64(struct avt_dev *camera, u16 reg, u64 *val)
+{
+	return avt_read(camera, reg, (u8*)val, sizeof(*val));
+}
+
+static ssize_t avt_write(struct avt_dev *camera, u16 reg, u64 val, size_t len)
+{
+	struct device *dev = &camera->i2c_client->dev;
+	u8 buf[8];
+	int ret;
+
+	switch (len)
+	{
+	// 8-bit register
+	case 1:
+		buf[0] = val;
+		break;
+	// 16-bit register
+	case 2:
+		put_unaligned_be16(val, buf);
+		break;
+	// 32-bit register
+	case 4:
+		put_unaligned_be32(val, buf);
+		break;
+	// 64-bit register
+	case 8:
+		put_unaligned_be64(val, buf);
+		break;
+	default:
+		dev_err(dev, "%s: Invalid data size!\n", __func__);
+		return -EINVAL;
+	}
+
+	ret = avt_write_raw(camera, reg, buf, len);
+	// TODO: For compatibility reason, check if can be removed
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static inline u16 get_bcrm_addr(struct avt_dev *camera,u16 reg)
+{
+	return camera->cci_reg.reg.bcrm_addr + reg;
+}
+
+static inline int bcrm_read(struct avt_dev *camera, u16 reg, u8 *val, size_t len)
+{
+	WARN_ON(camera->mode != AVT_BCRM_MODE);
+
+	return avt_read(camera, get_bcrm_addr(camera, reg), val, len);
+}
+
+static inline int bcrm_read8(struct avt_dev *camera,u16 reg,u8 *val)
+{
+	return bcrm_read(camera, reg, (u8*)val, sizeof(*val));
+}
+
+static inline int bcrm_read16(struct avt_dev *camera,u16 reg,u16 *val)
+{
+	return bcrm_read(camera, reg, (u8*)val, sizeof(*val));
+}
+
+static inline int bcrm_read32(struct avt_dev *camera,u16 reg,u32 *val)
+{
+	return bcrm_read(camera, reg, (u8*)val, sizeof(*val));
+}
+
+static inline int bcrm_read64(struct avt_dev *camera,u16 reg,u64 *val)
+{
+	return bcrm_read(camera, reg, (u8*)val, sizeof(*val));
+}
+
+static inline int bcrm_write8(struct avt_dev *camera, u16 reg, u8 val)
+{
+	return bcrm_write(camera, reg, val, sizeof(val));
+}
+
+static inline int bcrm_write16(struct avt_dev *camera, u16 reg, u16 val)
+{
+	return bcrm_write(camera, reg, val, sizeof(val));
+}
+
+static inline int bcrm_write32(struct avt_dev *camera, u16 reg, u32 val)
+{
+	return bcrm_write(camera, reg, val, sizeof(val));
+}
+
+static inline int bcrm_write64(struct avt_dev *camera, u16 reg, u64 val)
+{
+	return bcrm_write(camera, reg, val, sizeof(val));
+}
+
+static int avt_change_mode(struct avt_dev *camera, u8 req_mode)
+{
+	int ret;
+	u8 cur_mode;
+
+	if (req_mode == camera->mode)
+		return 0;
+
+	ret = avt_write(camera, GENCP_CHANGEMODE_8W, req_mode, AV_CAM_DATA_SIZE_8);
+	if (ret < 0)
+		goto out;
+
+
+	ret = read_poll_timeout(avt_read8, ret, cur_mode == req_mode,
+				MODE_SWTICH_POLL_INTERVAL_US,
+				MODE_SWITCH_TIMEOUT_US, true,
+				camera, GENCP_CURRENTMODE_8R, &cur_mode);
+	if (ret < 0)
+		goto out;
+
+	camera->mode = req_mode;
+
+	if (req_mode == AVT_BCRM_MODE) {
+		const int mbus_code = camera->mbus_framefmt.code;
+		ret = avt_write_media_bus_format(camera, mbus_code);
+
+		if (ret < 0) {
+			avt_err(get_sd(camera),"Failed to set pixelformat!");
+		}
+	}
+
+out:
+	return ret;
+}
+
+static void bcrm_dump(struct i2c_client *client)
+{
+	/* Dump all BCRM registers */
+
+	DUMP_BCRM_REG32(client, BCRM_VERSION_32R);
+	DUMP_BCRM_REG64(client, BCRM_FEATURE_INQUIRY_64R);
+	DUMP_BCRM_REG64(client, BCRM_DEVICE_FIRMWARE_VERSION_64R);
+	DUMP_BCRM_REG8(client, BCRM_WRITE_HANDSHAKE_8RW);
+
+	/* Streaming Control Registers */
+	DUMP_BCRM_REG8(client, BCRM_SUPPORTED_CSI2_LANE_COUNTS_8R);
+	DUMP_BCRM_REG8(client, BCRM_CSI2_LANE_COUNT_8RW);
+	DUMP_BCRM_REG32(client, BCRM_CSI2_CLOCK_MIN_32R);
+	DUMP_BCRM_REG32(client, BCRM_CSI2_CLOCK_MAX_32R);
+	DUMP_BCRM_REG32(client, BCRM_CSI2_CLOCK_32RW);
+	DUMP_BCRM_REG32(client, BCRM_BUFFER_SIZE_32R);
+	DUMP_BCRM_REG32(client, BCRM_PHY_RESET_8RW);
+	DUMP_BCRM_REG32(client, BCRM_STREAM_ON_DELAY_32RW);
+
+	DUMP_BCRM_REG32(client, BCRM_IPU_X_MIN_32W);
+	DUMP_BCRM_REG32(client, BCRM_IPU_X_MAX_32W);
+	DUMP_BCRM_REG32(client, BCRM_IPU_X_INC_32W);
+	DUMP_BCRM_REG32(client, BCRM_IPU_Y_MIN_32W);
+	DUMP_BCRM_REG32(client, BCRM_IPU_Y_MAX_32W);
+	DUMP_BCRM_REG32(client, BCRM_IPU_Y_INC_32W);
+	DUMP_BCRM_REG32(client, BCRM_IPU_X_32R);
+	DUMP_BCRM_REG32(client, BCRM_IPU_Y_32R);
+
+	/* Acquisition Control Registers */
+	DUMP_BCRM_REG8(client, BCRM_ACQUISITION_START_8RW);
+	DUMP_BCRM_REG8(client, BCRM_ACQUISITION_STOP_8RW);
+	DUMP_BCRM_REG8(client, BCRM_ACQUISITION_ABORT_8RW);
+	DUMP_BCRM_REG8(client, BCRM_ACQUISITION_STATUS_8R);
+	DUMP_BCRM_REG64(client, BCRM_ACQUISITION_FRAME_RATE_64RW);
+	DUMP_BCRM_REG64(client, BCRM_ACQUISITION_FRAME_RATE_MIN_64R);
+	DUMP_BCRM_REG64(client, BCRM_ACQUISITION_FRAME_RATE_MAX_64R);
+	DUMP_BCRM_REG64(client, BCRM_ACQUISITION_FRAME_RATE_INC_64R);
+	DUMP_BCRM_REG8(client, BCRM_ACQUISITION_FRAME_RATE_ENABLE_8RW);
+
+	DUMP_BCRM_REG8(client, BCRM_FRAME_START_TRIGGER_MODE_8RW);
+	DUMP_BCRM_REG8(client, BCRM_FRAME_START_TRIGGER_SOURCE_8RW);
+	DUMP_BCRM_REG8(client, BCRM_FRAME_START_TRIGGER_ACTIVATION_8RW);
+	DUMP_BCRM_REG8(client, BCRM_FRAME_START_TRIGGER_SOFTWARE_8W);
+	DUMP_BCRM_REG32(client, BCRM_FRAME_START_TRIGGER_DELAY_32RW);
+
+	DUMP_BCRM_REG8(client, BCRM_EXPOSURE_ACTIVE_LINE_MODE_8RW);
+	DUMP_BCRM_REG8(client, BCRM_EXPOSURE_ACTIVE_LINE_SELECTOR_8RW);
+	DUMP_BCRM_REG32(client, BCRM_LINE_CONFIGURATION_32RW);
+
+	/* Image Format Control Registers */
+	DUMP_BCRM_REG32(client, BCRM_IMG_WIDTH_32RW);
+	DUMP_BCRM_REG32(client, BCRM_IMG_WIDTH_MIN_32R);
+	DUMP_BCRM_REG32(client, BCRM_IMG_WIDTH_MAX_32R);
+	DUMP_BCRM_REG32(client, BCRM_IMG_WIDTH_INC_32R);
+
+	DUMP_BCRM_REG32(client, BCRM_IMG_HEIGHT_32RW);
+	DUMP_BCRM_REG32(client, BCRM_IMG_HEIGHT_MIN_32R);
+	DUMP_BCRM_REG32(client, BCRM_IMG_HEIGHT_MAX_32R);
+	DUMP_BCRM_REG32(client, BCRM_IMG_HEIGHT_INC_32R);
+
+	DUMP_BCRM_REG32(client, BCRM_IMG_OFFSET_X_32RW);
+	DUMP_BCRM_REG32(client, BCRM_IMG_OFFSET_X_MIN_32R);
+	DUMP_BCRM_REG32(client, BCRM_IMG_OFFSET_X_MAX_32R);
+	DUMP_BCRM_REG32(client, BCRM_IMG_OFFSET_X_INC_32R);
+
+	DUMP_BCRM_REG32(client, BCRM_IMG_OFFSET_Y_32RW);
+	DUMP_BCRM_REG32(client, BCRM_IMG_OFFSET_Y_MIN_32R);
+	DUMP_BCRM_REG32(client, BCRM_IMG_OFFSET_Y_MAX_32R);
+	DUMP_BCRM_REG32(client, BCRM_IMG_OFFSET_Y_INC_32R);
+
+	DUMP_BCRM_REG32(client, BCRM_IMG_MIPI_DATA_FORMAT_32RW);
+	DUMP_BCRM_REG64(client, BCRM_IMG_AVAILABLE_MIPI_DATA_FORMATS_64R);
+
+	DUMP_BCRM_REG8(client, BCRM_IMG_BAYER_PATTERN_INQUIRY_8R);
+	DUMP_BCRM_REG8(client, BCRM_IMG_BAYER_PATTERN_8RW);
+
+	DUMP_BCRM_REG8(client, BCRM_IMG_REVERSE_X_8RW);
+	DUMP_BCRM_REG8(client, BCRM_IMG_REVERSE_Y_8RW);
+
+	DUMP_BCRM_REG32(client, BCRM_SENSOR_WIDTH_32R);
+	DUMP_BCRM_REG32(client, BCRM_SENSOR_HEIGHT_32R);
+
+	DUMP_BCRM_REG32(client, BCRM_WIDTH_MAX_32R);
+	DUMP_BCRM_REG32(client, BCRM_HEIGHT_MAX_32R);
+
+	/* Brightness Control Registers */
+	DUMP_BCRM_REG64(client, BCRM_EXPOSURE_TIME_64RW);
+	DUMP_BCRM_REG64(client, BCRM_EXPOSURE_TIME_MIN_64R);
+	DUMP_BCRM_REG64(client, BCRM_EXPOSURE_TIME_MAX_64R);
+	DUMP_BCRM_REG64(client, BCRM_EXPOSURE_TIME_64RW);
+	DUMP_BCRM_REG8(client, BCRM_EXPOSURE_AUTO_8RW);
+
+	DUMP_BCRM_REG8(client, BCRM_INTENSITY_AUTO_PRECEDENCE_8RW);
+	DUMP_BCRM_REG32(client, BCRM_INTENSITY_AUTO_PRECEDENCE_VALUE_32RW);
+	DUMP_BCRM_REG32(client, BCRM_INTENSITY_AUTO_PRECEDENCE_MIN_32R);
+	DUMP_BCRM_REG32(client, BCRM_INTENSITY_AUTO_PRECEDENCE_MAX_32R);
+	DUMP_BCRM_REG32(client, BCRM_INTENSITY_AUTO_PRECEDENCE_INC_32R);
+
+	DUMP_BCRM_REG32(client, BCRM_BLACK_LEVEL_32RW);
+	DUMP_BCRM_REG32(client, BCRM_BLACK_LEVEL_MIN_32R);
+	DUMP_BCRM_REG32(client, BCRM_BLACK_LEVEL_MAX_32R);
+	DUMP_BCRM_REG32(client, BCRM_BLACK_LEVEL_INC_32R);
+
+	DUMP_BCRM_REG64(client, BCRM_GAIN_64RW);
+	DUMP_BCRM_REG64(client, BCRM_GAIN_MIN_64R);
+	DUMP_BCRM_REG64(client, BCRM_GAIN_MAX_64R);
+	DUMP_BCRM_REG64(client, BCRM_GAIN_INC_64R);
+	DUMP_BCRM_REG8(client, BCRM_GAIN_AUTO_8RW);
+
+	DUMP_BCRM_REG64(client, BCRM_GAMMA_64RW);
+	DUMP_BCRM_REG64(client, BCRM_GAMMA_MIN_64R);
+	DUMP_BCRM_REG64(client, BCRM_GAMMA_MAX_64R);
+	DUMP_BCRM_REG64(client, BCRM_GAMMA_INC_64R);
+
+	DUMP_BCRM_REG32(client, BCRM_CONTRAST_VALUE_32RW);
+	DUMP_BCRM_REG32(client, BCRM_CONTRAST_VALUE_MIN_32R);
+	DUMP_BCRM_REG32(client, BCRM_CONTRAST_VALUE_MAX_32R);
+	DUMP_BCRM_REG32(client, BCRM_CONTRAST_VALUE_INC_32R);
+
+	/* Color Management Registers */
+	DUMP_BCRM_REG32(client, BCRM_SATURATION_32RW);
+	DUMP_BCRM_REG32(client, BCRM_SATURATION_MIN_32R);
+	DUMP_BCRM_REG32(client, BCRM_SATURATION_MAX_32R);
+	DUMP_BCRM_REG32(client, BCRM_SATURATION_INC_32R);
+
+	DUMP_BCRM_REG32(client, BCRM_HUE_32RW);
+	DUMP_BCRM_REG32(client, BCRM_HUE_MIN_32R);
+	DUMP_BCRM_REG32(client, BCRM_HUE_MAX_32R);
+	DUMP_BCRM_REG32(client, BCRM_HUE_INC_32R);
+
+	DUMP_BCRM_REG64(client, BCRM_ALL_BALANCE_RATIO_64RW);
+	DUMP_BCRM_REG64(client, BCRM_ALL_BALANCE_RATIO_MIN_64R);
+	DUMP_BCRM_REG64(client, BCRM_ALL_BALANCE_RATIO_MAX_64R);
+
+	DUMP_BCRM_REG64(client, BCRM_RED_BALANCE_RATIO_64RW);
+	DUMP_BCRM_REG64(client, BCRM_RED_BALANCE_RATIO_MIN_64R);
+	DUMP_BCRM_REG64(client, BCRM_RED_BALANCE_RATIO_MAX_64R);
+	DUMP_BCRM_REG64(client, BCRM_RED_BALANCE_RATIO_INC_64R);
+
+	DUMP_BCRM_REG64(client, BCRM_GREEN_BALANCE_RATIO_64RW);
+	DUMP_BCRM_REG64(client, BCRM_GREEN_BALANCE_RATIO_MIN_64R);
+	DUMP_BCRM_REG64(client, BCRM_GREEN_BALANCE_RATIO_MAX_64R);
+	DUMP_BCRM_REG64(client, BCRM_GREEN_BALANCE_RATIO_INC_64R);
+
+	DUMP_BCRM_REG64(client, BCRM_BLUE_BALANCE_RATIO_64RW);
+	DUMP_BCRM_REG64(client, BCRM_BLUE_BALANCE_RATIO_MIN_64R);
+	DUMP_BCRM_REG64(client, BCRM_BLUE_BALANCE_RATIO_MAX_64R);
+	DUMP_BCRM_REG64(client, BCRM_BLUE_BALANCE_RATIO_INC_64R);
+
+	DUMP_BCRM_REG8(client, BCRM_WHITE_BALANCE_AUTO_8RW);
+
+	/* Other Registers */
+	DUMP_BCRM_REG32(client, BCRM_SHARPNESS_32RW);
+	DUMP_BCRM_REG32(client, BCRM_SHARPNESS_MIN_32R);
+	DUMP_BCRM_REG32(client, BCRM_SHARPNESS_MAX_32R);
+	DUMP_BCRM_REG32(client, BCRM_SHARPNESS_INC_32R);
+
+	DUMP_BCRM_REG32(client, BCRM_DEVICE_TEMPERATURE_32R);
+
+	DUMP_BCRM_REG64(client, BCRM_EXPOSURE_AUTO_MIN_64RW);
+	DUMP_BCRM_REG64(client, BCRM_EXPOSURE_AUTO_MAX_64RW);
+
+	DUMP_BCRM_REG16(client, BCRM_BINNING_INQ_16R);
+	DUMP_BCRM_REG16(client, BCRM_BINNING_INQ_16R);
+}
+
+static void dump_bcrm_reg(struct i2c_client *client, u16 nOffset, const char *pRegName, int regsize)
+{
+	struct avt_dev *camera = client_to_avt_dev(client);
+	int status = 0;
+	struct avt_val64 val64;
+
+	CLEAR(val64);
+
+	if (status >= 0)
+		switch (regsize)
+		{
+		case AV_CAM_DATA_SIZE_8:
+			bcrm_read8(camera, nOffset, &val64.u8[0]);
+			avt_info(get_sd(camera), "%44s: %u (0x%x)", pRegName, val64.u8[0], val64.u8[0]);
+			break;
+		case AV_CAM_DATA_SIZE_16:
+			bcrm_read16(camera, nOffset, &val64.u16[0]);
+			avt_info(get_sd(camera), "%44s: %u (0x%08x)", pRegName, val64.u16[0], val64.u16[0]);
+			break;
+		case AV_CAM_DATA_SIZE_32:
+			bcrm_read32(camera, nOffset, &val64.u32[0]);
+			avt_info(get_sd(camera), "%44s: %u (0x%08x)", pRegName, val64.u32[0], val64.u32[0]);
+			break;
+		case AV_CAM_DATA_SIZE_64:
+			bcrm_read64(camera, nOffset, &val64.u64);
+			avt_info(get_sd(camera), "%44s: %llu (0x%016llx)", pRegName, val64.u64, val64.u64);
+			break;
+		}
+	else
+		avt_err(get_sd(camera), "%s: ERROR", pRegName);
+}
+
+static bool bcrm_get_write_handshake_availibility(struct i2c_client *client)
+{
+	struct avt_dev *camera = client_to_avt_dev(client);
+	u8 value = 0;
+	int status;
+
+	if (!camera)
+	{
+		avt_err(get_sd(camera), "camera == NULL!!!\n");
+		return -EINVAL;
+	}
+	/* check of camera supports write_done_handshake register */
+	status = bcrm_read8(camera, BCRM_WRITE_HANDSHAKE_8RW, &value);
+
+	if ((status >= 0) && (value & BCRM_HANDSHAKE_AVAILABLE_MASK))
+	{
+		avt_info(get_sd(camera), "BCRM write handshake supported!");
+		return true;
+	}
+	else
+	{
+		avt_info(get_sd(camera), "BCRM write handshake NOT supported!");
+		return false;
+	}
+}
+
+static int read_cci_registers(struct i2c_client *client)
+{
+	struct avt_dev *camera = client_to_avt_dev(client);
+
+	int ret = 0;
+	uint32_t crc = 0;
+	uint32_t crc_byte_count = 0;
+
+	if (!camera)
+	{
+		avt_err(get_sd(camera), "camera == NULL!!!");
+		return -EINVAL;
+	}
+
+	mutex_lock(&camera->lock);
+
+	/*
+	 * ToDO: Check against latest spec!!
+	 * Avoid last 3 bytes read as its WRITE only register except
+	 * CURRENT MODE REG
+	 */
+	/* Calculate byte per byte CRC from each reg up to the CRC reg */
+	crc_byte_count =
+		(uint32_t)((char *)&camera->cci_reg.reg.checksum - (char *)&camera->cci_reg);
+
+	avt_dbg(get_sd(camera), "crc_byte_count: %d", crc_byte_count);
+	avt_dbg(get_sd(camera), "0x%08X, 0x%08X",
+			cci_cmd_tbl[CCI_REGISTER_LAYOUT_VERSION].address,
+			cci_cmd_tbl[CHANGE_MODE].address);
+
+	// read only until CHANGE_MODE because it's writeonly
+	ret = avt_read_raw(camera, cci_cmd_tbl[CCI_REGISTER_LAYOUT_VERSION].address,
+						   (char *)&camera->cci_reg, cci_cmd_tbl[CHANGE_MODE].address);
+
+	avt_info(get_sd(camera), "regmap_bulk_read(camera->regmap8, cci_cmd_tbl[CCI_REGISTER_LAYOUT_VERSION].address ret %d\n", ret);
+
+	avt_dbg(get_sd(camera), "0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X - 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X\n",
+			camera->cci_reg.buf[0x00], camera->cci_reg.buf[0x01], camera->cci_reg.buf[0x02], camera->cci_reg.buf[0x03],
+			camera->cci_reg.buf[0x04], camera->cci_reg.buf[0x05], camera->cci_reg.buf[0x06], camera->cci_reg.buf[0x07],
+			camera->cci_reg.buf[0x08], camera->cci_reg.buf[0x09], camera->cci_reg.buf[0x0a], camera->cci_reg.buf[0x0b],
+			camera->cci_reg.buf[0x0c], camera->cci_reg.buf[0x0d], camera->cci_reg.buf[0x0e], camera->cci_reg.buf[0x0f]);
+
+	avt_dbg(get_sd(camera), "0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X - 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X\n",
+			camera->cci_reg.buf[0x10], camera->cci_reg.buf[0x11], camera->cci_reg.buf[0x12], camera->cci_reg.buf[0x13],
+			camera->cci_reg.buf[0x14], camera->cci_reg.buf[0x15], camera->cci_reg.buf[0x16], camera->cci_reg.buf[0x17],
+			camera->cci_reg.buf[0x18], camera->cci_reg.buf[0x19], camera->cci_reg.buf[0x1a], camera->cci_reg.buf[0x1b],
+			camera->cci_reg.buf[0x1c], camera->cci_reg.buf[0x1d], camera->cci_reg.buf[0x1e], camera->cci_reg.buf[0x1f]);
+
+	avt_dbg(get_sd(camera), "0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X - 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X\n",
+			camera->cci_reg.buf[0x20], camera->cci_reg.buf[0x21], camera->cci_reg.buf[0x22], camera->cci_reg.buf[0x23],
+			camera->cci_reg.buf[0x24], camera->cci_reg.buf[0x25], camera->cci_reg.buf[0x26], camera->cci_reg.buf[0x27],
+			camera->cci_reg.buf[0x28], camera->cci_reg.buf[0x29], camera->cci_reg.buf[0x1a], camera->cci_reg.buf[0x2b],
+			camera->cci_reg.buf[0x2c], camera->cci_reg.buf[0x2d], camera->cci_reg.buf[0x2e], camera->cci_reg.buf[0x2f]);
+
+	avt_dbg(get_sd(camera), "0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X - 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X\n",
+			camera->cci_reg.buf[0x30], camera->cci_reg.buf[0x31], camera->cci_reg.buf[0x32], camera->cci_reg.buf[0x33],
+			camera->cci_reg.buf[0x34], camera->cci_reg.buf[0x35], camera->cci_reg.buf[0x36], camera->cci_reg.buf[0x37],
+			camera->cci_reg.buf[0x38], camera->cci_reg.buf[0x39], camera->cci_reg.buf[0x1a], camera->cci_reg.buf[0x3b],
+			camera->cci_reg.buf[0x3c], camera->cci_reg.buf[0x3d], camera->cci_reg.buf[0x3e], camera->cci_reg.buf[0x3f]);
+
+	if (ret < 0)
+	{
+		avt_err(get_sd(camera), "regmap_read failed (%d)\n", ret);
+		goto err_out;
+	}
+
+	/* CRC calculation */
+	crc = crc32(U32_MAX, &camera->cci_reg, crc_byte_count);
+
+	dev_info(&client->dev, "cci layout version b: 0x%08X\n",
+			 camera->cci_reg.reg.layout_version);
+	/* Swap bytes if neccessary */
+	cpu_to_be32s(&camera->cci_reg.reg.layout_version);
+
+	dev_info(&client->dev, "cci layout version a: 0x%08X\n",
+			 camera->cci_reg.reg.layout_version);
+
+	cpu_to_be64s(&camera->cci_reg.reg.device_capabilities.value);
+	cpu_to_be16s(&camera->cci_reg.reg.gcprm_address);
+	cpu_to_be16s(&camera->cci_reg.reg.bcrm_addr);
+	cpu_to_be32s(&camera->cci_reg.reg.checksum);
+
+	/* Check the checksum of received with calculated. */
+	if (crc != camera->cci_reg.reg.checksum)
+	{
+		avt_err(get_sd(camera), "wrong CCI CRC value! calculated = 0x%x, received = 0x%x\n",
+				crc, camera->cci_reg.reg.checksum);
+		ret = -EINVAL;
+		goto err_out;
+	}
+
+	avt_dbg(get_sd(camera), "cci layout version: 0x%08X\ncci device capabilities: %llx\ncci device guid: %s\ncci gcprm_address: 0x%x\n",
+			camera->cci_reg.reg.layout_version,
+			camera->cci_reg.reg.device_capabilities.value,
+			camera->cci_reg.reg.device_guid,
+			camera->cci_reg.reg.gcprm_address);
+
+	ret = 0;
+err_out:
+
+	mutex_unlock(&camera->lock);
+
+	return ret;
+}
+
+static int read_gencp_registers(struct i2c_client *client)
+{
+	struct avt_dev *camera = client_to_avt_dev(client);
+
+	int ret = 0;
+	uint32_t crc = 0;
+	uint32_t crc_byte_count = 0;
+
+	uint32_t i2c_reg;
+	uint32_t i2c_reg_size;
+	uint32_t i2c_reg_count;
+
+	char *i2c_reg_buf;
+
+	mutex_lock(&camera->lock);
+	avt_dbg(get_sd(camera), "+");
+
+	i2c_reg = camera->cci_reg.reg.gcprm_address + 0x0000;
+	i2c_reg_size = AV_CAM_REG_SIZE;
+	i2c_reg_count = sizeof(camera->gencp_reg);
+	i2c_reg_buf = (char *)&camera->gencp_reg;
+
+	/* Calculate CRC from each reg up to the CRC reg */
+	crc_byte_count =
+		(uint32_t)((char *)&camera->gencp_reg.checksum - (char *)&camera->gencp_reg);
+
+	ret = avt_read_raw(camera, camera->cci_reg.reg.gcprm_address + 0x0000,
+		(char *)&camera->gencp_reg, sizeof(camera->gencp_reg));
+
+	if (ret < 0)
+	{
+		avt_err(get_sd(camera), "regmap_read failed, ret %d", ret);
+		goto err_out;
+	}
+
+	crc = crc32(U32_MAX, &camera->gencp_reg, crc_byte_count);
+
+	be32_to_cpus(&camera->gencp_reg.gcprm_layout_version);
+	be16_to_cpus(&camera->gencp_reg.gencp_out_buffer_address);
+	be16_to_cpus(&camera->gencp_reg.gencp_in_buffer_address);
+	be16_to_cpus(&camera->gencp_reg.gencp_out_buffer_size);
+	be16_to_cpus(&camera->gencp_reg.gencp_in_buffer_size);
+	be32_to_cpus(&camera->gencp_reg.checksum);
+
+	if (crc != camera->gencp_reg.checksum)
+	{
+		avt_warn(get_sd(camera), "wrong GENCP CRC value! calculated = 0x%x, received = 0x%x\n",
+				crc, camera->gencp_reg.checksum);
+	}
+
+	avt_dbg(get_sd(camera), "gcprm layout version: %x\n",
+			camera->gencp_reg.gcprm_layout_version);
+	avt_dbg(get_sd(camera), "gcprm out buf addr: %x\n",
+			camera->gencp_reg.gencp_out_buffer_address);
+	avt_dbg(get_sd(camera), "gcprm out buf size: %x\n",
+			camera->gencp_reg.gencp_out_buffer_size);
+	avt_dbg(get_sd(camera), "gcprm in buf addr: %x\n",
+			camera->gencp_reg.gencp_in_buffer_address);
+	avt_dbg(get_sd(camera), "gcprm in buf size: %x\n",
+			camera->gencp_reg.gencp_in_buffer_size);
+
+err_out:
+	mutex_unlock(&camera->lock);
+
+	return ret;
+}
+
+static int cci_version_check(struct i2c_client *client)
+{
+	struct avt_dev *camera = client_to_avt_dev(client);
+	uint32_t cci_minver, cci_majver;
+	int ret = 0;
+
+	mutex_lock(&camera->lock);
+
+	cci_minver = (camera->cci_reg.reg.layout_version & CCI_REG_LAYOUT_MINVER_MASK) >> CCI_REG_LAYOUT_MINVER_SHIFT;
+
+	if (cci_minver >= CCI_REG_LAYOUT_MINVER)
+	{
+		avt_dbg(get_sd(camera), "correct cci register minver: %d (0x%x)\n",
+				cci_minver, camera->cci_reg.reg.layout_version);
+	}
+	else
+	{
+		avt_err(get_sd(camera), "cci reg minver mismatch! read: %d (0x%x) expected: %d\n",
+				cci_minver, camera->cci_reg.reg.layout_version, CCI_REG_LAYOUT_MINVER);
+		ret = -EINVAL;
+		goto err_out;
+	}
+
+	cci_majver = (camera->cci_reg.reg.layout_version & CCI_REG_LAYOUT_MAJVER_MASK) >> CCI_REG_LAYOUT_MAJVER_SHIFT;
+
+	if (cci_majver == CCI_REG_LAYOUT_MAJVER)
+	{
+		avt_dbg(get_sd(camera), "correct cci register majver: %d (0x%x)\n",
+				cci_majver, camera->cci_reg.reg.layout_version);
+	}
+	else
+	{
+		avt_err(get_sd(camera), "cci reg majver mismatch! read: %d (0x%x) expected: %d\n",
+				cci_majver, camera->cci_reg.reg.layout_version, CCI_REG_LAYOUT_MAJVER);
+		ret = -EINVAL;
+		goto err_out;
+	}
+
+err_out:
+	mutex_unlock(&camera->lock);
+
+	return ret;
+}
+
+static int bcrm_version_check(struct i2c_client *client)
+{
+	struct avt_dev *camera = client_to_avt_dev(client);
+	u32 value = 0;
+	int ret;
+
+	mutex_lock(&camera->lock);
+	/* reading the BCRM version */
+	ret = bcrm_read32(camera,BCRM_VERSION_32R,&value);
+
+	if (ret < 0)
+	{
+		avt_err(get_sd(camera), "regmap_read failed (%d)", ret);
+		goto err_out;
+	}
+
+	avt_dbg(get_sd(camera), "bcrm version (driver): 0x%x (maj: 0x%x min: 0x%x)\n",
+			BCRM_DEVICE_VERSION,
+			BCRM_MAJOR_VERSION,
+			BCRM_MINOR_VERSION);
+
+	avt_dbg(get_sd(camera), "bcrm version (camera): 0x%x (maj: 0x%x min: 0x%x)\n",
+			value,
+			(value & 0xffff0000) >> 16,
+			(value & 0x0000ffff));
+
+	ret = (value >> 16) == BCRM_MAJOR_VERSION ? 1 : 0;
+
+err_out:
+	mutex_unlock(&camera->lock);
+
+	return ret;
+}
+
+static int gcprm_version_check(struct i2c_client *client)
+{
+	struct avt_dev *camera = client_to_avt_dev(client);
+	u32 value = camera->gencp_reg.gcprm_layout_version;
+
+	mutex_lock(&camera->lock);
+	avt_dbg(get_sd(camera), "gcprm version (driver): 0x%x (maj: 0x%x min: 0x%x)\n",
+			GCPRM_DEVICE_VERSION,
+			GCPRM_MAJOR_VERSION,
+			GCPRM_MINOR_VERSION);
+
+	avt_dbg(get_sd(camera), "gcprm version (camera): 0x%x (maj: 0x%x min: 0x%x)\n",
+			value,
+			(value & 0xffff0000) >> 16,
+			(value & 0x0000ffff));
+	mutex_unlock(&camera->lock);
+
+	return (value & 0xffff0000) >> 16 == GCPRM_MAJOR_VERSION ? 1 : 0;
+}
+
+/* implementation of driver attibutes published in sysfs */
+
+static ssize_t availability_show(struct device *dev,
+								 struct device_attribute *attr, char *buf)
+{
+	struct avt_dev *camera = client_to_avt_dev(to_i2c_client(dev));
+	ssize_t ret;
+
+	mutex_lock(&camera->lock);
+
+	dev_info(dev, "%s[%d]: %s", __func__, __LINE__, __FILE__);
+	ret = sprintf(buf, "%d\n", camera->open_refcnt == 0 ? 1 : 0);
+
+	mutex_unlock(&camera->lock);
+
+	return ret;
+}
+
+static ssize_t cci_register_layout_version_show(struct device *dev,
+												struct device_attribute *attr, char *buf)
+{
+	struct avt_dev *camera = client_to_avt_dev(to_i2c_client(dev));
+	ssize_t ret;
+
+	mutex_lock(&camera->lock);
+	ret = sprintf(buf, "%d\n", camera->cci_reg.reg.layout_version);
+	mutex_unlock(&camera->lock);
+
+	return ret;
+}
+
+static ssize_t bcrm_feature_inquiry_reg_show(struct device *dev,
+											 struct device_attribute *attr, char *buf)
+{
+	struct avt_dev *camera = client_to_avt_dev(to_i2c_client(dev));
+	ssize_t ret;
+	union bcrm_feature_inquiry_reg feature_inquiry_reg;
+
+	/* reading the Feature inquiry register */
+	ret = bcrm_read64(camera, BCRM_FEATURE_INQUIRY_64R, &feature_inquiry_reg.value);
+
+	if (ret < 0)
+	{
+		avt_err(get_sd(camera), "regmap_bulk_read BCRM_FEATURE_INQUIRY_64R failed (%ld)", ret);
+		return ret;
+	}
+
+	ret = sprintf(buf, "0x%016llX\n", feature_inquiry_reg.value);
+
+	return ret;
+}
+
+static ssize_t bcrm_feature_inquiry_reg_text_show(struct device *dev,
+												  struct device_attribute *attr, char *buf)
+{
+	struct avt_dev *camera = client_to_avt_dev(to_i2c_client(dev));
+	ssize_t ret = 0;
+
+	ret = sprintf(buf, "reverse_x_avail                 %d\n"
+					   "reverse_y_avail                 %d\n"
+					   "intensity_auto_precedence_avail %d\n"
+					   "black_level_avail               %d\n"
+					   "gain_avail                      %d\n"
+					   "gamma_avail                     %d\n"
+					   "contrast_avail                  %d\n"
+					   "saturation_avail                %d\n"
+					   "hue_avail                       %d\n"
+					   "white_balance_avail             %d\n"
+					   "sharpness_avail                 %d\n"
+					   "exposure_auto                   %d\n"
+					   "gain_auto                       %d\n"
+					   "white_balance_auto_avail        %d\n"
+					   "device_temperature_avail        %d\n"
+					   "acquisition_abort               %d\n"
+					   "acquisition_frame_rate          %d\n"
+					   "frame_trigger                   %d\n"
+					   "exposure active line available  %d\n",
+				  camera->feature_inquiry_reg.feature_inq.reverse_x_avail,
+				  camera->feature_inquiry_reg.feature_inq.reverse_y_avail,
+				  camera->feature_inquiry_reg.feature_inq.intensity_auto_precedence_avail,
+				  camera->feature_inquiry_reg.feature_inq.black_level_avail,
+				  camera->feature_inquiry_reg.feature_inq.gain_avail,
+				  camera->feature_inquiry_reg.feature_inq.gamma_avail,
+				  camera->feature_inquiry_reg.feature_inq.contrast_avail,
+				  camera->feature_inquiry_reg.feature_inq.saturation_avail,
+				  camera->feature_inquiry_reg.feature_inq.hue_avail,
+				  camera->feature_inquiry_reg.feature_inq.white_balance_avail,
+				  camera->feature_inquiry_reg.feature_inq.sharpness_avail,
+				  camera->feature_inquiry_reg.feature_inq.exposure_auto_avail,
+				  camera->feature_inquiry_reg.feature_inq.gain_auto_avail,
+				  camera->feature_inquiry_reg.feature_inq.white_balance_auto_avail,
+				  camera->feature_inquiry_reg.feature_inq.device_temperature_avail,
+				  camera->feature_inquiry_reg.feature_inq.acquisition_abort,
+				  camera->feature_inquiry_reg.feature_inq.acquisition_frame_rate,
+				  camera->feature_inquiry_reg.feature_inq.frame_trigger,
+				  camera->feature_inquiry_reg.feature_inq.exposure_active_line_available);
+	return ret;
+}
+
+static ssize_t bcrm_bayer_formats_show(struct device *dev,
+									   struct device_attribute *attr, char *buf)
+{
+	struct avt_dev *camera = client_to_avt_dev(to_i2c_client(dev));
+	ssize_t ret;
+
+	ret = sprintf(buf, "0x%04X\n", camera->bayer_inquiry_reg.value);
+
+	return ret;
+}
+
+static ssize_t bcrm_bayer_formats_text_show(struct device *dev,
+											struct device_attribute *attr, char *buf)
+{
+	struct avt_dev *camera = client_to_avt_dev(to_i2c_client(dev));
+	ssize_t ret;
+
+	ret = sprintf(buf, "monochrome_avail %d\n"
+					   "bayer_GR_avail   %d\n"
+					   "bayer_RG_avail   %d\n"
+					   "bayer_GB_avail   %d\n"
+					   "bayer_BG_avail   %d\n",
+				  camera->bayer_inquiry_reg.bayer_pattern.monochrome_avail,
+				  camera->bayer_inquiry_reg.bayer_pattern.bayer_GR_avail,
+				  camera->bayer_inquiry_reg.bayer_pattern.bayer_RG_avail,
+				  camera->bayer_inquiry_reg.bayer_pattern.bayer_GB_avail,
+				  camera->bayer_inquiry_reg.bayer_pattern.bayer_BG_avail);
+
+	return ret;
+}
+
+static ssize_t bcrm_mipi_formats_show(struct device *dev,
+									  struct device_attribute *attr, char *buf)
+{
+	struct avt_dev *camera = client_to_avt_dev(to_i2c_client(dev));
+	ssize_t ret;
+
+	mutex_lock(&camera->lock);
+	ret = sprintf(buf, "0x%016llX\n", camera->avail_mipi_reg.value);
+	mutex_unlock(&camera->lock);
+
+	return ret;
+}
+
+static ssize_t bcrm_mipi_formats_text_show(struct device *dev,
+										   struct device_attribute *attr, char *buf)
+{
+	struct avt_dev *camera = client_to_avt_dev(to_i2c_client(dev));
+
+	return sprintf(buf, "yuv420_8_leg_avail   %d\n"
+						"yuv420_8_avail       %d\n"
+						"yuv420_10_avail      %d\n"
+						"yuv420_8_csps_avail  %d\n"
+						"yuv420_10_csps_avail %d\n"
+						"yuv422_8_avail       %d\n"
+						"yuv422_10_avail      %d\n"
+						"rgb888_avail         %d\n"
+						"rgb666_avail         %d\n"
+						"rgb565_avail         %d\n"
+						"rgb555_avail         %d\n"
+						"rgb444_avail         %d\n"
+						"raw6_avail           %d\n"
+						"raw7_avail           %d\n"
+						"raw8_avail           %d\n"
+						"raw10_avail          %d\n"
+						"raw12_avail          %d\n"
+						"raw14_avail          %d\n"
+						"jpeg_avail           %d\n",
+				   camera->avail_mipi_reg.avail_mipi.yuv420_8_leg_avail,
+				   camera->avail_mipi_reg.avail_mipi.yuv420_8_avail,
+				   camera->avail_mipi_reg.avail_mipi.yuv420_10_avail,
+				   camera->avail_mipi_reg.avail_mipi.yuv420_8_csps_avail,
+				   camera->avail_mipi_reg.avail_mipi.yuv420_10_csps_avail,
+				   camera->avail_mipi_reg.avail_mipi.yuv422_8_avail,
+				   camera->avail_mipi_reg.avail_mipi.yuv422_10_avail,
+				   camera->avail_mipi_reg.avail_mipi.rgb888_avail,
+				   camera->avail_mipi_reg.avail_mipi.rgb666_avail,
+				   camera->avail_mipi_reg.avail_mipi.rgb565_avail,
+				   camera->avail_mipi_reg.avail_mipi.rgb555_avail,
+				   camera->avail_mipi_reg.avail_mipi.rgb444_avail,
+				   camera->avail_mipi_reg.avail_mipi.raw6_avail,
+				   camera->avail_mipi_reg.avail_mipi.raw7_avail,
+				   camera->avail_mipi_reg.avail_mipi.raw8_avail,
+				   camera->avail_mipi_reg.avail_mipi.raw10_avail,
+				   camera->avail_mipi_reg.avail_mipi.raw12_avail,
+				   camera->avail_mipi_reg.avail_mipi.raw14_avail,
+				   camera->avail_mipi_reg.avail_mipi.jpeg_avail);
+}
+
+static ssize_t device_capabilities_show(struct device *dev,
+										struct device_attribute *attr, char *buf)
+{
+	struct avt_dev *camera = client_to_avt_dev(to_i2c_client(dev));
+
+	return sprintf(buf, "0x%016llX\n", camera->cci_reg.reg.device_capabilities.value);
+}
+
+static ssize_t device_capabilities_text_show(struct device *dev,
+											 struct device_attribute *attr, char *buf)
+{
+	struct avt_dev *camera = client_to_avt_dev(to_i2c_client(dev));
+	ssize_t ret;
+
+	mutex_lock(&camera->lock);
+
+	ret = sprintf(buf, "user_name        %d\n"
+					   "bcrm             %d\n"
+					   "gencp            %d\n"
+					   "string_encoding  %s\n"
+					   "family_name      %d\n",
+				  camera->cci_reg.reg.device_capabilities.caps.user_name,
+				  camera->cci_reg.reg.device_capabilities.caps.bcrm,
+				  camera->cci_reg.reg.device_capabilities.caps.gencp,
+				  camera->cci_reg.reg.device_capabilities.caps.string_encoding == CCI_CAPS_SE_ASCII ? "ASCII" : camera->cci_reg.reg.device_capabilities.caps.string_encoding == CCI_CAPS_SE_UTF8 ? "UTF8"
+																											: camera->cci_reg.reg.device_capabilities.caps.string_encoding == CCI_CAPS_SE_UTF16	 ? "UTF16"
+																																																 : "unknown string encoding",
+				  camera->cci_reg.reg.device_capabilities.caps.family_name);
+
+	mutex_unlock(&camera->lock);
+
+	return ret;
+}
+
+static ssize_t device_guid_show(struct device *dev,
+								struct device_attribute *attr, char *buf)
+{
+	struct avt_dev *camera = client_to_avt_dev(to_i2c_client(dev));
+	ssize_t ret;
+
+	ret = sprintf(buf, "%s\n", camera->cci_reg.reg.device_guid);
+
+	return ret;
+}
+
+static ssize_t manufacturer_name_show(struct device *dev,
+									  struct device_attribute *attr, char *buf)
+{
+	struct avt_dev *camera = client_to_avt_dev(to_i2c_client(dev));
+	ssize_t ret;
+
+	ret = sprintf(buf, "%s\n", camera->cci_reg.reg.manufacturer_name);
+
+	return ret;
+}
+
+static ssize_t model_name_show(struct device *dev,
+							   struct device_attribute *attr, char *buf)
+{
+	struct avt_dev *camera = client_to_avt_dev(to_i2c_client(dev));
+	ssize_t ret;
+
+	ret = sprintf(buf, "%s\n", camera->cci_reg.reg.model_name);
+
+	return ret;
+}
+
+static ssize_t family_name_show(struct device *dev,
+								struct device_attribute *attr, char *buf)
+{
+	struct avt_dev *camera = client_to_avt_dev(to_i2c_client(dev));
+	ssize_t ret;
+
+	ret = sprintf(buf, "%s\n", camera->cci_reg.reg.family_name);
+
+	return ret;
+}
+
+static ssize_t lane_count_show(struct device *dev,
+							   struct device_attribute *attr, char *buf)
+{
+	struct avt_dev *camera = client_to_avt_dev(to_i2c_client(dev));
+	ssize_t ret;
+
+	ret = sprintf(buf, "%d\n", camera->v4l2_fwnode_ep.bus.mipi_csi2.num_data_lanes);
+
+	return ret;
+}
+
+static ssize_t lane_capabilities_show(struct device *dev,
+									  struct device_attribute *attr, char *buf)
+{
+	struct avt_dev *camera = client_to_avt_dev(to_i2c_client(dev));
+
+	return sprintf(buf, "0x%02X\n", camera->lane_capabilities.value);
+}
+
+static ssize_t device_version_show(struct device *dev,
+								   struct device_attribute *attr, char *buf)
+{
+	struct avt_dev *camera = client_to_avt_dev(to_i2c_client(dev));
+
+	return sprintf(buf, "%s\n", camera->cci_reg.reg.device_version);
+}
+
+static ssize_t firmware_version_show(struct device *dev,
+									 struct device_attribute *attr, char *buf)
+{
+	struct avt_dev *camera = client_to_avt_dev(to_i2c_client(dev));
+	ssize_t ret;
+
+	ret = sprintf(buf, "%u.%u.%u.%u\n",
+				  camera->cam_firmware_version.device_firmware.special_version,
+				  camera->cam_firmware_version.device_firmware.major_version,
+				  camera->cam_firmware_version.device_firmware.minor_version,
+				  camera->cam_firmware_version.device_firmware.patch_version);
+
+	return ret;
+}
+
+static ssize_t manufacturer_info_show(struct device *dev,
+									  struct device_attribute *attr, char *buf)
+{
+	struct avt_dev *camera = client_to_avt_dev(to_i2c_client(dev));
+
+	return sprintf(buf, "%s\n", camera->cci_reg.reg.manufacturer_info);
+}
+
+static ssize_t serial_number_show(struct device *dev,
+								  struct device_attribute *attr, char *buf)
+{
+	struct avt_dev *camera = client_to_avt_dev(to_i2c_client(dev));
+
+	return sprintf(buf, "%s\n", camera->cci_reg.reg.serial_number);
+}
+
+static ssize_t user_defined_name_show(struct device *dev,
+									  struct device_attribute *attr, char *buf)
+{
+	struct avt_dev *camera = client_to_avt_dev(to_i2c_client(dev));
+
+	return sprintf(buf, "%s\n", camera->cci_reg.reg.user_defined_name);
+}
+
+static ssize_t driver_version_show(struct device *dev,
+								   struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%s\n", DRIVER_VERSION);
+}
+
+static ssize_t debug_en_show(struct device *dev,
+							 struct device_attribute *attr, char *buf)
+{
+
+	return sprintf(buf, "%d\n", debug);
+}
+
+static ssize_t debug_en_store(struct device *dev,
+							  struct device_attribute *attr, const char *buf, size_t count)
+{
+	ssize_t ret;
+
+	struct avt_dev *camera = client_to_avt_dev(to_i2c_client(dev));
+	mutex_lock(&camera->lock);
+
+	ret = kstrtoint(buf, 10, &debug);
+	if (ret < 0)
+	{
+
+		mutex_unlock(&camera->lock);
+		return ret;
+	}
+
+	mutex_unlock(&camera->lock);
+
+	return count;
+}
+
+static ssize_t mipiclk_show(struct device *dev,
+							struct device_attribute *attr, char *buf)
+{
+	ssize_t ret;
+
+	struct avt_dev *camera = client_to_avt_dev(to_i2c_client(dev));
+
+	ret = sysfs_emit(buf, "%llu\n", camera->v4l2_fwnode_ep.link_frequencies[0]);
+
+	return ret;
+}
+
+static ssize_t mipiclk_store(struct device *dev,
+							 struct device_attribute *attr, const char *buf, size_t count)
+{
+	ssize_t ret;
+	uint32_t avt_next_clk = 0;
+	uint32_t avt_current_clk = 0;
+
+	struct avt_dev *camera = client_to_avt_dev(to_i2c_client(dev));
+	struct i2c_client *client = to_i2c_client(dev);
+	mutex_lock(&camera->lock);
+
+	ret = kstrtouint(buf, 10, &avt_next_clk);
+	if (ret < 0)
+	{
+		goto out;
+	}
+
+	dev_info(&client->dev, "%s+[%d] request %s %u  0x%08X",
+			 __func__, __LINE__,
+			 buf, avt_next_clk, avt_next_clk);
+
+	if ((avt_next_clk < camera->avt_min_clk) ||
+		(avt_next_clk > camera->avt_max_clk))
+	{
+		dev_err(&client->dev, "%s[%d]: unsupported csi clock frequency (%u Hz, range: %u:%u Hz)!\n",
+				__func__, __LINE__,
+				avt_next_clk, camera->avt_min_clk,
+				camera->avt_max_clk);
+		ret = -EINVAL;
+	}
+	else
+	{
+		ret = bcrm_write32(camera, BCRM_CSI2_CLOCK_32RW, avt_next_clk);
+
+		dev_info(&client->dev, "%s[%d]: requested csi clock frequency %u Hz, retval %ld)\n",
+				 __func__, __LINE__, avt_next_clk, ret);
+
+		ret = bcrm_read32(camera, BCRM_CSI2_CLOCK_32RW, &avt_current_clk);
+		dev_info(&client->dev, "%s[%d]: requested csi clock frequency %u Hz, got %u Hz)\n",
+				 __func__, __LINE__, avt_next_clk, avt_current_clk);
+
+		if (0 < avt_current_clk)
+			camera->v4l2_fwnode_ep.link_frequencies[0] = avt_current_clk;
+	}
+
+out:
+	mutex_unlock(&camera->lock);
+
+	return count;
+}
+
+static ssize_t device_temperature_show(struct device *dev,
+									   struct device_attribute *attr, char *buf)
+{
+	ssize_t ret;
+	int device_temperature;
+
+	struct avt_dev *camera = client_to_avt_dev(to_i2c_client(dev));
+	mutex_lock(&camera->lock);
+
+	ret = bcrm_read32(camera, BCRM_DEVICE_TEMPERATURE_32R, &device_temperature);
+
+	ret = sprintf(buf, "%d.%d\n", device_temperature / 10, device_temperature % 10);
+
+	mutex_unlock(&camera->lock);
+	return ret;
+}
+
+static ssize_t softreset_show(struct device *dev,
+							  struct device_attribute *attr, char *buf)
+{
+	struct avt_dev *camera = client_to_avt_dev(to_i2c_client(dev));
+	ssize_t ret;
+
+	ret = sprintf(buf, "%d\n", camera->pending_softreset_request);
+
+	return ret;
+}
+
+static ssize_t softreset_store(struct device *dev,
+							   struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct avt_dev *camera = client_to_avt_dev(to_i2c_client(dev));
+	ssize_t ret;
+	int value;
+
+	ret = kstrtoint(buf, 10, &value);
+	if (ret < 0)
+	{
+		return ret;
+	}
+
+	if (value > 0) {
+		avt_reset(camera, RESET_TYPE_SOFT);
+
+		/* Re-read and configure MIPI configuration */
+		avt_get_sensor_capabilities(get_sd(camera));
+	}
+
+	return count;
+}
+
+static ssize_t dphyreset_show(struct device *dev,
+							  struct device_attribute *attr, char *buf)
+{
+	struct avt_dev *camera = client_to_avt_dev(to_i2c_client(dev));
+	ssize_t ret;
+
+	mutex_lock(&camera->lock);
+
+	ret = sprintf(buf, "%d\n", camera->pending_dphyreset_request);
+
+	mutex_unlock(&camera->lock);
+
+	return ret;
+}
+
+static ssize_t dphyreset_store(struct device *dev,
+							   struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct avt_dev *camera = client_to_avt_dev(to_i2c_client(dev));
+	ssize_t ret;
+
+	mutex_lock(&camera->lock);
+	ret = kstrtoint(buf, 10, &camera->pending_dphyreset_request);
+	if (ret < 0)
+	{
+		mutex_unlock(&camera->lock);
+		return ret;
+	}
+
+	if (camera->pending_dphyreset_request > 0)
+	{
+		avt_dphy_reset(camera, true);
+		avt_dphy_reset(camera, false);
+	}
+	mutex_unlock(&camera->lock);
+	return count;
+}
+
+static ssize_t streamon_delay_show(struct device *dev,
+								   struct device_attribute *attr, char *buf)
+{
+	struct avt_dev *camera = client_to_avt_dev(to_i2c_client(dev));
+	ssize_t ret;
+
+	mutex_lock(&camera->lock);
+
+	ret = bcrm_read32(camera, BCRM_STREAM_ON_DELAY_32RW, &camera->streamon_delay);
+
+	ret = sprintf(buf, "%u\n", camera->streamon_delay);
+
+	mutex_unlock(&camera->lock);
+
+	return ret;
+}
+
+static ssize_t streamon_delay_store(struct device *dev,
+									struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct avt_dev *camera = client_to_avt_dev(to_i2c_client(dev));
+	ssize_t ret;
+
+	mutex_lock(&camera->lock);
+	ret = kstrtoint(buf, 10, &camera->streamon_delay);
+	if (ret < 0)
+	{
+		mutex_unlock(&camera->lock);
+		return ret;
+	}
+
+	ret = bcrm_write64(camera, BCRM_STREAM_ON_DELAY_32RW, camera->streamon_delay);
+
+
+	mutex_unlock(&camera->lock);
+	return count;
+}
+
+
+static ssize_t hardreset_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct avt_dev *camera = client_to_avt_dev(to_i2c_client(dev));
+	ssize_t ret;
+
+	mutex_lock(&camera->lock);
+
+	ret = sprintf(buf, "%d\n", camera->pending_softreset_request);
+
+	mutex_unlock(&camera->lock);
+
+	return ret;
+}
+
+static ssize_t hardreset_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct avt_dev *camera = client_to_avt_dev(to_i2c_client(dev));
+	ssize_t ret;
+	int value;
+
+	ret = kstrtoint(buf, 10, &value);
+	if (ret < 0)
+	{
+		return ret;
+	}
+
+	if (value > 0) {
+		avt_reset(camera, RESET_TYPE_HARD);
+
+		/* Re-read and configure MIPI configuration */
+		avt_get_sensor_capabilities(get_sd(camera));
+	}
+
+	return count;
+}
+
+static ssize_t bcrm_dump_show(struct device *dev,
+							  struct device_attribute *attr, char *buf)
+{
+	bcrm_dump(to_i2c_client(dev));
+
+	return 0;
+}
+
+
+static DEVICE_ATTR_RO(availability);
+static DEVICE_ATTR_RO(bcrm_dump);
+static DEVICE_ATTR_RO(cci_register_layout_version);
+static DEVICE_ATTR_RO(device_capabilities);
+static DEVICE_ATTR_RO(firmware_version);
+static DEVICE_ATTR_RO(device_capabilities_text);
+static DEVICE_ATTR_RO(bcrm_feature_inquiry_reg);
+static DEVICE_ATTR_RO(bcrm_feature_inquiry_reg_text);
+static DEVICE_ATTR_RO(device_guid);
+static DEVICE_ATTR_RO(device_version);
+static DEVICE_ATTR_RO(driver_version);
+static DEVICE_ATTR_RO(family_name);
+static DEVICE_ATTR_RO(lane_count);
+static DEVICE_ATTR_RO(lane_capabilities);
+static DEVICE_ATTR_RO(manufacturer_info);
+static DEVICE_ATTR_RO(manufacturer_name);
+static DEVICE_ATTR_RO(model_name);
+static DEVICE_ATTR_RO(serial_number);
+static DEVICE_ATTR_RO(user_defined_name);
+static DEVICE_ATTR_RO(bcrm_mipi_formats);
+static DEVICE_ATTR_RO(bcrm_mipi_formats_text);
+static DEVICE_ATTR_RO(bcrm_bayer_formats);
+static DEVICE_ATTR_RO(bcrm_bayer_formats_text);
+static DEVICE_ATTR_RW(debug_en);
+static DEVICE_ATTR_RW(softreset);
+static DEVICE_ATTR_RW(dphyreset);
+static DEVICE_ATTR_RW(streamon_delay);
+static DEVICE_ATTR_RW(hardreset);
+static DEVICE_ATTR_RO(device_temperature);
+static DEVICE_ATTR_RW(mipiclk);
+
+static struct attribute *avt_attrs[] = {
+	&dev_attr_availability.attr,
+	&dev_attr_bcrm_dump.attr,
+	&dev_attr_cci_register_layout_version.attr,
+	&dev_attr_device_capabilities.attr,
+	&dev_attr_device_capabilities_text.attr,
+	&dev_attr_firmware_version.attr,
+	&dev_attr_device_guid.attr,
+	&dev_attr_device_version.attr,
+	&dev_attr_driver_version.attr,
+	&dev_attr_bcrm_feature_inquiry_reg.attr,
+	&dev_attr_bcrm_feature_inquiry_reg_text.attr,
+	&dev_attr_family_name.attr,
+	&dev_attr_lane_count.attr,
+	&dev_attr_lane_capabilities.attr,
+	&dev_attr_manufacturer_info.attr,
+	&dev_attr_manufacturer_name.attr,
+	&dev_attr_model_name.attr,
+	&dev_attr_serial_number.attr,
+	&dev_attr_user_defined_name.attr,
+	&dev_attr_bcrm_mipi_formats.attr,
+	&dev_attr_bcrm_mipi_formats_text.attr,
+	&dev_attr_bcrm_bayer_formats.attr,
+	&dev_attr_bcrm_bayer_formats_text.attr,
+	&dev_attr_debug_en.attr,
+	&dev_attr_dphyreset.attr,
+	&dev_attr_streamon_delay.attr,
+	&dev_attr_softreset.attr,
+	&dev_attr_hardreset.attr,
+	&dev_attr_device_temperature.attr,
+	&dev_attr_mipiclk.attr,
+	NULL};
+
+static struct attribute_group avt_attr_grp = {
+	.attrs = avt_attrs,
+};
+
+static int avt_get_fmt_available(struct i2c_client *client)
+{
+	struct avt_dev *camera = client_to_avt_dev(client);
+	u8 bayer_val = 0;
+	int ret;
+	u64 avail_mipi = 0;
+
+	mutex_lock(&camera->lock);
+
+	ret = bcrm_read64(camera, BCRM_IMG_AVAILABLE_MIPI_DATA_FORMATS_64R, &avail_mipi);
+
+	if (ret < 0)
+	{
+		dev_err(&client->dev, "%s[%d]regmap_bulk_read (%d)\n",
+				__func__, __LINE__, ret);
+		goto out;
+	}
+
+	camera->avail_mipi_reg.value = avail_mipi;
+
+	/* read the Bayer Inquiry register to check whether the camera
+	 * really support the requested RAW format
+	 */
+	ret = bcrm_read8(camera, BCRM_IMG_BAYER_PATTERN_INQUIRY_8R, &bayer_val);
+
+	if (ret < 0)
+	{
+		dev_err(&client->dev, "%s[%d]: regmap_read (%d)\n",
+				__func__, __LINE__, ret);
+		goto out;
+	}
+
+	camera->bayer_inquiry_reg.value = bayer_val;
+
+out:
+	avt_dbg(get_sd(camera), "avail_mipi 0x%016llX bayer_val 0x%02X ret %d",
+			camera->avail_mipi_reg.value,
+			camera->bayer_inquiry_reg.value, ret);
+
+	mutex_unlock(&camera->lock);
+	return ret;
+}
+
+static int lookup_media_bus_format_index(struct avt_dev *camera, u32 mbus_code)
+{
+
+	int i;
+
+	for (i = 0; i < camera->available_fmts_cnt; i++)
+	{
+		adev_info(&camera->i2c_client->dev, "mbus_code 0x%04x against test MEDIA_BUS_FMT 0x%04x / V4L2_PIX_FMT_ %c%c%c%c / MIPI_CSI2_DT 0x%02x",
+				  mbus_code,
+				  camera->available_fmts[i].mbus_code,
+				  camera->available_fmts[i].fourcc & 0x0ff, (camera->available_fmts[i].fourcc >> 8) & 0x0ff,
+				  (camera->available_fmts[i].fourcc >> 16) & 0x0ff, (camera->available_fmts[i].fourcc >> 24) & 0x0ff,
+				  camera->available_fmts[i].mipi_fmt);
+		if (mbus_code == camera->available_fmts[i].mbus_code)
+			return i;
+	}
+
+	return -EINVAL;
+}
+
+static void set_mode_mapping(struct avt_csi_mipi_mode_mapping *pfmt,
+					  u32 mbus_code, u16 mipi_fmt, u32 colorspace,
+					  u32 fourcc,
+					  enum bayer_format bayer_pattern, const char *name)
+{
+	pfmt->mbus_code = mbus_code;
+	pfmt->mipi_fmt = mipi_fmt;
+	pfmt->fourcc = fourcc;
+	pfmt->colorspace = colorspace;
+	pfmt->bayer_pattern = bayer_pattern;
+	strcpy(pfmt->name, name);
+}
+
+/* ToDo: read available formats from Cam */
+static int avt_init_avail_formats(struct v4l2_subdev *sd)
+{
+	struct avt_dev *camera = to_avt_dev(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct avt_csi_mipi_mode_mapping *pfmt;
+
+	if (sd == NULL)
+	{
+		return -EINVAL;
+	}
+
+	avt_dbg(sd, "camera->available_fmts_cnt %d", camera->available_fmts_cnt);
+
+	camera->available_fmts_cnt = 0;
+
+	avt_dbg(sd, "%s %s %s %s\n",
+			camera->cci_reg.reg.manufacturer_name,
+			camera->cci_reg.reg.family_name,
+			camera->cci_reg.reg.model_name,
+			camera->cci_reg.reg.device_guid);
+
+	avt_dbg(sd, "monochrome_avail %d\n"
+				"bayer_GR_avail   %d\n"
+				"bayer_RG_avail   %d\n"
+				"bayer_GB_avail   %d\n"
+				"bayer_BG_avail   %d\n",
+			camera->bayer_inquiry_reg.bayer_pattern.monochrome_avail,
+			camera->bayer_inquiry_reg.bayer_pattern.bayer_GR_avail,
+			camera->bayer_inquiry_reg.bayer_pattern.bayer_RG_avail,
+			camera->bayer_inquiry_reg.bayer_pattern.bayer_GB_avail,
+			camera->bayer_inquiry_reg.bayer_pattern.bayer_BG_avail);
+
+	avt_dbg(sd, "\n"
+				"yuv420_8_leg_avail   %d\n"
+				"yuv420_8_avail       %d\n"
+				"yuv420_10_avail      %d\n"
+				"yuv420_8_csps_avail  %d\n"
+				"yuv420_10_csps_avail %d\n"
+				"yuv422_8_avail       %d\n"
+				"yuv422_10_avail      %d\n"
+				"rgb888_avail         %d\n"
+				"rgb666_avail         %d\n"
+				"rgb565_avail         %d\n"
+				"rgb555_avail         %d\n"
+				"rgb444_avail         %d\n"
+				"raw6_avail           %d\n"
+				"raw7_avail           %d\n"
+				"raw8_avail           %d\n"
+				"raw10_avail          %d\n"
+				"raw12_avail          %d\n"
+				"raw14_avail          %d\n"
+				"jpeg_avail           %d\n",
+			camera->avail_mipi_reg.avail_mipi.yuv420_8_leg_avail,
+			camera->avail_mipi_reg.avail_mipi.yuv420_8_avail,
+			camera->avail_mipi_reg.avail_mipi.yuv420_10_avail,
+			camera->avail_mipi_reg.avail_mipi.yuv420_8_csps_avail,
+			camera->avail_mipi_reg.avail_mipi.yuv420_10_csps_avail,
+			camera->avail_mipi_reg.avail_mipi.yuv422_8_avail,
+			camera->avail_mipi_reg.avail_mipi.yuv422_10_avail,
+			camera->avail_mipi_reg.avail_mipi.rgb888_avail,
+			camera->avail_mipi_reg.avail_mipi.rgb666_avail,
+			camera->avail_mipi_reg.avail_mipi.rgb565_avail,
+			camera->avail_mipi_reg.avail_mipi.rgb555_avail,
+			camera->avail_mipi_reg.avail_mipi.rgb444_avail,
+			camera->avail_mipi_reg.avail_mipi.raw6_avail,
+			camera->avail_mipi_reg.avail_mipi.raw7_avail,
+			camera->avail_mipi_reg.avail_mipi.raw8_avail,
+			camera->avail_mipi_reg.avail_mipi.raw10_avail,
+			camera->avail_mipi_reg.avail_mipi.raw12_avail,
+			camera->avail_mipi_reg.avail_mipi.raw14_avail,
+			camera->avail_mipi_reg.avail_mipi.jpeg_avail);
+
+	camera->available_fmts = kmalloc(sizeof(camera->available_fmts[0]) * AVT_MAX_FORMAT_ENTRIES, GFP_KERNEL);
+
+	if (!camera->available_fmts)
+	{
+		dev_err(&client->dev,
+				"%s[%d]: not enough memory to store list of available formats",
+				__func__, __LINE__);
+		return -ENOMEM;
+	}
+
+	pfmt = camera->available_fmts;
+
+  #define add_format_unconditional(mbus_code, mipi_fmt, colorspace, fourcc, bayer_pattern) \
+    set_mode_mapping(pfmt, mbus_code, mipi_fmt, colorspace, fourcc, bayer_pattern, #mbus_code); \
+    camera->available_fmts_cnt++; \
+    pfmt++;
+
+  #define add_format_gen(avail_field_name, mbus_code, mipi_fmt, colorspace, fourcc, bayer_pattern) \
+    if(camera->avail_mipi_reg.avail_mipi.avail_field_name) { \
+      adev_info(&client->dev, "add MEDIA_BUS_FMT_" #mbus_code "/V4L2_PIX_FMT_" #fourcc "/MIPI_CSI2_DT_" #mipi_fmt " to list of available formats %d - %d", bayer_pattern, \
+                camera->avail_mipi_reg.avail_mipi.avail_field_name); \
+      add_format_unconditional(MEDIA_BUS_FMT_ ## mbus_code, MIPI_CSI2_DT_ ## mipi_fmt, colorspace, V4L2_PIX_FMT_ ## fourcc, bayer_pattern); \
+    }
+
+  #define add_format_srgb(avail_field_name, mbus_code, mipi_fmt, fourcc) \
+    add_format_gen(avail_field_name, mbus_code, mipi_fmt, V4L2_COLORSPACE_SRGB, fourcc, bayer_ignore)
+
+  #define add_format_raw(pattern_avail_field, avail_field_name, mbus_code, mipi_fmt, fourcc, bayer_format) \
+		if(camera->bayer_inquiry_reg.bayer_pattern.pattern_avail_field) {\
+      add_format_gen(avail_field_name, mbus_code, mipi_fmt, V4L2_COLORSPACE_RAW, fourcc, bayer_format); \
+    }
+
+  // YUV formats
+  add_format_srgb(yuv422_8_avail,  UYVY8_2X8,   YUV422_8B, UYVY);
+  add_format_srgb(yuv422_8_avail,  UYVY8_1X16,  YUV422_8B, UYVY);
+  add_format_srgb(yuv422_8_avail,  YUYV8_1X16,  YUV422_8B, YUV422P);
+  add_format_srgb(yuv422_8_avail,  YUYV8_2X8,   YUV422_8B, YUYV);
+  add_format_srgb(yuv422_8_avail,  VYUY8_2X8,   YUV422_8B, VYUY);
+
+  add_format_srgb(yuv422_10_avail, YUYV10_1X20, YUV422_8B, YUV410);
+
+  // RGB formats
+  add_format_srgb(rgb888_avail,    RGB888_1X24, RGB888,    RGB24);
+  add_format_srgb(rgb888_avail,    RBG888_1X24, RGB888,    RGB24);
+  add_format_srgb(rgb888_avail,    BGR888_1X24, RGB888,    RGB24);
+  add_format_srgb(rgb888_avail,    RGB888_3X8,  RGB888,    RGB24);
+
+  // 8 bit raw formats (mono / bayer)
+  add_format_raw(monochrome_avail, raw8_avail,  Y8_1X8,       RAW8,  GREY,    monochrome);
+  add_format_raw(bayer_GR_avail,   raw8_avail,  SGRBG8_1X8,   RAW8,  SGRBG8,  bayer_gr);
+  add_format_raw(bayer_RG_avail,   raw8_avail,  SRGGB8_1X8,   RAW8,  SRGGB8,  bayer_rg);
+  add_format_raw(bayer_BG_avail,   raw8_avail,  SBGGR8_1X8,   RAW8,  SBGGR8,  bayer_bg);
+  add_format_raw(bayer_GB_avail,   raw8_avail,  SGBRG8_1X8,   RAW8,  SGBRG8,  bayer_gb);
+
+  // 10 bit raw formats (mono / bayer)
+  add_format_raw(monochrome_avail, raw10_avail, Y10_1X10,     RAW10, Y10,     monochrome);
+  add_format_raw(bayer_GR_avail,   raw10_avail, SGRBG10_1X10, RAW10, SGRBG10, bayer_gr);
+  add_format_raw(bayer_RG_avail,   raw10_avail, SRGGB10_1X10, RAW10, SRGGB10, bayer_rg);
+  add_format_raw(bayer_BG_avail,   raw10_avail, SBGGR10_1X10, RAW10, SGRBG10, bayer_bg);
+  add_format_raw(bayer_GB_avail,   raw10_avail, SGBRG10_1X10, RAW10, SGBRG10, bayer_gb);
+
+  // 12 bit raw formats (mono / bayer)
+  add_format_raw(monochrome_avail, raw12_avail, Y12_1X12,     RAW12, Y12,     monochrome);
+  add_format_raw(bayer_GR_avail,   raw12_avail, SGRBG12_1X12, RAW12, SGRBG12, bayer_gr);
+  add_format_raw(bayer_RG_avail,   raw12_avail, SRGGB12_1X12, RAW12, SRGGB12, bayer_rg);
+  add_format_raw(bayer_BG_avail,   raw12_avail, SBGGR12_1X12, RAW12, SGRBG12, bayer_bg);
+  add_format_raw(bayer_GB_avail,   raw12_avail, SGBRG12_1X12, RAW12, SGBRG12, bayer_gb);
+
+  // 14 bit raw formats (mono / bayer)
+  add_format_raw(monochrome_avail, raw14_avail, Y14_1X14,     RAW14, Y14,     monochrome);
+  add_format_raw(bayer_GR_avail,   raw14_avail, SGRBG14_1X14, RAW14, SGRBG14, bayer_gr);
+  add_format_raw(bayer_RG_avail,   raw14_avail, SRGGB14_1X14, RAW14, SRGGB14, bayer_rg);
+  add_format_raw(bayer_BG_avail,   raw14_avail, SBGGR14_1X14, RAW14, SGRBG14, bayer_bg);
+  add_format_raw(bayer_GB_avail,   raw14_avail, SGBRG14_1X14, RAW14, SGBRG14, bayer_gb);
+
+  // GenICam
+	add_format_unconditional(MEDIA_BUS_FMT_CUSTOM, 0x31, V4L2_COLORSPACE_DEFAULT, V4L2_PIX_FMT_CUSTOM, bayer_ignore);
+
+  #undef add_format_raw
+  #undef add_format
+  #undef add_format_gen
+  #undef add_format_unconditional
+
+	pfmt->mbus_code = -EINVAL;
+
+	avt_dbg(get_sd(camera), "available_fmts_cnt %d", camera->available_fmts_cnt);
+
+	return camera->available_fmts_cnt;
+}
+
+static int avt_init_current_format(struct avt_dev *camera, struct v4l2_mbus_framefmt *fmt)
+{
+	u32 current_mipi_format;
+	u8 current_bayer_pattern;
+	int ret, i;
+
+	ret = bcrm_read32(camera, BCRM_IMG_MIPI_DATA_FORMAT_32RW, &current_mipi_format);
+	if (unlikely(ret))
+	{
+		dev_err(&camera->i2c_client->dev, "Failed to read current mipi format!");
+		return ret;
+	}
+
+	ret = bcrm_read8(camera, BCRM_IMG_BAYER_PATTERN_8RW, &current_bayer_pattern);
+	if (unlikely(ret))
+	{
+		dev_err(&camera->i2c_client->dev, "Failed to read current bayer pattern!");
+		return ret;
+	}
+
+	for (i = 0;i < camera->available_fmts_cnt; i++)
+	{
+		const struct avt_csi_mipi_mode_mapping *mapping = &camera->available_fmts[i];
+		bool const bayer_correct =
+			mapping->bayer_pattern == current_bayer_pattern
+			|| mapping->bayer_pattern == bayer_ignore;
+
+		if (mapping->mipi_fmt == current_mipi_format && bayer_correct)
+		{
+			fmt->code = mapping->mbus_code;
+			fmt->colorspace = V4L2_COLORSPACE_SRGB;
+			fmt->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(fmt->colorspace);
+			fmt->quantization = V4L2_QUANTIZATION_FULL_RANGE;
+			fmt->xfer_func = V4L2_XFER_FUNC_DEFAULT;
+			fmt->width = camera->max_rect.width;
+			fmt->height = camera->max_rect.height;
+			fmt->field = V4L2_FIELD_NONE;
+
+			return 0;
+		}
+	}
+
+	return -EINVAL;
+}
+
+/* hard reset depends on gpio-pins, needs to be completed on
+   suitable board instead of imx8mp-evk */
+static int perform_hard_reset(struct avt_dev *camera)
+{
+	dev_info(&camera->i2c_client->dev, "%s[%d]",
+			 __func__, __LINE__);
+
+	if (!camera->reset_gpio)
+	{
+		dev_info(&camera->i2c_client->dev, "%s[%d]: - ignore reset request because missing reset gpio",
+				 __func__, __LINE__);
+		camera->pending_hardtreset_request = 0;
+
+		return -1;
+	}
+
+	dev_info(&camera->i2c_client->dev, "%s[%d]: - request hard reset by triggering reset gpio",
+			 __func__, __LINE__);
+	gpiod_set_value_cansleep(camera->reset_gpio, GPIOD_OUT_HIGH);
+
+	/* Todo: implement usefull camera power cycle timing,
+	 eventually based on additional dts parameters,
+	 can't be checked on imx8mp-evk because shared GPIO lines */
+	//	avt_power(camera, false);
+	usleep_range(5000, 10000);
+	//	avt_power(camera, true);
+	//	usleep_range(5000, 10000);
+
+	gpiod_set_value_cansleep(camera->reset_gpio, GPIOD_OUT_LOW);
+	//	usleep_range(1000, 2000);
+
+	//	gpiod_set_value_cansleep(camera->reset_gpio, 0);
+	usleep_range(20000, 25000);
+
+	return 0;
+}
+
+static const int heartbeat_default = 0x80;
+
+static int heartbeat_write_default(struct avt_dev *camera) {
+	int ret = avt_write(camera, cci_cmd_tbl[HEARTBEAT].address, heartbeat_default, AV_CAM_DATA_SIZE_8);
+	if(ret != 0) {
+		avt_err(get_sd(camera), "Heartbeat write failed (regmap_write returned %d)", ret);
+		return -1;
+	}
+	return 0;
+}
+
+static int heartbeat_read(struct avt_dev *camera, u8 *heartbeat) {
+	int ret = avt_read8(camera, cci_cmd_tbl[HEARTBEAT].address, heartbeat);
+	if(ret != 0) {
+		avt_err(get_sd(camera), "Heartbeat read failed (regmap_read returned %d)", ret);
+		return -1;
+	}
+	return 0;
+}
+
+static int heartbeat_supported(struct avt_dev *camera) {
+	u8 heartbeat;
+
+	int ret = heartbeat_write_default(camera);
+	if(ret != 0) {
+		avt_err(get_sd(camera), "Heartbeat support detection failed (heartbeat_write returned %d)", ret);
+		return ret;
+	}
+
+	ret = heartbeat_read(camera, &heartbeat);
+	if(ret != 0) {
+		avt_err(get_sd(camera), "Heartbeat support detection failed (heartbeat_read returned %d)", ret);
+		return -1;
+	}
+
+	return heartbeat != 0;
+}
+
+static int wait_camera_available(struct avt_dev *camera, bool use_heartbeat) {
+	static const unsigned long max_time_ms = 10000;
+	static const unsigned long delay_ms = 400;
+	u64 const start_jiffies = get_jiffies_64();
+	bool device_available = false;
+	u64 duration_ms = 0;
+
+
+	avt_info(get_sd(camera), "Waiting for camera to shutdown...");
+	do
+	{
+		usleep_range(delay_ms*1000, (delay_ms+1)*1000);
+		device_available = avt_detect(camera->i2c_client) == 0;
+		duration_ms = jiffies_to_msecs(get_jiffies_64() - start_jiffies);
+	} while((duration_ms < max_time_ms) && device_available);
+
+	avt_info(get_sd(camera), "Waiting for camera to respond to I2C transfers...");
+	do
+	{
+		usleep_range(delay_ms*1000, (delay_ms+1)*1000);
+		device_available = avt_detect(camera->i2c_client) == 0;
+		duration_ms = jiffies_to_msecs(get_jiffies_64() - start_jiffies);
+	} while((duration_ms < max_time_ms) && !device_available);
+
+	avt_dbg(get_sd(camera), "Camera is responding again");
+
+	if(!device_available) {
+		return -1;
+	}
+
+	if(!use_heartbeat) {
+		avt_info(get_sd(camera), "Heartbeat NOT supported, waiting %dms before continuing", add_wait_time_ms);
+		usleep_range(add_wait_time_ms*1000, (add_wait_time_ms+1)*1000);
+		avt_info(get_sd(camera), "Done waiting, let's hope for the best...");
+		return 0;
+	} else {
+		u8 heartbeat;
+		avt_info(get_sd(camera), "Heartbeat supported, waiting for heartbeat to become active");
+
+		do
+		{
+			usleep_range(delay_ms*1000, (delay_ms+1)*1000);
+			heartbeat_read(camera, &heartbeat);
+			duration_ms = jiffies_to_msecs(get_jiffies_64() - start_jiffies);
+		} while((duration_ms < max_time_ms) && ((heartbeat == 0) || (heartbeat == heartbeat_default)));
+
+		if(heartbeat >= 0 && heartbeat < heartbeat_default) {
+			avt_info(get_sd(camera), "Heartbeat active");
+			return 0;
+		}
+
+		avt_err(get_sd(camera), "Camera not reconnected (heartbeat timeout)");
+	}
+
+	return -1;
+}
+
+static int avt_reset(struct avt_dev *camera, enum avt_reset_type reset_type)
+{
+	struct i2c_client *client = camera->i2c_client;
+	int ret;
+	int heartbeat;
+
+	dev_info(&client->dev, "%s[%d]",
+			 __func__, __LINE__);
+
+	mutex_lock(&camera->lock);
+
+	heartbeat = heartbeat_supported(camera);
+	if(heartbeat < 0) {
+		avt_err(get_sd(camera), "Heartbeat detection failed");
+		ret = -1;
+		goto out;
+	}
+
+	if(reset_type == RESET_TYPE_HARD) {
+		camera->pending_hardtreset_request = 1;
+		ret = perform_hard_reset(camera);
+		if (ret < 0) {
+			dev_err(&client->dev, "perform_hard_reset request failed (%d)\n", ret);
+			goto out;
+		}
+	} else {
+		camera->pending_softreset_request = 1;
+		ret = avt_write(camera, cci_cmd_tbl[SOFT_RESET].address, 1, AV_CAM_DATA_SIZE_8);
+		if (ret < 0) {
+			dev_err(&client->dev, "avt_soft_reset request by calling regmap_write failed (%d)\n", ret);
+			goto out;
+		}
+	}
+
+	ret = wait_camera_available(camera, heartbeat == 1);
+
+	if(ret != 0) {
+		avt_err(get_sd(camera), "Camera failed to come back online");
+		goto out;
+	}
+
+	if(reset_type == RESET_TYPE_HARD) {
+		camera->pending_hardtreset_request = 0;
+	} else {
+		camera->pending_softreset_request = 0;
+	}
+
+out:
+	mutex_unlock(&camera->lock);
+	return ret;
+}
+
+static void avt_dphy_reset(struct avt_dev *camera, bool bResetPhy)
+{
+	struct i2c_client *client = camera->i2c_client;
+	int ret;
+	int ival = bResetPhy;
+
+	dev_info(&client->dev, "%s[%d]", __func__, __LINE__);
+
+	ret = bcrm_write8(camera, BCRM_PHY_RESET_8RW, ival);
+
+	if (ret < 0)
+	{
+		dev_err(&client->dev, "%s[%d]: avt_dphy_reset request by calling regmap_write CSI2_PHY_RESET_32RW failed (%d)\n",
+				__func__, __LINE__, ret);
+		goto out;
+	}
+
+out:
+	camera->pending_dphyreset_request = 0;
+}
+
+/* --------------- Subdev Operations --------------- */
+/* -- Code needs to be completed, e.g. power off the cam and setup on power on to support standby, hybernate, ... --  */
+static int avt_core_ops_s_power(struct v4l2_subdev *sd, int on)
+{
+	struct avt_dev *camera = to_avt_dev(sd);
+	int ret = 0;
+
+	mutex_lock(&camera->lock);
+
+	dev_info(&camera->i2c_client->dev, "%s[%d]+: on %d, camera->power_count %d",
+			 __func__, __LINE__, on, camera->power_count);
+
+	/* Update the power count. */
+	if (on)
+		camera->power_count++;
+	else
+		camera->power_count--;
+
+	WARN_ON(camera->power_count < 0);
+	WARN_ON(camera->power_count > 1);
+
+	mutex_unlock(&camera->lock);
+
+	return ret;
+}
+
+static int avt_get_fmt_bcm(struct avt_dev *camera,
+			   struct v4l2_subdev_state *sd_state,
+			   struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *fmt;
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY) 	{
+		dev_dbg(&camera->i2c_client->dev, "%s[%d]", __func__, __LINE__);
+		fmt = v4l2_subdev_get_try_format(get_sd(camera), sd_state, format->pad);
+	} else {
+		dev_dbg(&camera->i2c_client->dev, "%s[%d]: %u x %u 0x%04X", __func__, __LINE__,
+				 camera->mbus_framefmt.width, camera->mbus_framefmt.height,
+				 camera->mbus_framefmt.code);
+		fmt = &camera->mbus_framefmt;
+	}
+
+	format->format = *fmt;
+
+	return 0;
+}
+
+static int avt_get_fmt_gencp(struct avt_dev *camera,
+			   struct v4l2_subdev_state *sd_state,
+			   struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *fmt = &format->format;
+
+	fmt->width = camera->curr_rect.width;
+	fmt->height = camera->curr_rect.height;
+	fmt->code = MEDIA_BUS_FMT_CUSTOM;
+	fmt->field = V4L2_FIELD_NONE;
+	fmt->colorspace = V4L2_COLORSPACE_RAW;
+	fmt->quantization = V4L2_QUANTIZATION_DEFAULT;
+	fmt->xfer_func = V4L2_XFER_FUNC_NONE;
+
+
+	return 0;
+}
+
+static int avt_pad_ops_get_fmt(struct v4l2_subdev *sd,
+			       struct v4l2_subdev_state *sd_state,
+			       struct v4l2_subdev_format *format)
+{
+	struct avt_dev *camera = to_avt_dev(sd);
+	int ret;
+
+
+	dev_info(&camera->i2c_client->dev, "%s[%d]",
+			 __func__, __LINE__);
+
+	if (format->pad != 0) {
+		avt_err(sd, "format->pad != 0");
+		return -EINVAL;
+	}
+
+
+	mutex_lock(&camera->lock);
+
+	switch (camera->mode) {
+		case AVT_BCRM_MODE:
+			ret = avt_get_fmt_bcm(camera, sd_state, format);
+			break;
+		case AVT_GENCP_MODE:
+			ret = avt_get_fmt_gencp(camera, sd_state, format);
+			break;
+		default:
+			ret = -EINVAL;
+			break;
+	}
+
+	mutex_unlock(&camera->lock);
+
+
+	return ret;
+}
+
+static void avt_calc_compose(const struct avt_dev * const camera,
+			      const struct v4l2_rect * const crop,
+			      u32 *width,u32 *height,
+			      const struct avt_binning_info **info)
+{
+	const u32 type = camera->curr_binning_type;
+	const struct avt_binning_info * const infos = camera->binning_infos[type];
+	const size_t cnt = camera->binning_info_cnt[type];
+	const struct v4l2_rect * const min = &camera->min_rect;
+	const struct v4l2_rect * const max = &camera->sensor_rect;
+	const bool x_changed = *width != camera->mbus_framefmt.width;
+	const bool y_changed = *height != camera->mbus_framefmt.height;
+	const bool type_changed = type != camera->curr_binning_info->type;
+	const struct avt_binning_info *best;
+	struct v4l2_rect scaled_crop = *crop;
+	struct v4l2_rect binning_rect = {0};
+
+	best = camera->curr_binning_info;
+
+	if (x_changed || y_changed || type_changed) {
+		u32 min_error = U32_MAX;
+		int i;
+
+		for (i = 0; i < cnt; i++) {
+			const struct avt_binning_info * const cur = &infos[i];
+			const u32 s_width = camera->curr_rect.width / cur->vfact;
+			const u32 s_height = camera->curr_rect.height / cur->hfact;
+			u32 error = 0;
+
+			if (x_changed || type_changed)
+				error += abs(s_width - *width);
+
+			if (y_changed || type_changed)
+				error += abs(s_height - *height);
+
+			if (error > min_error)
+				continue;
+
+			min_error = error;
+			best = cur;
+			if (error == 0)
+				break;
+		}
+	}
+
+	dev_info(&camera->i2c_client->dev,"Selected binning %dx%d type: %s\n",
+		 best->vfact,best->hfact,binning_type_str[type]);
+
+	binning_rect.width = best->max_width;
+	binning_rect.height = best->max_height;
+
+	v4l2_rect_scale(&scaled_crop,max,&binning_rect);
+
+	v4l_bound_align_image(&scaled_crop.width,min->width,
+			      binning_rect.width,3,
+			      &scaled_crop.height,min->height,
+			      binning_rect.height,3,0);
+
+	*width = scaled_crop.width;
+	*height = scaled_crop.height;
+
+	dev_info(&camera->i2c_client->dev,"Selected crop (%u,%u) %ux%u\n",
+		 scaled_crop.left,scaled_crop.top,
+		 scaled_crop.width,scaled_crop.height);
+
+	*info = best;
+}
+
+static int avt_update_format(struct avt_dev *camera,
+	const struct v4l2_rect *roi,
+	const struct avt_binning_info *info)
+{
+	int ret = 0;
+	struct v4l2_rect scaled_roi = *roi;
+	const struct v4l2_rect binning_rect = {
+		.width = info->max_width,
+		.height = info->max_height,
+	};
+
+	v4l2_rect_scale(&scaled_roi, &camera->sensor_rect, &binning_rect);
+
+	v4l_bound_align_image(
+		&scaled_roi.width,camera->min_rect.width,
+		binning_rect.width,3,
+		&scaled_roi.height,camera->min_rect.height,
+		binning_rect.height,3,0);
+
+	ret = bcrm_write8(camera, BCRM_BINNING_SETTING_8RW, info->sel);
+	if (unlikely(ret))
+		return ret;
+
+	ret = bcrm_write32(camera, BCRM_IMG_WIDTH_32RW, scaled_roi.width);
+	if (unlikely(ret))
+		return ret;
+
+	ret = bcrm_write32(camera, BCRM_IMG_HEIGHT_32RW, scaled_roi.height);
+	if (unlikely(ret))
+		return ret;
+
+	ret = bcrm_write32(camera, BCRM_IMG_OFFSET_X_32RW, scaled_roi.left);
+	if (unlikely(ret))
+		return ret;
+
+	ret = bcrm_write32(camera, BCRM_IMG_OFFSET_Y_32RW, scaled_roi.top);
+	if (unlikely(ret))
+		return ret;
+
+	camera->curr_binning_info = info;
+
+	return ret;
+}
+
+static int avt_try_fmt_internal(struct v4l2_subdev *sd,
+				 struct v4l2_mbus_framefmt *fmt,
+				 const struct avt_binning_info **new_binning)
+{
+	struct avt_dev *camera = to_avt_dev(sd);
+	int i;
+
+	avt_calc_compose(camera,&camera->curr_rect,&fmt->width,&fmt->height,
+			  new_binning);
+
+	dev_info(&camera->i2c_client->dev, "%s[%d]",
+			 __func__, __LINE__);
+	avt_dbg(get_sd(camera), "fmt->width %d, fmt->height %d, fmt->code 0x%04X, "
+		"camera->available_fmts_cnt %d, camera->mbus_framefmt.code 0x%04X",
+			  fmt->width, fmt->height, fmt->code,
+			  camera->available_fmts_cnt,
+			  camera->mbus_framefmt.code);
+
+
+	for (i = 0; i < camera->available_fmts_cnt; i++)
+	{
+		avt_dbg(get_sd(camera), "loop %d: fmt->width %d, fmt->height %d, "
+		 	"camera->mbus_framefmt.code 0x%04X, "
+			"camera->available_fmts[%d].mbus_code 0x%04X, "
+			"fmt->code 0x%04X",
+				  i, fmt->width, fmt->height,
+				  camera->mbus_framefmt.code,
+				  i,
+				  camera->available_fmts[i].mbus_code,
+				  fmt->code);
+		if (camera->available_fmts[i].mbus_code == fmt->code)
+		{
+			break;
+		}
+	}
+
+	if (i == camera->available_fmts_cnt)
+	{
+		avt_dbg(sd, "format fmt->code 0x%04X not found in available formats [ToDo: error handling incomplete]", fmt->code);
+		fmt->code = camera->mbus_framefmt.code;
+		//return -EINVAL;
+	}
+
+	memset(fmt->reserved, 0, sizeof(fmt->reserved));
+
+	fmt->colorspace = camera->available_fmts[i].colorspace;
+	fmt->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(fmt->colorspace);
+	fmt->quantization = V4L2_QUANTIZATION_FULL_RANGE;
+	fmt->xfer_func = V4L2_XFER_FUNC_DEFAULT;
+
+	return 0;
+}
+
+static int avt_update_exposure_limits(struct v4l2_subdev *sd) {
+	struct avt_dev *camera = to_avt_dev(sd);
+	int ret;
+	u64 exp_min, exp_max, exp_inc;
+
+	ret = bcrm_read64(camera, BCRM_EXPOSURE_TIME_MIN_64R, &exp_min);
+	if(ret < 0) {
+		avt_err(sd, "Failed to read minimum exposure: %d", ret);
+		goto err;
+	}
+
+	ret = bcrm_read64(camera, BCRM_EXPOSURE_TIME_MAX_64R, &exp_max);
+	if(ret < 0) {
+		avt_err(sd, "Failed to read maximum exposure: %d", ret);
+		goto err;
+	}
+
+	ret = bcrm_read64(camera, BCRM_EXPOSURE_TIME_INC_64R, &exp_inc);
+	if(ret < 0) {
+		avt_err(sd, "Failed to read exposure increment: %d", ret);
+		goto err;
+	}
+
+	{
+		struct v4l2_ctrl * exp_ctrl = avt_ctrl_find(camera, V4L2_CID_EXPOSURE);
+		if(exp_ctrl != NULL) {
+			__v4l2_ctrl_modify_range(exp_ctrl, exp_min, exp_max, exp_inc, exp_ctrl->default_value);
+		}
+	}
+
+	{
+		struct v4l2_ctrl* exp_abs_ctrl = avt_ctrl_find(camera, V4L2_CID_EXPOSURE_ABSOLUTE);
+		if(exp_abs_ctrl != NULL) {
+			__v4l2_ctrl_modify_range(exp_abs_ctrl, exp_min / EXP_ABS, exp_max / EXP_ABS, exp_inc / EXP_ABS, exp_abs_ctrl->default_value);
+		}
+	}
+
+	{
+		struct v4l2_ctrl *exp_auto_min_ctrl =
+			avt_ctrl_find(camera, AVT_CID_EXPOSURE_AUTO_MIN);
+		struct v4l2_ctrl *exp_auto_max_ctrl =
+			avt_ctrl_find(camera, AVT_CID_EXPOSURE_AUTO_MAX);
+
+		if(exp_auto_min_ctrl != NULL && exp_auto_max_ctrl != NULL) {
+			__v4l2_ctrl_modify_range(exp_auto_min_ctrl, exp_min, exp_max, exp_inc, exp_min);
+			__v4l2_ctrl_modify_range(exp_auto_max_ctrl, exp_min, exp_max, exp_inc, exp_max);
+			__v4l2_ctrl_s_ctrl_int64(exp_auto_min_ctrl, exp_min);
+			__v4l2_ctrl_s_ctrl_int64(exp_auto_max_ctrl, exp_max);
+		}
+	}
+
+err:
+	return ret;
+}
+
+static int avt_write_media_bus_format(struct avt_dev *camera, int code)
+{
+	struct device *dev = &camera->i2c_client->dev;
+	const struct avt_csi_mipi_mode_mapping *fmt_mapping;
+	int idx = lookup_media_bus_format_index(camera, code);
+	int ret = 0;
+
+	if (idx < 0) {
+		return -EINVAL;
+	}
+
+	fmt_mapping = &camera->available_fmts[idx];
+
+	ret = bcrm_write32(camera, BCRM_IMG_MIPI_DATA_FORMAT_32RW,
+		fmt_mapping->mipi_fmt);
+
+	if (unlikely(ret)) {
+		dev_err(dev, "Failed to set mipi format to %x with %d\n",
+			fmt_mapping->mipi_fmt, ret);
+
+		goto exit;
+	}
+
+	if (fmt_mapping->bayer_pattern != bayer_ignore) {
+		ret = bcrm_write8(camera, BCRM_IMG_BAYER_PATTERN_8RW,
+			fmt_mapping->bayer_pattern);
+
+		if (unlikely(ret)) {
+			dev_err(dev,
+				"Failed to set bayer pattern to %x with %d\n",
+				fmt_mapping->bayer_pattern, ret);
+
+			goto exit;
+		}
+	}
+
+exit:
+	return ret;
+}
+
+static int avt_set_fmt_internal_bcrm(struct avt_dev *camera,
+	struct v4l2_subdev_state *sd_state,
+	struct v4l2_subdev_format *format)
+{
+	struct v4l2_subdev *sd = get_sd(camera);
+	struct v4l2_mbus_framefmt *mbus_fmt = &format->format;
+	const struct avt_binning_info *new_binning = NULL;
+	struct v4l2_mbus_framefmt *fmt;
+	int ret = 0;
+
+	if (mbus_fmt->code == MEDIA_BUS_FMT_CUSTOM) {
+		if (format->which != V4L2_SUBDEV_FORMAT_TRY) {
+			*mbus_fmt = camera->mbus_framefmt;
+			goto out;
+		}
+	} else {
+		ret = avt_try_fmt_internal(sd, mbus_fmt, &new_binning);
+		if (ret)
+			goto out;
+	}
+
+
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY) {
+		avt_dbg(sd,  "format->which == V4L2_SUBDEV_FORMAT_TRY");
+		fmt = v4l2_subdev_get_try_format(sd, sd_state, format->pad);
+	} else {
+		avt_dbg(sd,  "format->which != V4L2_SUBDEV_FORMAT_TRY");
+		fmt = &camera->mbus_framefmt;
+
+		if (new_binning != camera->curr_binning_info) {
+			ret = avt_update_format(camera, &camera->curr_rect, new_binning);
+			if (ret < 0)
+				goto out;
+		}
+
+		if (mbus_fmt->code != camera->mbus_framefmt.code) {
+			ret = avt_write_media_bus_format(camera, mbus_fmt->code);
+
+			if(ret < 0) {
+				avt_err(sd, "Failed setting pixel format in camera: %d", ret);
+				goto out;
+			}
+
+			ret = avt_update_exposure_limits(sd);
+		}
+	}
+
+	*fmt = *mbus_fmt;
+
+out:
+	return ret;
+}
+
+static int avt_set_fmt_internal_gencp(struct avt_dev *camera,
+	struct v4l2_subdev_state *sd_state,
+	struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mbus_fmt = &format->format;
+
+	if (mbus_fmt->code != MEDIA_BUS_FMT_CUSTOM)
+		mbus_fmt->code = MEDIA_BUS_FMT_CUSTOM;
+
+	//Reset cropping if genicam for csi2 mode is selected
+	camera->curr_rect.left = 0;
+	camera->curr_rect.top = 0;
+	camera->curr_rect.width = mbus_fmt->width;
+	camera->curr_rect.height = mbus_fmt->height;
+
+	return 0;
+}
+
+
+static int avt_pad_ops_set_fmt(struct v4l2_subdev *sd,
+				struct v4l2_subdev_state *sd_state,
+				struct v4l2_subdev_format *format)
+{
+	struct avt_dev *camera = to_avt_dev(sd);
+
+
+	int ret;
+
+	avt_dbg(sd, "%s[%d]",
+			 __func__, __LINE__);
+	avt_dbg(sd, "%d x %d, format.code 0x%04X, format.pad %d",
+			format->format.width, format->format.height, format->format.code, format->pad);
+
+	if (format->pad != 0)
+		return -EINVAL;
+
+	mutex_lock(&camera->lock);
+	if (camera->is_streaming) {
+		ret = -EBUSY;
+		goto out;
+	}
+
+	if (camera->mode == AVT_BCRM_MODE) {
+		ret = avt_set_fmt_internal_bcrm(camera, sd_state, format);
+	} else if (camera->mode == AVT_GENCP_MODE) {
+		ret = avt_set_fmt_internal_gencp(camera, sd_state, format);
+	} else {
+		ret = -EINVAL;
+	}
+
+out:
+	mutex_unlock(&camera->lock);
+
+	return ret;
+}
+static int read_control_value(struct avt_dev *camera,s64 *value, const u16 reg,
+			      const u8 size)
+{
+	int ret = 0;
+	u8 tmp[8];
+
+	if (size > AV_CAM_DATA_SIZE_64)
+		return -EINVAL;
+
+	ret = avt_read_raw(camera, get_bcrm_addr(camera, reg), tmp, size);
+
+	if (ret < 0)
+		return ret;
+
+	switch (size)
+	{
+	case AV_CAM_DATA_SIZE_8:
+		*value = tmp[0];
+		break;
+	case AV_CAM_DATA_SIZE_16:
+		*value = get_unaligned_be16(tmp);
+		break;
+	case AV_CAM_DATA_SIZE_32:
+		*value = (s32)get_unaligned_be32(tmp);
+		break;
+	case AV_CAM_DATA_SIZE_64:
+		*value = (s64)get_unaligned_be64(tmp);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+static void avt_ctrl_to_reg(const u32 cid,s64 * value)
+{
+	switch (cid) {
+	case V4L2_CID_EXPOSURE_AUTO:
+		if (*value == V4L2_EXPOSURE_MANUAL)
+			*value = 0;
+		else
+			*value = 2;
+		break;
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+	case V4L2_CID_AUTOGAIN:
+		if (*value)
+			*value = 2;
+		else
+			*value = 0;
+		break;
+	case V4L2_CID_EXPOSURE_ABSOLUTE:
+		*value = *value * EXP_ABS;
+		break;
+	default:
+		break;
+	}
+}
+
+static void avt_ctrl_from_reg(const u32 cid,s64 * value)
+{
+	switch (cid) {
+	case V4L2_CID_EXPOSURE_AUTO:
+		if (*value)
+			*value = V4L2_EXPOSURE_AUTO;
+		else
+			*value = V4L2_EXPOSURE_MANUAL;
+		break;
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+	case V4L2_CID_AUTOGAIN:
+		if (*value)
+			*value = 1;
+		else
+			*value = 0;
+		break;
+	case V4L2_CID_EXPOSURE_ABSOLUTE:
+		*value = *value / EXP_ABS;
+		break;
+	default:
+		break;
+	}
+}
+
+static int avt_update_ctrl_value(struct avt_dev *camera,
+				  struct v4l2_ctrl *ctrl,
+				  const struct avt_ctrl_mapping *mapping)
+{
+	const u16 reg = mapping->reg_offset;
+	const u8 len = mapping->reg_length;
+	int ret = 0;
+	s64 value = 0;
+
+	ret = read_control_value(camera, &value, reg, len);
+
+	if (ret < 0) {
+		avt_err(get_sd(camera),"Reading ctrl %x (reg: %x) failed with: %d",
+			ctrl->id,reg,ret);
+		return ret;
+	}
+
+	avt_ctrl_from_reg(ctrl->id,&value);
+
+	switch (ctrl->type) {
+	case V4L2_CTRL_TYPE_MENU:
+	case V4L2_CTRL_TYPE_BOOLEAN:
+	case V4L2_CTRL_TYPE_INTEGER:
+		ctrl->val = (s32)value;
+		break;
+	case V4L2_CTRL_TYPE_INTEGER64:
+		*ctrl->p_cur.p_s64 = value;
+		*ctrl->p_new.p_s64 = value;
+		break;
+	case V4L2_CTRL_TYPE_U8:
+		*ctrl->p_cur.p_u8 = value;
+		*ctrl->p_new.p_u8 = value;
+		break;
+	case V4L2_CTRL_TYPE_U16:
+		*ctrl->p_cur.p_u16 = value;
+		*ctrl->p_new.p_u16 = value;
+		break;
+	case V4L2_CTRL_TYPE_U32:
+		*ctrl->p_cur.p_u32 = value;
+		*ctrl->p_new.p_u32 = value;
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int avt_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
+{
+	const struct avt_ctrl_mapping * const ctrl_mapping = ctrl->priv;
+	struct avt_dev *camera = container_of(ctrl->handler, struct avt_dev, v4l2_ctrl_hdl);
+
+	avt_dbg(get_sd(camera), "ctrl->id %d", ctrl->id);
+
+	if (camera->mode != AVT_BCRM_MODE) {
+		return -EBUSY;
+	}
+
+	if (ctrl->id == AVT_CID_BINNING_SETTING) {
+		ctrl->p_new.p_area->width = camera->curr_binning_info->hfact;
+		ctrl->p_new.p_area->height = camera->curr_binning_info->vfact;
+		return 0;
+	}
+
+	if (unlikely(!ctrl_mapping)) {
+		avt_warn(get_sd(camera), "Invalid control mapping!\n");
+		return -EINVAL;
+	}
+
+	return avt_update_ctrl_value(camera, ctrl, ctrl_mapping);
+}
+
+static struct v4l2_ctrl* avt_ctrl_find(struct avt_dev *camera,u32 id)
+{
+	int i;
+
+	for (i = 0; i < AVT_MAX_CTRLS; i++)
+	{
+		struct v4l2_ctrl * ctrl = camera->avt_ctrls[i];
+
+		if (ctrl && ctrl->id == id)
+		{
+			return ctrl;
+		}
+	}
+
+	return NULL;
+}
+
+static inline int avt_trigger_mode_enabled(struct avt_dev *camera)
+{
+	u8 tmp = 0;
+	int ret = 0;
+
+	const struct v4l2_ctrl * trigger_mode_ctrl =
+			avt_ctrl_find(camera, AVT_CID_TRIGGER_MODE);
+
+	if (trigger_mode_ctrl) {
+		return trigger_mode_ctrl->val != 0;
+	}
+
+	ret = bcrm_read8(camera, BCRM_FRAME_START_TRIGGER_MODE_8RW, &tmp);
+
+	if (unlikely(ret)) {
+		return ret;
+	}
+
+	return tmp != 0;
+}
+
+static inline int avt_test_trigger_source(struct avt_dev *camera, int source)
+{
+	u8 tmp = 0;
+	int ret = 0;
+
+	const struct v4l2_ctrl * trigger_source_ctrl =
+		avt_ctrl_find(camera, AVT_CID_TRIGGER_SOURCE);
+
+	if (trigger_source_ctrl) {
+		return trigger_source_ctrl->val == source;
+	}
+
+	ret = bcrm_read8(camera, BCRM_FRAME_START_TRIGGER_SOURCE_8RW, &tmp);
+
+	if (unlikely(ret)) {
+		return ret;
+	}
+
+	return tmp == source;
+}
+
+static void avt_update_sw_ctrl_state(struct avt_dev *camera)
+{
+	int trigger_en = 0, trigger_sw_source = 0;
+	struct v4l2_ctrl * sw_trigger_ctrl =
+		avt_ctrl_find(camera, AVT_CID_TRIGGER_SOFTWARE);
+
+	if (!sw_trigger_ctrl) {
+		avt_warn(get_sd(camera),"Software trigger control not found!");
+		return;
+	}
+
+	trigger_en = avt_trigger_mode_enabled(camera);
+	if (trigger_en < 0) {
+		return;
+	}
+
+	trigger_sw_source =
+		avt_test_trigger_source(camera, AVT_TRIGGER_SOURCE_SOFTWARE);
+	if (trigger_sw_source < 0) {
+		return;
+	}
+
+	v4l2_ctrl_activate(sw_trigger_ctrl, trigger_en && trigger_sw_source);
+}
+
+static const struct v4l2_event avt_source_change_event = {
+	.type = V4L2_EVENT_SOURCE_CHANGE,
+	.u.src_change.changes = V4L2_EVENT_SRC_CH_RESOLUTION,
+};
+
+static void avt_ctrl_changed(struct avt_dev *camera,
+			      const struct v4l2_ctrl * const ctrl)
+{
+	switch (ctrl->id)
+	{
+	case AVT_CID_TRIGGER_MODE:
+		avt_update_sw_ctrl_state(camera);
+		break;
+	case AVT_CID_TRIGGER_SOURCE:
+		avt_update_sw_ctrl_state(camera);
+		break;
+	case AVT_CID_EXPOSURE_AUTO_MIN: {
+		struct v4l2_ctrl *max_ctrl;
+
+		max_ctrl = avt_ctrl_find(camera, AVT_CID_EXPOSURE_AUTO_MAX);
+
+		if (max_ctrl == NULL)
+			break;
+
+		__v4l2_ctrl_modify_range(max_ctrl,*ctrl->p_new.p_s64,
+					 max_ctrl->maximum,max_ctrl->step,
+					 max_ctrl->default_value);
+
+		break;
+	}
+	case AVT_CID_EXPOSURE_AUTO_MAX: {
+		struct v4l2_ctrl *min_ctrl;
+
+		min_ctrl = avt_ctrl_find(camera, AVT_CID_EXPOSURE_AUTO_MIN);
+
+		if (min_ctrl == NULL)
+			break;
+
+		__v4l2_ctrl_modify_range(min_ctrl,min_ctrl->minimum,
+					 *ctrl->p_new.p_s64,min_ctrl->step,
+					 min_ctrl->default_value);
+
+		break;
+	}
+	case AVT_CID_GAIN_AUTO_MIN: {
+		struct v4l2_ctrl *max_ctrl;
+
+		max_ctrl = avt_ctrl_find(camera, AVT_CID_GAIN_AUTO_MAX);
+
+		if (max_ctrl == NULL)
+			break;
+
+		__v4l2_ctrl_modify_range(max_ctrl,*ctrl->p_new.p_s64,
+					 max_ctrl->maximum,max_ctrl->step,
+					 max_ctrl->default_value);
+
+		break;
+	}
+	case AVT_CID_GAIN_AUTO_MAX: {
+		struct v4l2_ctrl *min_ctrl;
+
+		min_ctrl = avt_ctrl_find(camera, AVT_CID_GAIN_AUTO_MIN);
+
+		if (min_ctrl == NULL)
+			break;
+
+		__v4l2_ctrl_modify_range(min_ctrl,min_ctrl->minimum,
+					 *ctrl->p_new.p_s64,min_ctrl->step,
+					 min_ctrl->default_value);
+
+		break;
+	}
+	case V4L2_CID_AUTOGAIN: {
+		struct v4l2_ctrl *gain_ctrl;
+
+		gain_ctrl = avt_ctrl_find(camera,V4L2_CID_GAIN);
+
+		if (gain_ctrl != NULL)
+			__v4l2_ctrl_grab(gain_ctrl,ctrl->val);
+
+		break;
+	}
+	case V4L2_CID_EXPOSURE_AUTO: {
+		struct v4l2_ctrl *exp_ctrl,*exp_abs_ctrl;
+		bool grabbed = (ctrl->val == V4L2_EXPOSURE_AUTO);
+
+		exp_ctrl = avt_ctrl_find(camera,V4L2_CID_EXPOSURE);
+
+		if (exp_ctrl != NULL)
+			__v4l2_ctrl_grab(exp_ctrl,grabbed);
+
+		exp_abs_ctrl = avt_ctrl_find(camera,V4L2_CID_EXPOSURE_ABSOLUTE);
+
+		if (exp_abs_ctrl != NULL)
+			__v4l2_ctrl_grab(exp_abs_ctrl,grabbed);
+
+		break;
+	}
+	case AVT_CID_BINNING_SELECTOR: {
+		const struct avt_binning_info *info;
+		struct v4l2_ctrl *binning_mode_ctrl;
+		u32 width = camera->mbus_framefmt.width;
+		u32 height = camera->mbus_framefmt.height;
+
+		camera->curr_binning_type = ctrl->val;
+
+		avt_calc_compose(camera, &camera->curr_rect, &width, &height,
+				  &info);
+
+		camera->curr_binning_info = info;
+
+		if (camera->mbus_framefmt.width != width
+		    || camera->mbus_framefmt.height != height) {
+
+			camera->mbus_framefmt.width = width;
+			camera->mbus_framefmt.height = height;
+
+			v4l2_subdev_notify_event(get_sd(camera),
+						 &avt_source_change_event);
+		}
+
+		binning_mode_ctrl =
+			avt_ctrl_find(camera, AVT_CID_BINNING_MODE);
+		if (binning_mode_ctrl != NULL)
+		{
+			const long modes_enabled = binning_modes_enabled[ctrl->val];
+			const u32 new_mode = find_first_bit(&modes_enabled,sizeof(modes_enabled));
+
+			__v4l2_ctrl_s_ctrl(binning_mode_ctrl,new_mode);
+
+			__v4l2_ctrl_modify_range(binning_mode_ctrl,
+						 binning_mode_ctrl->minimum,
+						 binning_mode_ctrl->maximum,
+						 ~modes_enabled,
+						 new_mode);
+		}
+
+	}
+		break;
+	default:
+		break;
+	}
+
+}
+
+static int write_ctrl_value(struct avt_dev *camera,struct v4l2_ctrl *ctrl,
+		      const struct avt_ctrl_mapping * const ctrl_mapping)
+{
+	const u16 reg = ctrl_mapping->reg_offset;
+	const u8 reg_length = ctrl_mapping->reg_length;
+	s64 temp;
+	int ret = 0;
+
+	if (ctrl->type == V4L2_CTRL_TYPE_INTEGER64)
+		temp = *ctrl->p_new.p_s64;
+	else
+		temp = ctrl->val;
+
+	avt_ctrl_to_reg(ctrl->id,&temp);
+
+	if (ctrl_mapping->type == V4L2_CTRL_TYPE_BUTTON) {
+		ret = bcrm_write(camera, reg, 1, reg_length);
+	} else {
+		ret = bcrm_write(camera, reg, temp, reg_length);
+	}
+
+	if (ret < 0)
+		return ret;
+
+	if (ctrl_mapping->avt_flags & AVT_CTRL_FLAG_READ_BACK) {
+		ret =  avt_update_ctrl_value(camera, ctrl, ctrl_mapping);
+		if (ret < 0)
+			dev_err(&camera->i2c_client->dev,
+				"Control read back failed with %d",
+				ret);
+	}
+
+
+	return ret;
+}
+
+static int avt_v4l2_ctrl_ops_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct avt_dev *camera = container_of(ctrl->handler, struct avt_dev, v4l2_ctrl_hdl);
+	struct i2c_client *client = camera->i2c_client;
+	int ret = 0;
+
+	if (camera->mode != AVT_BCRM_MODE) {
+		return -EBUSY;
+	}
+
+	/* ignore if camera is in sleep mode */
+	if (camera->power_count == 0)
+	{
+		avt_dbg(get_sd(camera), "ToDo: Sensor is in sleep mode. Maybe it is better to ignore ctrl->id 0x%08X, camera->power_count %d",
+				 ctrl->id, camera->power_count);
+		// return -EINVAL;
+	}
+
+	if (camera->power_count > 1)
+	{
+		avt_info(get_sd(camera), "ctrl->id 0x%08X, camera->power_count %d", ctrl->id, camera->power_count);
+	}
+
+	if (ctrl->id == AVT_CID_EXPOSURE_ACTIVE_LINE_MODE)
+	{
+		struct v4l2_ctrl *sel_ctrl,*invert_ctrl;
+		u8 output_line_shift,invert,active = ctrl->val;
+		u32 line_config;
+
+		sel_ctrl = avt_ctrl_find(camera,
+					  AVT_CID_EXPOSURE_ACTIVE_LINE_SELECTOR);
+
+		if (sel_ctrl == NULL) {
+			return -EINVAL;
+		}
+
+		output_line_shift = sel_ctrl->val * 8;
+
+		invert_ctrl = avt_ctrl_find(camera,
+					     AVT_CID_EXPOSURE_ACTIVE_INVERT);
+
+		if (invert_ctrl == NULL) {
+			return -EINVAL;
+		}
+
+		invert = invert_ctrl->val ? 2 : 0;
+
+		line_config = (active ? (1 | invert ) : 0) << output_line_shift;
+
+		ret = bcrm_write32(camera, BCRM_LINE_CONFIGURATION_32RW, line_config);
+
+		if (ret < 0)
+			return ret;
+
+		__v4l2_ctrl_grab(sel_ctrl,active);
+		__v4l2_ctrl_grab(invert_ctrl,active);
+	}
+
+	if (ctrl->priv != NULL)
+	{
+		const struct avt_ctrl_mapping * const ctrl_mapping = ctrl->priv;
+
+
+		dev_dbg(&client->dev, "%s[%d]: Write custom ctrl %s (%x)\n",
+			 __func__, __LINE__, ctrl_mapping->attr.name, ctrl->id);
+
+		if (ctrl_mapping->reg_length != 0) {
+			ret = write_ctrl_value(camera,ctrl,ctrl_mapping);
+		}
+
+
+		avt_ctrl_changed(camera,ctrl);
+	}
+	else
+	{
+		dev_err(&camera->i2c_client->dev,
+			"%s[%d]: case default or not supported id %d, val %d\n",
+			__func__, __LINE__, ctrl->id, ctrl->val);
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops avt_ctrl_ops = {
+	.g_volatile_ctrl = avt_g_volatile_ctrl,
+	.s_ctrl = avt_v4l2_ctrl_ops_s_ctrl,
+};
+
+
+static int avt_fill_ctrl_config(struct avt_dev *camera,
+				 struct v4l2_ctrl_config *config,
+				 const struct avt_ctrl_mapping *mapping)
+{
+	int ret;
+
+
+
+	config->ops = &avt_ctrl_ops;
+	config->id = mapping->id;
+	config->name = mapping->attr.name;
+	config->type = mapping->type;
+	config->flags = mapping->flags;
+
+	switch (mapping->type)
+	{
+	case V4L2_CTRL_TYPE_MENU:
+		config->min = mapping->min_value;
+		config->menu_skip_mask = 0;
+		config->max = mapping->max_value;
+		config->qmenu = mapping->qmenu;
+		ret = read_control_value(camera, &config->def,
+					 mapping->reg_offset,
+					 mapping->reg_length);
+		if (ret < 0)
+			return ret;
+
+		avt_ctrl_from_reg(mapping->id,&config->def);
+
+		break;
+	case V4L2_CTRL_TYPE_BOOLEAN:
+		config->min = 0;
+		config->max = 1;
+		config->step = 1;
+		break;
+	case V4L2_CTRL_TYPE_INTEGER:
+	case V4L2_CTRL_TYPE_INTEGER64:
+	case V4L2_CTRL_TYPE_STRING:
+		if (!mapping->min_offset)
+			config->min = mapping->min_value;
+		else {
+			ret = read_control_value(camera, &config->min,
+						 mapping->min_offset,
+						 mapping->reg_length);
+			if (ret < 0)
+				return ret;
+
+			avt_ctrl_from_reg(mapping->id,&config->min);
+		}
+
+		if (!mapping->max_offset)
+			config->max = mapping->max_value;
+		else {
+			ret = read_control_value(camera, &config->max,
+						 mapping->max_offset,
+						 mapping->reg_length);
+			if (ret < 0)
+				return ret;
+
+			avt_ctrl_from_reg(mapping->id,&config->max);
+		}
+
+		if (!mapping->step_offset)
+			config->step = mapping->step_value;
+		else {
+			ret = read_control_value(camera, &config->step,
+						 mapping->step_offset,
+						 mapping->reg_length);
+			if (ret < 0)
+				return ret;
+
+			avt_ctrl_from_reg(mapping->id,&config->step);
+		}
+
+		if (!mapping->reg_offset)
+			config->def = mapping->default_value;
+		else {
+			ret = read_control_value(camera, &config->def,
+						 mapping->reg_offset,
+						 mapping->reg_length);
+			if (ret < 0)
+				return ret;
+
+			avt_ctrl_from_reg(mapping->id,&config->def);
+
+			if (config->def < config->min) {
+				config->def = config->min;
+			}
+
+			if (config->def > config->max) {
+				config->def = config->max;
+			}
+		}
+
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static void avt_ctrl_added(struct avt_dev *camera,struct v4l2_ctrl *ctrl)
+{
+	switch (ctrl->id)
+	{
+	case AVT_CID_TRIGGER_MODE:
+		avt_update_sw_ctrl_state(camera);
+		break;
+	case AVT_CID_TRIGGER_SOURCE:
+		avt_update_sw_ctrl_state(camera);
+		break;
+	case AVT_CID_TRIGGER_SOFTWARE:
+		avt_update_sw_ctrl_state(camera);
+		break;
+	case AVT_CID_FIRMWARE_VERSION: {
+		const union device_firmware_version_reg *fw_version =
+			&camera->cam_firmware_version;
+		snprintf(ctrl->p_cur.p_char,ctrl->elem_size,
+			"%02u.%02u.%02u.%08x",
+			 fw_version->device_firmware.special_version,
+			 fw_version->device_firmware.major_version,
+			 fw_version->device_firmware.minor_version,
+			 fw_version->device_firmware.patch_version);
+		break;
+	}
+	case AVT_CID_CAMERA_NAME:  {
+		snprintf(ctrl->p_cur.p_char,ctrl->elem_size,"%s %s",
+			 camera->cci_reg.reg.family_name,
+			 camera->cci_reg.reg.model_name);
+
+		break;
+	}
+	case AVT_CID_SERIAL_NUMBER:  {
+		snprintf(ctrl->p_cur.p_char,ctrl->elem_size,"%s",
+			 camera->cci_reg.reg.serial_number);
+
+		break;
+	}
+	case AVT_CID_EXPOSURE_AUTO_MIN: {
+		struct v4l2_ctrl *max_ctrl = NULL;
+
+		max_ctrl = avt_ctrl_find(camera, AVT_CID_EXPOSURE_AUTO_MAX);
+
+		if (max_ctrl == NULL)
+			return;
+
+		v4l2_ctrl_modify_range(ctrl,ctrl->minimum,
+					 max_ctrl->default_value,ctrl->step,
+					 ctrl->default_value);
+
+		break;
+	}
+	case AVT_CID_EXPOSURE_AUTO_MAX: {
+		struct v4l2_ctrl *min_ctrl = NULL;
+
+		min_ctrl = avt_ctrl_find(camera, AVT_CID_EXPOSURE_AUTO_MIN);
+
+		if (min_ctrl == NULL) {
+			avt_warn(get_sd(camera),"V4L2_CID_EXPOSURE_AUTO_MIN not found!");
+			return;
+		}
+
+		v4l2_ctrl_modify_range(ctrl,min_ctrl->default_value,
+					 ctrl->maximum,ctrl->step,
+					 ctrl->default_value);
+
+		break;
+	}
+	case AVT_CID_GAIN_AUTO_MIN: {
+		struct v4l2_ctrl *max_ctrl = NULL;
+
+		max_ctrl = avt_ctrl_find(camera, AVT_CID_GAIN_AUTO_MAX);
+
+		if (max_ctrl == NULL)
+			return;
+
+		v4l2_ctrl_modify_range(ctrl,ctrl->minimum,
+				       max_ctrl->default_value,ctrl->step,
+				       ctrl->default_value);
+
+		break;
+	}
+	case AVT_CID_GAIN_AUTO_MAX: {
+		struct v4l2_ctrl *min_ctrl = NULL;
+
+		min_ctrl = avt_ctrl_find(camera, AVT_CID_GAIN_AUTO_MIN);
+
+		if (min_ctrl == NULL) {
+			avt_warn(get_sd(camera),"V4L2_CID_EXPOSURE_AUTO_MIN not found!");
+			return;
+		}
+
+		v4l2_ctrl_modify_range(ctrl,min_ctrl->default_value,
+				       ctrl->maximum,ctrl->step,
+				       ctrl->default_value);
+
+		break;
+	}
+	default:
+		break;
+	}
+}
+
+static int avt_init_controls(struct avt_dev *camera)
+{
+	struct v4l2_ctrl_config config;
+	struct v4l2_ctrl *ctrl;
+	int ret;
+	int i, j;
+
+	avt_dbg(get_sd(camera), "code uses now v4l2_ctrl_new_std and v4l2_query_ext_ctrl (VIDIOC_QUERY_EXT_CTRL / s64) ");
+
+	ret = v4l2_ctrl_handler_init(&camera->v4l2_ctrl_hdl, ARRAY_SIZE(avt_ctrl_mappings));
+	if (ret < 0)
+	{
+		avt_err(get_sd(camera), "v4l2_ctrl_handler_init Failed");
+		goto free_ctrls;
+	}
+	/* we can use our own mutex for the ctrl lock */
+	camera->v4l2_ctrl_hdl.lock = &camera->lock;
+
+	for (i = 0, j = 0; j < ARRAY_SIZE(avt_ctrl_mappings); ++j)
+	{
+		const struct avt_ctrl_mapping * const ctrl_mapping
+			= &avt_ctrl_mappings[j];
+		const s8 feat_bit = ctrl_mapping->attr.feature_avail;
+		const u64 inq_reg = camera->feature_inquiry_reg.value;
+
+		if ((feat_bit != -1 && (inq_reg & (1 << feat_bit)) == 0)) {
+			avt_info(get_sd(camera),
+				 "Control %s (0x%x) not supported by camera\n",
+				 ctrl_mapping->attr.name,ctrl_mapping->id);
+			continue;
+		}
+
+		CLEAR(config);
+
+		avt_dbg(get_sd(camera), "Init ctrl %s (0x%x)\n",
+			 ctrl_mapping->attr.name,ctrl_mapping->id);
+
+
+		avt_fill_ctrl_config(camera,&config,ctrl_mapping);
+
+
+		camera->avt_ctrl_cfg[i] = config;
+
+		ctrl = v4l2_ctrl_new_custom(&camera->v4l2_ctrl_hdl,
+					    &config,(void*)ctrl_mapping);
+
+		if (ctrl == NULL)
+		{
+			avt_err(get_sd(camera),
+				"Failed to init %s ctrl %d 0x%08x\n",
+				camera->avt_ctrl_cfg[i].name,
+				camera->v4l2_ctrl_hdl.error,
+				camera->v4l2_ctrl_hdl.error);
+
+			if (camera->v4l2_ctrl_hdl.error == -ERANGE) {
+				avt_err(get_sd(camera),
+					"Invalid ctrl range min: %lld max: %lld "
+					"step: %lld def: %lld",
+					config.min,config.max,config.step,config.def);
+			}
+
+            		//Clear error
+			camera->v4l2_ctrl_hdl.error = 0;
+			continue;
+		}
+
+
+		avt_ctrl_added(camera,ctrl);
+
+		camera->avt_ctrls[i] = ctrl;
+		i++;
+	}
+
+	return ret;
+free_ctrls:
+	v4l2_ctrl_handler_free(&camera->v4l2_ctrl_hdl);
+	return ret;
+}
+
+static void set_frameinterval(struct v4l2_fract *interval,const u64 framerate)
+{
+	const u64 factor = UHZ_TO_HZ;
+
+	interval->denominator = (framerate * interval->numerator) / factor;
+
+	// If the denominator and minimal framerate is not zero, try to increase the numerator by 1000
+	while (interval->denominator == 0 && interval->numerator < factor)
+	{
+		interval->numerator *= 1000;
+		interval->denominator = (framerate * interval->numerator) / factor;
+	}
+}
+
+static inline u64 frame_interval_to_rate_uhz(struct v4l2_fract *interval)
+{
+	const u64 fac = UHZ_TO_HZ;
+	return mult_frac(fac, interval->denominator, interval->numerator);
+}
+
+static int avt_pad_ops_enum_frame_size(struct v4l2_subdev *sd,
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(5, 14, 0))
+	struct v4l2_subdev_state *sd_state,
+#else
+	struct v4l2_subdev_pad_config *cfg,
+#endif
+	struct v4l2_subdev_frame_size_enum *fse)
+{
+	struct avt_dev *camera = to_avt_dev(sd);
+	const struct v4l2_rect *min = &camera->min_rect;
+	const struct v4l2_rect *max = &camera->sensor_rect;
+	struct avt_binning_info *binning_info;
+	struct v4l2_rect binning_rect,scaled_crop = camera->curr_rect;
+	size_t max_frame_size;
+
+	avt_dbg(sd, "fse->index %d, fse->which %s", fse->index,
+		fse->which == V4L2_SUBDEV_FORMAT_TRY ? "V4L2_SUBDEV_FORMAT_TRY" : "V4L2_SUBDEV_FORMAT_ACTIVE");
+
+	if (fse->pad != 0)
+	{
+		avt_warn(sd, "Requested pad %d not supported",fse->pad);
+		return -EINVAL;
+	}
+
+#ifdef ENABLE_STEPWISE_IMAGE_SIZE
+	max_frame_size = camera->binning_info_cnt[camera->curr_binning_type];
+
+	if (fse->index >= max_frame_size)
+	{
+		avt_dbg(get_sd(camera), "fse->index(%d) >= %lu.",
+			 fse->index, max_frame_size);
+		return -EINVAL;
+	}
+
+	binning_info
+		= &camera->binning_infos[camera->curr_binning_type][fse->index];
+
+
+	binning_rect.width = binning_info->max_width;
+	binning_rect.height =  binning_info->max_height;
+
+	v4l2_rect_scale(&scaled_crop,max,&binning_rect);
+
+	v4l_bound_align_image(&scaled_crop.width,min->width,
+			      binning_rect.width,3,
+			      &scaled_crop.height,min->height,
+			      binning_rect.height,3,0);
+
+
+	fse->min_width = scaled_crop.width;
+	fse->max_width = scaled_crop.width;
+	fse->min_height = scaled_crop.height;
+	fse->max_height = scaled_crop.height;
+#else
+	if (fse->index >= 1)
+	{
+		avt_dbg(sd_of(camera), "fse->index(%d) >= 1.", fse->index);
+		return -EINVAL;
+	}
+	fse->min_width = camera->min_rect.width;
+	fse->max_width = camera->max_rect.width;
+	fse->min_height = camera->min_rect.height;
+	fse->max_height = camera->max_rect.height;
+
+#endif
+	return 0;
+}
+
+static int avt_pad_ops_enum_frame_interval(
+	struct v4l2_subdev *sd,
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(5, 14, 0))
+	struct v4l2_subdev_state *sd_state,
+#else
+	struct v4l2_subdev_pad_config *cfg,
+#endif
+	struct v4l2_subdev_frame_interval_enum *fie)
+{
+	struct avt_dev *camera = to_avt_dev(sd);
+	u32 width = fie->width;
+	u32 height = fie->height;
+	const struct avt_binning_info *new_binning;
+	int i,ret;
+	u64 max_framerate;
+
+	if (fie->pad != 0)
+	{
+		avt_err(sd, "no pad availble. fie->index %d, fie->pad %d, fie->code 0x%04X, fie->width %d, fie->height %d",
+				fie->index, fie->pad, fie->code, fie->width, fie->height);
+		return -EINVAL;
+	}
+
+	if (fie->index >= 1)
+	{
+		avt_info(sd, "fie->index >= avt_NUM_FRAMERATES fie->index %d, avt_NUM_FRAMERATES %d, fie->pad %d, fie->code 0x%04X, fie->width %d, fie->height %d",
+				 fie->index, 1, fie->pad, fie->code, fie->width, fie->height);
+		return -EINVAL;
+	}
+	/*
+	To enumerate frame intervals applications initialize the index, pad, which, code, width and height fields of
+	struct v4l2_subdev_frame_interval_enum and call the ioctl VIDIOC_SUBDEV_ENUM_FRAME_INTERVAL ioctl with a
+	pointer to this structure. Drivers fill the rest of the structure or return an EINVAL error code if one of
+	the input fields is invalid. All frame intervals are enumerable by beginning at index zero and incrementing
+	by one until EINVAL is returned. */
+
+	i = 0;
+	do
+	{
+		if (camera->available_fmts[i].mbus_code == fie->code)
+			break;
+		i++;
+	} while (i < camera->available_fmts_cnt);
+	if (i == camera->available_fmts_cnt)
+	{
+		avt_err(get_sd(camera), "camera->available_fmts[%d].mbus_code unknown MEDIA_BUS_FMT_ fie->code 0x%04X", i, fie->code);
+		return -EINVAL;
+	}
+
+	// Get matching binning config for requested resolution
+	avt_calc_compose(camera,&camera->curr_rect,&width,&height,
+			  &new_binning);
+
+	if (fie->width != width || fie->height != height)
+	{
+		avt_err(get_sd(camera), "Frameintervals for unsupported width (%u) or height (%u) requested", fie->width,fie->height);
+		return -EINVAL;
+	}
+
+	ret = bcrm_read64(camera,BCRM_ACQUISITION_FRAME_RATE_MAX_64R,&max_framerate);
+
+	if (ret < 0)
+		return ret;
+
+	fie->interval.numerator = 1;
+	set_frameinterval(&fie->interval,max_framerate);
+
+	return 0;
+}
+
+
+static int avt_video_ops_g_frame_interval(struct v4l2_subdev *sd,
+					   struct v4l2_subdev_frame_interval *fi)
+{
+	struct avt_dev *camera = to_avt_dev(sd);
+	int ret = 0;
+
+	mutex_lock(&camera->lock);
+
+	if (avt_trigger_mode_enabled(camera)) {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	fi->interval = camera->frame_interval;
+	avt_dbg(sd, "camera->frame_interval.denom %u, camera->frame_interval.num %u, fi->num %d fi->denom %u",
+			camera->frame_interval.denominator, camera->frame_interval.numerator,
+			fi->interval.numerator, fi->interval.denominator);
+
+exit:
+	mutex_unlock(&camera->lock);
+
+	return ret;
+}
+
+
+
+static int avt_video_ops_s_frame_interval(struct v4l2_subdev *sd,
+					   struct v4l2_subdev_frame_interval *fi)
+{
+	struct avt_dev *camera = to_avt_dev(sd);
+	int ret = 0;
+	u64 framerate_req,framerate_min,framerate_max;
+
+
+	avt_dbg(sd, "fie->num %d fie->denom %d",
+			fi->interval.numerator, fi->interval.denominator);
+
+	mutex_lock(&camera->lock);
+	if (camera->is_streaming)
+	{
+		ret = -EBUSY;
+		goto out;
+	}
+
+	if (avt_trigger_mode_enabled(camera)) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	ret = bcrm_read64(camera,BCRM_ACQUISITION_FRAME_RATE_MIN_64R,
+			  &framerate_min);
+
+	if (ret < 0)
+	{
+		avt_err(sd, "regmap_read failed (%d)\n", ret);
+		goto out;
+	}
+
+	ret = bcrm_read64(camera,BCRM_ACQUISITION_FRAME_RATE_MAX_64R,
+			  &framerate_max);
+
+	if (ret < 0)
+	{
+		avt_err(sd, "regmap_read failed (%d)\n", ret);
+		goto out;
+	}
+
+	if (fi->interval.numerator == 0 || fi->interval.denominator == 0) {
+		camera->framerate_auto = true;
+	}
+	else {
+		framerate_req = frame_interval_to_rate_uhz(&fi->interval);
+		framerate_req = clamp(framerate_req,framerate_min,framerate_max);
+
+		set_frameinterval(&fi->interval, framerate_req);
+
+		camera->framerate_auto = false;
+	}
+
+
+	camera->frame_interval = fi->interval;
+
+	avt_dbg(sd, "set fie->num %d fie->denom %d",
+			fi->interval.numerator, fi->interval.denominator);
+
+out:
+	mutex_unlock(&camera->lock);
+
+	avt_dbg(get_sd(camera), "- fie->num %d fie->denom %d --> idx",
+			fi->interval.numerator, fi->interval.denominator);
+	return ret;
+}
+
+static int avt_pad_ops_enum_mbus_code(struct v4l2_subdev *sd,
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(5, 14, 0))
+									   struct v4l2_subdev_state *sd_state,
+#else
+									   struct v4l2_subdev_pad_config *cfg,
+#endif
+									   struct v4l2_subdev_mbus_code_enum *code)
+{
+	struct avt_dev *camera = to_avt_dev(sd);
+	struct i2c_client *client = camera->i2c_client;
+
+	if (NULL == code)
+	{
+		dev_warn(&client->dev, "%s[%d]: code == NULL", __func__, __LINE__);
+		return -EINVAL;
+	}
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(5, 14, 0))
+	if (NULL == sd_state)
+	{
+		dev_warn(&client->dev, "%s[%d]: sd_state == NULL", __func__, __LINE__);
+	}
+#else
+	if (NULL == cfg)
+	{
+		dev_warn(&client->dev, "%s[%d]: cfg == NULL", __func__, __LINE__);
+	}
+#endif
+
+	if (code->pad != 0)
+	{
+		dev_warn(&client->dev, "%s[%d]: code->pad != 0 fse->index %d, code 0x%04X camera->available_fmts_cnt %d",
+				 __func__, __LINE__, code->index, code->code, camera->available_fmts_cnt);
+
+		return -EINVAL;
+	}
+
+	if (code->index >= camera->available_fmts_cnt)
+	{
+		dev_warn(&client->dev, "%s[%d]: code->index >= camera->available_fmts_cnt fse->index %d, code 0x%04X camera->available_fmts_cnt %d",
+				 __func__, __LINE__, code->index, code->code, camera->available_fmts_cnt);
+		return -EINVAL;
+	}
+
+	code->code = camera->available_fmts[code->index].mbus_code;
+
+	return 0;
+}
+
+static void avt_controls_stream_grab(struct avt_dev *camera,bool grabbed)
+{
+	int i;
+
+	for (i = 0;i < AVT_MAX_CTRLS;i++)
+	{
+		struct v4l2_ctrl *ctrl = camera->avt_ctrls[i];
+
+		if (ctrl && ctrl->priv)
+		{
+			const struct avt_ctrl_mapping * const ctrl_mapping = ctrl->priv;
+
+			if (ctrl_mapping->avt_flags &
+			    AVT_CTRL_FLAG_STREAM_DISABLED)
+			{
+				__v4l2_ctrl_grab(ctrl,grabbed);
+			}
+		}
+	}
+}
+
+static inline int set_auto_framerate(struct avt_dev *camera, bool enabled)
+{
+	const u8 val = enabled ? 0 : 1;
+	return bcrm_write8(camera, BCRM_ACQUISITION_FRAME_RATE_ENABLE_8RW, val);
+}
+
+static int write_framerate(struct avt_dev *camera)
+{
+	int ret = 0;
+
+	if (camera->framerate_auto) {
+		ret = set_auto_framerate(camera, true);
+	} else {
+		struct v4l2_fract *interval = &camera->frame_interval;
+		u64 rate_uhz = frame_interval_to_rate_uhz(interval);
+
+		ret = set_auto_framerate(camera, false);
+		if (unlikely(ret)) {
+			goto exit;
+		}
+
+		ret = bcrm_write64(camera, BCRM_ACQUISITION_FRAME_RATE_64RW,
+			rate_uhz);
+	}
+
+exit:
+	return ret;
+}
+
+static int avt_video_ops_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct avt_dev *camera = to_avt_dev(sd);
+	struct i2c_client *client = camera->i2c_client;
+	int ret = 0;
+
+	dev_info(&client->dev, "%s[%d]: enable %d, camera->is_streaming %d\n"
+						   "	camera->mbus_framefmt.width     %d\n"
+						   "	camera->mbus_framefmt.height    %d\n"
+						   "	camera->mbus_framefmt.code      %d 0x%04X\n"
+						   "	camera->mbus_framefmt.ycbcr_enc %d\n",
+			 __func__, __LINE__, enable, camera->is_streaming,
+			 camera->mbus_framefmt.width,
+			 camera->mbus_framefmt.height,
+			 camera->mbus_framefmt.code,
+			 camera->mbus_framefmt.code,
+			 camera->mbus_framefmt.ycbcr_enc);
+
+	if (camera->mode == AVT_GENCP_MODE)
+		return 0;
+
+	mutex_lock(&camera->lock);
+
+	if (!enable && camera->is_streaming)
+	{
+		ret = bcrm_write8(camera, BCRM_ACQUISITION_STOP_8RW, 1);
+		camera->is_streaming = false;
+
+		// ToDo: eventually wait until cam has stopped streaming
+	}
+
+	if (enable && !camera->is_streaming)
+	{
+		struct v4l2_rect crop_rect = camera->curr_rect;
+		struct v4l2_rect binning_rect = {0};
+		const struct avt_binning_info *binning_info = camera->curr_binning_info;
+
+		binning_rect.width = binning_info->max_width;
+		binning_rect.height = binning_info->max_height;
+
+		v4l2_rect_scale(&crop_rect,&camera->sensor_rect,&binning_rect);
+
+
+		v4l_bound_align_image(&crop_rect.width,camera->min_rect.width,
+				      binning_rect.width,3,
+				      &crop_rect.height,camera->min_rect.height,
+				      binning_rect.height,3,0);
+
+		dev_info(&camera->i2c_client->dev,"Selected crop (%u,%u) %ux%u\n",crop_rect.left,crop_rect.top,crop_rect.width,crop_rect.height);
+
+
+		if (!avt_trigger_mode_enabled(camera)) {
+			ret = write_framerate(camera);
+			if (unlikely(ret))
+				goto out;
+		}
+
+		if (debug >= 2)
+			bcrm_dump(client);
+
+		if (camera->stream_start_phy_reset) {
+			avt_dphy_reset(camera,1);
+
+			usleep_range(100,1000);
+
+			avt_dphy_reset(camera,0);
+		}
+
+		/* start streaming */
+		ret = bcrm_write8(camera, BCRM_ACQUISITION_START_8RW, 1);
+
+		// ToDo: probably it's better to check the status here. but this conflicts with the workaround for imx8mp delayed start
+		if (!ret)
+			camera->is_streaming = enable;
+	}
+
+	avt_controls_stream_grab(camera,enable);
+
+out:
+	mutex_unlock(&camera->lock);
+
+	return ret;
+}
+
+
+int avt_core_ops_reset(struct v4l2_subdev *sd, u32 val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	dev_info(&client->dev, "%s[%d]+ %s", __func__, __LINE__, __FILE__);
+
+	return 0;
+}
+
+int avt_core_ops_g_register(struct v4l2_subdev *sd, struct v4l2_dbg_register *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct avt_dev *camera = to_avt_dev(sd);
+	int ret = 0;
+
+	dev_info(&client->dev, "%s[%d]: reg 0x%04llX, size %d",
+			 __func__, __LINE__, reg->reg, reg->size);
+
+	if (reg->reg & ~0xffff)
+			return -EINVAL;
+
+	if (reg->size != 1 && reg->size != 2 &&
+		reg->size != 4 && reg->size != 8)
+	{
+		ret = -EINVAL;
+	}
+
+	ret = avt_read(camera, reg->reg, &reg->val, reg->size);
+
+	return ret;
+}
+
+int avt_core_ops_s_register(struct v4l2_subdev *sd, const struct v4l2_dbg_register *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	dev_info(&client->dev, "%s[%d]: reg 0x%04llX, size %u",
+			 __func__, __LINE__, reg->reg, reg->size);
+
+	return 0;
+}
+
+static int avt_core_ops_subscribe_event(struct v4l2_subdev *sd, struct v4l2_fh *fh,
+										 struct v4l2_event_subscription *sub)
+{
+	avt_dbg(sd, "event type %u", sub->type);
+
+	switch (sub->type)
+	{
+	case V4L2_EVENT_SOURCE_CHANGE:
+		return v4l2_src_change_event_subdev_subscribe(sd, fh, sub);
+	case V4L2_EVENT_CTRL:
+		return v4l2_ctrl_subdev_subscribe_event(sd, fh, sub);
+	default:
+		return -EINVAL;
+	}
+}
+
+static const struct v4l2_subdev_core_ops avt_core_ops = {
+	.s_power = avt_core_ops_s_power,
+	.log_status = v4l2_ctrl_subdev_log_status,
+	.reset = avt_core_ops_reset,
+	.subscribe_event = avt_core_ops_subscribe_event,
+	.unsubscribe_event = v4l2_event_subdev_unsubscribe,
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.g_register = avt_core_ops_g_register,
+	.s_register = avt_core_ops_s_register,
+#endif
+};
+
+static int avt_subdev_internal_ops_close(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct avt_dev *camera = to_avt_dev(sd);
+	int ret = 0;
+
+	avt_dbg(sd, "camera->open_refcnt %d, camera->is_streaming %d",
+			camera->open_refcnt, camera->is_streaming);
+
+	// stop the stream if just streaming
+	if (camera->is_streaming)
+	{
+		avt_err(sd, "camera->is_streaming %d",
+				camera->is_streaming);
+		// ret = avt_video_ops_s_stream(sd, false);
+	}
+
+	camera->open_refcnt--;
+	return ret;
+}
+//TODO: Support multiple opens
+static int avt_subdev_internal_ops_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	// called when userspace app calls 'open'
+	struct avt_dev *camera = to_avt_dev(sd);
+
+	avt_dbg(sd, "camera->open_refcnt %d", camera->open_refcnt);
+
+	if (camera->open_refcnt)
+	{
+		avt_dbg(sd, "device already opened %d", camera->open_refcnt);
+		return -EBUSY;
+	}
+
+	if (!camera->is_streaming)
+	{
+		avt_dbg(sd, "force bcrm mode");
+		// set BCRM mode only when camera is not streaming
+		mutex_lock(&camera->lock);
+
+		avt_change_mode(camera, AVT_BCRM_MODE);
+
+		mutex_unlock(&camera->lock);
+	}
+
+	camera->open_refcnt++;
+
+	return 0;
+}
+
+static const struct v4l2_subdev_internal_ops avt_subdev_internal_ops = {
+	.open = avt_subdev_internal_ops_open,
+	.close = avt_subdev_internal_ops_close,
+};
+
+int avt_video_ops_querystd(struct v4l2_subdev *sd, v4l2_std_id *std)
+{
+	v4l2_dbg(2, debug, sd, "%s[%d]: %s",
+			 __func__, __LINE__, __FILE__);
+	return 0;
+}
+
+int v4l2_subdev_video_ops_s_mbus_config(struct v4l2_subdev *sd,
+										const struct v4l2_mbus_config *cfg)
+{
+	v4l2_dbg(2, debug, sd, "%s[%d]: %s", __func__, __LINE__, __FILE__);
+	return 0;
+}
+
+int avt_video_ops_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parm)
+{
+	struct avt_dev *camera = to_avt_dev(sd);
+	dev_info(&camera->i2c_client->dev, "%s[%d]: %s", __func__, __LINE__, __FILE__);
+
+	if (!parm)
+		return -EINVAL;
+
+	v4l2_dbg(2, debug, sd, "%s[%d]: parm->type %d", __func__, __LINE__, parm->type);
+
+	if (!V4L2_TYPE_IS_CAPTURE(parm->type))
+	{
+		return -EINVAL;
+	}
+
+	memcpy(&parm->parm.capture, &camera->streamcap, sizeof(struct v4l2_captureparm));
+
+	parm->parm.capture.capability = V4L2_CAP_TIMEPERFRAME | V4L2_MODE_HIGHQUALITY;
+	parm->parm.capture.timeperframe = camera->frame_interval;
+	/* return latest format as has been set by avt_video_ops_g_parm */
+
+	return 0;
+}
+
+int avt_video_ops_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parm)
+{
+	struct avt_dev *camera = to_avt_dev(sd);
+	struct v4l2_fract *timeperframe = &parm->parm.capture.timeperframe;
+
+	v4l2_dbg(2, debug, sd, "%s[%d]: %s", __func__, __LINE__, __FILE__);
+
+	// TODO: parameter checking!!!
+	if (!V4L2_TYPE_IS_CAPTURE(parm->type))
+	{
+		dev_info(&camera->i2c_client->dev, "%s[%d]: wrong parm->type %d",
+				 __func__, __LINE__, parm->type);
+		return -EINVAL;
+	}
+
+	// TODO: parameter checking!!!!!!
+	if ((timeperframe->numerator == 0) ||
+		(timeperframe->denominator == 0))
+	{
+		timeperframe->denominator = 30; // DEFAULT_FPS;
+		timeperframe->numerator = 1;
+	}
+
+	/* Copy new settings to internal structure */
+	memcpy(&camera->streamcap, &parm->parm.capture, sizeof(struct v4l2_captureparm));
+
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops avt_video_ops = {
+	.g_frame_interval = avt_video_ops_g_frame_interval,
+	.s_frame_interval = avt_video_ops_s_frame_interval,
+	.s_stream = avt_video_ops_s_stream,
+	.querystd = avt_video_ops_querystd,
+#if !defined(CONFIG_ARCH_ZYNQMP) && !defined(DISABLE_PARM)
+	.g_parm = avt_video_ops_g_parm,
+	.s_parm = avt_video_ops_s_parm,
+#endif
+#if ((LINUX_VERSION_CODE) < (KERNEL_VERSION(5, 6, 0)))
+	.g_mbus_config = v4l2_subdev_video_ops_g_mbus_config,
+	.s_mbus_config = v4l2_subdev_video_ops_s_mbus_config,
+#endif
+};
+
+static void avt_get_compose(struct avt_dev *camera,
+		   struct v4l2_subdev_state *sd_state,
+		   struct v4l2_subdev_selection *sel)
+{
+	const struct v4l2_mbus_framefmt *frmfmt;
+
+	if (sel->which == V4L2_SUBDEV_FORMAT_TRY)
+		frmfmt = v4l2_subdev_get_try_format(get_sd(camera),sd_state,
+						    sel->pad);
+	else
+		frmfmt = &camera->mbus_framefmt;
+
+	sel->r.left = 0;
+	sel->r.top = 0;
+	sel->r.width = frmfmt->width;
+	sel->r.height = frmfmt->height;
+}
+
+static void avt_get_crop(struct avt_dev * camera,
+		   struct v4l2_subdev_state *sd_state,
+		   struct v4l2_subdev_selection *sel)
+{
+	const struct v4l2_rect *rect;
+
+	dev_info(&camera->i2c_client->dev, "%s[%d]: %s",
+		 __func__, __LINE__, __FILE__);
+
+	if (sel->which == V4L2_SUBDEV_FORMAT_TRY)
+		rect = v4l2_subdev_get_try_crop(get_sd(camera),sd_state,sel->pad);
+	else
+		rect = &camera->curr_rect;
+
+	dev_info(&camera->i2c_client->dev,"%ux%u",rect->width,rect->height);
+
+	sel->r = *rect;
+}
+
+int avt_pad_ops_get_selection(struct v4l2_subdev *sd,
+			       struct v4l2_subdev_state *sd_state,
+			       struct v4l2_subdev_selection *sel)
+{
+	struct avt_dev *camera = to_avt_dev(sd);
+	struct i2c_client *client = camera->i2c_client;
+
+	dev_info(&client->dev, "%s[%d]: %s",
+			 __func__, __LINE__, __FILE__);
+
+	if (sel->pad > 0)
+		return -EINVAL;
+
+	//No cropping or binning in genicam for csi2 mode
+	if (camera->mbus_framefmt.code == MEDIA_BUS_FMT_CUSTOM)
+		return -ENODATA;
+
+	switch (sel->target)
+	{
+	/* Composing bounds */
+	case V4L2_SEL_TGT_COMPOSE_BOUNDS:
+	/* Default composing area */
+	case V4L2_SEL_TGT_COMPOSE_DEFAULT:
+		v4l2_rect_set_size_to(&sel->r,&camera->curr_rect);
+		break;
+	/* Current composing area */
+	case V4L2_SEL_TGT_COMPOSE:
+		avt_get_compose(camera,sd_state,sel);
+		break;
+
+	/* Current cropping area */
+	case V4L2_SEL_TGT_CROP:
+		avt_get_crop(camera,sd_state,sel);
+		break;
+
+	/* Cropping bounds */
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+	/* Default cropping area */
+	case V4L2_SEL_TGT_CROP_DEFAULT:
+		sel->r = camera->max_rect;
+		break;
+	/* Native frame size */
+	case V4L2_SEL_TGT_NATIVE_SIZE:
+		sel->r = camera->sensor_rect;
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int avt_set_compose(struct avt_dev *camera,
+			    struct v4l2_subdev_state *sd_state,
+			    struct v4l2_subdev_selection *sel)
+{
+	int ret = 0;
+	struct v4l2_mbus_framefmt *frmfmt;
+	const struct avt_binning_info *info;
+	const struct v4l2_rect *crop;
+
+	if (sel->which  == V4L2_SUBDEV_FORMAT_TRY) {
+		frmfmt = v4l2_subdev_get_try_format(get_sd(camera), sd_state, sel->pad);
+		crop = v4l2_subdev_get_try_crop(get_sd(camera), sd_state, sel->pad);
+	} else {
+		frmfmt = &camera->mbus_framefmt;
+		crop = &camera->curr_rect;
+	}
+
+	sel->r.left = 0;
+	sel->r.top = 0;
+
+	avt_calc_compose(camera,crop,&sel->r.width,&sel->r.height,&info);
+
+	if (sel->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		ret = avt_update_format(camera, crop, info);
+		if (ret < 0)
+			goto exit;
+	}
+
+	frmfmt->width = sel->r.width;
+	frmfmt->height = sel->r.height;
+
+exit:
+	return ret;
+}
+
+static int avt_set_crop(struct avt_dev *camera,
+			 struct v4l2_subdev_state *sd_state,
+			 struct v4l2_subdev_selection *sel)
+{
+	int ret = 0;
+	const struct v4l2_rect *min = &camera->min_rect;
+	const struct v4l2_rect *max = &camera->max_rect;
+	struct v4l2_rect *crop;
+	struct v4l2_mbus_framefmt *frmfmt;
+	const struct avt_binning_info *info;
+	u32 width = max->width,height = max->height;
+
+	if (sel->which  == V4L2_SUBDEV_FORMAT_TRY) {
+		crop = v4l2_subdev_get_try_crop(get_sd(camera), sd_state, sel->pad);
+		frmfmt = v4l2_subdev_get_try_format(get_sd(camera), sd_state, sel->pad);
+	} else {
+		crop = &camera->curr_rect;
+		frmfmt = &camera->mbus_framefmt;
+	}
+
+	v4l_bound_align_image(&sel->r.width,min->width, max->width,3,
+			      &sel->r.height,min->height,max->height,3,0);
+
+	v4l2_rect_map_inside(&sel->r, max);
+
+	avt_calc_compose(camera,&sel->r,&width,&height,&info);
+
+	if (sel->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		ret = avt_update_format(camera, &sel->r, info);
+		if (ret < 0)
+			goto exit;
+	}
+
+	frmfmt->width = width;
+	frmfmt->height = height;
+
+	*crop = sel->r;
+
+exit:
+	return ret;
+}
+
+int avt_pad_ops_set_selection(struct v4l2_subdev *sd,
+	struct v4l2_subdev_state *sd_state,
+	struct v4l2_subdev_selection *sel)
+{
+	struct avt_dev *camera = to_avt_dev(sd);
+	int ret = -EINVAL;
+
+
+	if (camera->is_streaming && sel->which == V4L2_SUBDEV_FORMAT_ACTIVE)
+		return -EBUSY;
+
+	if (sel->pad > 0)
+		return -EINVAL;
+
+	//No cropping or binning in genicam for csi2 mode
+	if (camera->mbus_framefmt.code == MEDIA_BUS_FMT_CUSTOM)
+		return -EINVAL;
+
+	mutex_lock(&camera->lock);
+
+	if (sel->target == V4L2_SEL_TGT_CROP)
+		ret = avt_set_crop(camera,sd_state, sel);
+	else if (sel->target == V4L2_SEL_TGT_COMPOSE)
+		ret = avt_set_compose(camera,sd_state,sel);
+
+	mutex_unlock(&camera->lock);
+
+	return ret;
+}
+
+int avt_pad_ops_get_frame_desc(struct v4l2_subdev *sd, unsigned int pad,
+								struct v4l2_mbus_frame_desc *fd)
+{
+	struct avt_dev *camera = to_avt_dev(sd);
+	struct i2c_client *client = camera->i2c_client;
+
+	dev_info(&client->dev, "%s[%d]: %s",
+			 __func__, __LINE__, __FILE__);
+	return 0;
+}
+
+int avt_pad_ops_set_frame_desc(struct v4l2_subdev *sd, unsigned int pad,
+								struct v4l2_mbus_frame_desc *fd)
+{
+
+	struct avt_dev *camera = to_avt_dev(sd);
+	struct i2c_client *client = camera->i2c_client;
+
+	dev_info(&client->dev, "%s[%d]: %s",
+			 __func__, __LINE__, __FILE__);
+	return 0;
+}
+#ifdef CONFIG_MEDIA_CONTROLLER
+int avt_pad_ops_link_validate(struct v4l2_subdev *sd, struct media_link *link,
+							   struct v4l2_subdev_format *source_fmt,
+							   struct v4l2_subdev_format *sink_fmt)
+{
+
+	v4l2_dbg(2, debug, sd, "%s[%d]: %s",
+			 __func__, __LINE__, __FILE__);
+	return 0;
+}
+#endif /* CONFIG_MEDIA_CONTROLLER */
+
+static const struct v4l2_subdev_pad_ops avt_pad_ops = {
+	.enum_mbus_code = avt_pad_ops_enum_mbus_code,
+	.enum_frame_size = avt_pad_ops_enum_frame_size,
+	.enum_frame_interval = avt_pad_ops_enum_frame_interval,
+	.get_fmt = avt_pad_ops_get_fmt,
+	.set_fmt = avt_pad_ops_set_fmt,
+	.get_selection = avt_pad_ops_get_selection,
+	.set_selection = avt_pad_ops_set_selection,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 6, 0))
+	.g_mbus_config = v4l2_subdev_video_ops_g_mbus_config,
+	.s_mbus_config = v4l2_subdev_video_ops_s_mbus_config,
+#endif
+	.get_frame_desc = avt_pad_ops_get_frame_desc,
+	.set_frame_desc = avt_pad_ops_set_frame_desc,
+#ifdef CONFIG_MEDIA_CONTROLLER
+	.link_validate = avt_pad_ops_link_validate,
+#endif /* CONFIG_MEDIA_CONTROLLER */
+};
+static const struct v4l2_subdev_ops avt_subdev_ops = {
+	.core = &avt_core_ops,
+	.video = &avt_video_ops,
+	.pad = &avt_pad_ops,
+};
+
+static int avt_meo_link_setup(struct media_entity *entity,
+							   const struct media_pad *local,
+							   const struct media_pad *remote, u32 flags)
+{
+	pr_info("%s[%d]", __func__, __LINE__);
+
+	return 0;
+}
+
+int avt_meo_get_fwnode_pad(struct fwnode_endpoint *endpoint)
+{
+	pr_info("%s[%d]", __func__, __LINE__);
+
+	return 0;
+}
+
+int avt_meo_link_validate(struct media_link *link)
+{
+	pr_info("%s[%d]", __func__, __LINE__);
+
+	return 0;
+}
+
+static const struct media_entity_operations avt_sd_media_ops = {
+	.link_setup = avt_meo_link_setup,
+};
+
+
+static int avt_get_sensor_capabilities(struct v4l2_subdev *sd)
+{
+	struct avt_dev *camera = to_avt_dev(sd);
+	struct i2c_client *client = camera->i2c_client;
+
+	int ret = 0;
+	u64 value64;
+	u8 avt_supported_lane_mask = 0;
+	u32 avt_current_clk = 0;
+	u32 clk;
+	u8 bcm_mode = 0;
+	u32 temp;
+
+	/* reading the Feature inquiry register */
+	ret = bcrm_read64(camera, BCRM_FEATURE_INQUIRY_64R,
+		&camera->feature_inquiry_reg.value);
+
+	if (ret < 0)
+	{
+		avt_err(sd, "regmap_bulk_read BCRM_FEATURE_INQUIRY_64R failed (%d)\n", ret);
+		return ret;
+	}
+	avt_dbg(sd, "BCRM_FEATURE_INQUIRY_64R %llu\n", camera->feature_inquiry_reg.value);
+
+	/* Check if requested number of lanes is supported */
+	ret = bcrm_read8(camera, BCRM_SUPPORTED_CSI2_LANE_COUNTS_8R,
+		&avt_supported_lane_mask);
+
+	if (ret < 0)
+	{
+		avt_dbg(sd, "regmap_read failed (%d)\n", ret);
+		return ret;
+	}
+
+	camera->lane_capabilities.value = avt_supported_lane_mask;
+
+	avt_dbg(sd, "supported lane config: %x", (uint32_t)avt_supported_lane_mask);
+
+	if (!(test_bit(camera->v4l2_fwnode_ep.bus.mipi_csi2.num_data_lanes - 1, (const long *)(&avt_supported_lane_mask))))
+	{
+		avt_err(sd, "requested number of lanes (%u) not supported by this camera!\n",
+				camera->v4l2_fwnode_ep.bus.mipi_csi2.num_data_lanes);
+		return -EINVAL;
+	}
+
+	avt_dbg(sd, "request %u lanes.\n", camera->v4l2_fwnode_ep.bus.mipi_csi2.num_data_lanes);
+
+	/* Set number of lanes */
+	ret = bcrm_write8(camera, BCRM_CSI2_LANE_COUNT_8RW,
+		camera->v4l2_fwnode_ep.bus.mipi_csi2.num_data_lanes);
+
+	if (ret < 0)
+	{
+		avt_err(sd, "bcrm_write8 failed (%d)\n", ret);
+		return ret;
+	}
+
+
+	ret = bcrm_read32(camera, BCRM_CSI2_CLOCK_MIN_32R, &camera->avt_min_clk);
+	if (ret < 0)
+	{
+		avt_err(sd, "regmap_read failed (%d)\n", ret);
+		return ret;
+	}
+
+	ret = bcrm_read32(camera, BCRM_CSI2_CLOCK_MAX_32R, &camera->avt_max_clk);
+	if (ret < 0)
+	{
+		avt_err(sd, "regmap_read failed (%d)\n", ret);
+		return ret;
+	}
+
+	avt_info(sd, "csi clocks\n"
+				 "   camera range:           %9d:%9d Hz\n"
+				 "   dts nr_of_link_frequencies %d\n"
+				 "   dts link_frequencies[0] %9lld Hz\n",
+			 camera->avt_min_clk, camera->avt_max_clk,
+			 camera->v4l2_fwnode_ep.nr_of_link_frequencies,
+			 camera->v4l2_fwnode_ep.link_frequencies[0]);
+
+	if (camera->v4l2_fwnode_ep.link_frequencies[0] < camera->avt_min_clk ||
+		camera->v4l2_fwnode_ep.link_frequencies[0] > camera->avt_max_clk)
+	{
+
+		avt_err(sd, "unsupported csi clock frequency (%lld Hz, range: %d:%d Hz)!\n",
+				camera->v4l2_fwnode_ep.link_frequencies[0],
+				camera->avt_min_clk,
+				camera->avt_max_clk);
+		return -EINVAL;
+	}
+
+	clk = camera->v4l2_fwnode_ep.link_frequencies[0];
+
+	ret = bcrm_write32(camera, BCRM_CSI2_CLOCK_32RW, clk);
+	if (ret < 0)
+	{
+		avt_err(sd, "regmap_write BCRM_CSI2_CLOCK_32RW failed (%d)\n", ret);
+		return ret;
+	}
+
+	ret = bcrm_read32(camera, BCRM_CSI2_CLOCK_32RW, &avt_current_clk);
+	if (ret < 0)
+	{
+		avt_err(sd, "regmap_read BCRM_CSI2_CLOCK_32RW failed (%d)\n", ret);
+		return ret;
+	}
+
+	avt_dbg(sd, "csi clock frequency (req: %lld Hz, cur: %d Hz, range: %d:%d Hz)!\n",
+			camera->v4l2_fwnode_ep.link_frequencies[0],
+			avt_current_clk,
+			camera->avt_min_clk,
+			camera->avt_max_clk);
+
+	avt_info(sd, "csi clock read from camera: %u Hz\n", avt_current_clk);
+
+	camera->min_rect.left = camera->min_rect.top = 0;
+
+	avt_info(sd, "get minimal and maximal resolutions");
+
+	ret = bcrm_read32(camera, BCRM_IMG_WIDTH_MIN_32R, &camera->min_rect.width);
+	if (ret < 0)
+	{
+		avt_err(sd, "regmap_read failed (%d)\n", ret);
+		// goto err_out;
+	}
+	avt_dbg(sd, "BCRM_IMG_WIDTH_MIN_32R %u", camera->min_rect.width);
+
+	ret = bcrm_read32(camera, BCRM_IMG_WIDTH_MAX_32R, &camera->max_rect.width);
+	if (ret < 0)
+	{
+		avt_err(sd, "regmap_read failed (%d)\n", ret);
+		// goto err_out;
+	}
+	avt_dbg(sd, "BCRM_IMG_WIDTH_MAX_32R %u", camera->max_rect.width);
+
+	camera->max_rect.left = camera->max_rect.top = 0;
+
+	ret = bcrm_read32(camera, BCRM_IMG_HEIGHT_MIN_32R, &camera->min_rect.height);
+	if (ret < 0)
+	{
+		avt_err(sd, "regmap_read failed (%d)", ret);
+		// goto err_out;
+	}
+	avt_dbg(sd, "BCRM_IMG_HEIGHT_MIN_32R %u", camera->min_rect.height);
+
+	ret = bcrm_read32(camera, BCRM_IMG_HEIGHT_MAX_32R, &camera->max_rect.height);
+	if (ret < 0)
+	{
+		avt_err(sd, "regmap_read failed (%d)", ret);
+		// goto err_out;
+	}
+
+	ret = device_property_read_u32(&camera->i2c_client->dev,"avt,max-width",
+				 &temp);
+
+	if (ret == 0)
+	{
+		if (camera->max_rect.width > temp)
+			camera->max_rect.width = temp;
+	}
+
+	ret = device_property_read_u32(&camera->i2c_client->dev,"avt,max-height",
+				 &temp);
+	if (ret == 0)
+	{
+		if (camera->max_rect.height > temp)
+			camera->max_rect.height = temp;
+	}
+
+	avt_dbg(sd, "BCRM_IMG_HEIGHT_MAX_32R %u", camera->max_rect.height);
+
+	ret = bcrm_read64(camera, BCRM_GAIN_MIN_64R, &value64);
+
+	if (ret < 0)
+	{
+		dev_err(&client->dev, "regmap_read failed (%d)\n", ret);
+		// goto err_out;
+	}
+	avt_dbg(sd, "BCRM_GAIN_MIN_64R %llu", value64);
+
+	ret = bcrm_read64(camera, BCRM_GAIN_MAX_64R, &value64);
+
+	if (ret < 0)
+	{
+		avt_err(sd, "regmap_read failed (%d)", ret);
+		// goto err_out;
+	}
+	avt_dbg(sd, "BCRM_GAIN_MAX_64R %llu", value64);
+
+	ret = bcrm_read32(camera,BCRM_SENSOR_WIDTH_32R,
+			  &camera->sensor_rect.width);
+
+	if (ret < 0)
+		return ret;
+
+	ret = bcrm_read32(camera,BCRM_SENSOR_HEIGHT_32R,
+			  &camera->sensor_rect.height);
+
+	if (ret < 0)
+		return ret;
+
+	camera->sensor_rect.left = 0;
+	camera->sensor_rect.top = 0;
+
+	camera->curr_rect = camera->max_rect;
+	camera->curr_rect.left = 0;
+	camera->curr_rect.top = 0;
+
+	ret = avt_write(camera, GENCP_CHANGEMODE_8W, bcm_mode, AV_CAM_DATA_SIZE_8);
+
+	if (ret < 0)
+	{
+		avt_err(sd, "Failed to set BCM mode: i2c write failed (%d)\n", ret);
+		return ret;
+	}
+	camera->mode = AVT_BCRM_MODE;
+
+	return 0;
+}
+
+static int avt_csi2_check_mipicfg(struct avt_dev *camera)
+{
+	struct i2c_client *client = camera->i2c_client;
+	int ret = -EINVAL;
+	int i;
+
+	camera->v4l2_fwnode_ep.bus_type = V4L2_MBUS_CSI2_DPHY;
+
+	camera->endpoint = fwnode_graph_get_next_endpoint(dev_fwnode(&client->dev), NULL);
+	if (!camera->endpoint)
+	{
+		dev_err(&client->dev, "endpoint node not found\n");
+		return -EINVAL;
+	}
+
+	if (v4l2_fwnode_endpoint_alloc_parse(camera->endpoint, &camera->v4l2_fwnode_ep))
+	{
+		dev_err(&client->dev, "could not parse endpoint\n");
+		goto error_out;
+	}
+
+	/* Check the number of MIPI CSI2 data lanes */
+	if (camera->v4l2_fwnode_ep.bus.mipi_csi2.num_data_lanes > 4)
+	{
+		dev_err(&client->dev, "%s[%d]: more than 4 data lanes are currently not supported\n",
+				__func__, __LINE__);
+		goto error_out;
+	}
+
+	dev_info(&client->dev, "%s[%d]: ep_cfg.bus.mipi_csi2.num_data_lanes % d\n",
+			 __func__, __LINE__, camera->v4l2_fwnode_ep.bus.mipi_csi2.num_data_lanes);
+	dev_info(&client->dev, "%s[%d]: v4l2_fwnode_ep.nr_of_link_frequencies %d",
+			 __func__, __LINE__,
+			 camera->v4l2_fwnode_ep.nr_of_link_frequencies);
+
+	for (i = 0; i < camera->v4l2_fwnode_ep.nr_of_link_frequencies; i++)
+		dev_info(&client->dev, "%s[%d]: v4l2_fwnode_ep.link-frequencies %u value %llu\n", __func__, __LINE__, i,
+				 camera->v4l2_fwnode_ep.link_frequencies[i]);
+
+	/* Check the link frequency set in device tree */
+	if (1 > camera->v4l2_fwnode_ep.nr_of_link_frequencies)
+	{
+		dev_err(&client->dev, "%s[%d]: link-frequency property not found in DT\n", __func__, __LINE__);
+		goto error_out;
+	}
+
+	ret = 0;
+	return ret;
+
+error_out:
+	dev_err(&client->dev, "%s[%d]: camera->v4l2_fwnode_ep invalid from now on!!", __func__, __LINE__);
+	v4l2_fwnode_endpoint_free(&camera->v4l2_fwnode_ep);
+	fwnode_handle_put(camera->endpoint);
+
+	return ret;
+}
+
+
+static int avt_query_binning(struct avt_dev *camera)
+{
+	int ret,i,j;
+	int type_idx[AVT_BINNING_TYPE_CNT];
+	u16 binning_inq;
+	u32 width_inc,height_inc;
+	const struct v4l2_rect *sensor_rect = &camera->sensor_rect;
+
+	ret = bcrm_read16(camera,BCRM_BINNING_INQ_16R,&binning_inq);
+
+	if (ret < 0)
+		return ret;
+
+	// In the firmware version without sensor binning the byteorder of the
+	// inquiry register is swapped.
+	// If the digital binning fields are zero and the bits outside the
+	// allowed range are set, then the byteorder will be swapped.
+	if ((binning_inq & 0x7f) == 0 && (binning_inq & 0xffe) != 0) {
+		__swab16s(&binning_inq);
+	}
+
+	dev_dbg(&camera->i2c_client->dev,"Binning inq 0x%x\n",binning_inq);
+
+	ret = bcrm_read32(camera,BCRM_IMG_WIDTH_INC_32R,&width_inc);
+
+	if (ret < 0)
+		return ret;
+
+	width_inc = ilog2(width_inc);
+
+	ret = bcrm_read32(camera,BCRM_IMG_HEIGHT_INC_32R,&height_inc);
+
+	if (ret < 0)
+		return ret;
+
+	height_inc = ilog2(height_inc);
+
+	for (i = 0;i < avt_binning_setting_cnt;i++) {
+		const struct avt_binning_setting *setting =
+			&avt_binning_settings[i];
+
+		if (setting->inq == -1 || binning_inq & (1 << setting->inq)) {
+			if (setting->type == NONE) {
+				for (j = 0;j < AVT_BINNING_TYPE_CNT;j++)
+					camera->binning_info_cnt[j]++;
+			} else {
+				camera->binning_info_cnt[setting->type]++;
+			}
+		}
+	}
+
+	for (i = 0;i < AVT_BINNING_TYPE_CNT;i++) {
+		camera->binning_infos[i] = kcalloc(camera->binning_info_cnt[i],
+			sizeof(struct avt_binning_info),GFP_KERNEL);
+	}
+
+	memset(type_idx,0,sizeof(type_idx[0]) * AVT_BINNING_TYPE_CNT);
+	for (i = 0;i < avt_binning_setting_cnt;i++) {
+		const struct avt_binning_setting *setting = &avt_binning_settings[i];
+		if (setting->inq == -1 || binning_inq & (1<<setting->inq)) {
+			struct avt_binning_info info = {0};
+
+			info.vfact = setting->vfact;
+			info.hfact = setting->hfact;
+			info.sel = setting->sel;
+
+			info.max_width = sensor_rect->width / setting->hfact;
+			info.max_height = sensor_rect->height / setting->vfact;
+
+			v4l_bound_align_image(&info.max_width,0,
+					      info.max_width,3,
+					      &info.max_height,0,
+					      info.max_height,3,0);
+
+
+			if (setting->type == NONE) {
+				int l;
+				for (l = 0; l < AVT_BINNING_TYPE_CNT; l++) {
+					const int idx = type_idx[l]++;
+
+					dev_dbg(&camera->i2c_client->dev,
+						"Binning setting %dx%d: width %u "
+						"height %u type: %s\n",
+						setting->hfact,setting->vfact,
+						info.max_width,info.max_height,
+						binning_type_str[l]);
+
+					info.type = l;
+					camera->binning_infos[l][idx] = info;
+				}
+			} else {
+				const u32 type = setting->type;
+				const int idx = type_idx[type]++;
+
+
+				dev_dbg(&camera->i2c_client->dev,
+					"Binning setting %dx%d: width %u "
+					"height %u type: %s\n",
+					setting->hfact,setting->vfact,
+					info.max_width,info.max_height,
+					binning_type_str[type]);
+
+				info.type = type;
+				camera->binning_infos[type][idx] = info;
+			}
+
+
+		}
+	}
+
+
+	camera->curr_binning_info = &camera->binning_infos[0][0];
+
+	return 0;
+}
+
+
+
+static const struct regmap_config alvium_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 8,
+	.reg_stride = 1,
+	.max_register = 0xffff,
+	.reg_format_endian = REGMAP_ENDIAN_BIG,
+	.val_format_endian = REGMAP_ENDIAN_BIG,
+	.name = "alvium_regmap",
+	.cache_type = REGCACHE_NONE,
+};
+
+
+static int prepare_write_handshake(struct avt_dev *camera)
+{
+	int ret;
+	u8 handshake_val;
+
+	ret = bcrm_read8(camera,BCRM_WRITE_HANDSHAKE_8RW,&handshake_val);
+
+	if (ret < 0)
+	{
+		dev_err(&camera->i2c_client->dev,
+			"%s[%d]: Reading handshake value failed with: %d\n",
+			__func__, __LINE__,ret);
+		return ret;
+	}
+
+	if ((handshake_val & BCRM_HANDSHAKE_STATUS_MASK) != 0)
+	{
+		dev_warn(&camera->i2c_client->dev,
+			 "%s[%d]: Write handshake still in progress",
+			 __func__, __LINE__);
+	}
+
+	/* reset only handshake status */
+	ret = avt_write(camera, get_bcrm_addr(camera, BCRM_WRITE_HANDSHAKE_8RW),
+		handshake_val & ~BCRM_HANDSHAKE_STATUS_MASK, 1);
+
+	if (ret < 0)
+	{
+		dev_err(&camera->i2c_client->dev,"%s[%d]: Clearing handshake status failed with: %d\n",__func__, __LINE__,ret);
+		return ret;
+	}
+
+
+	/* wait for bcrm handshake */
+	reinit_completion(&camera->bcrm_wrhs_completion);
+
+	if (!queue_work(camera->bcrm_wrhs_queue, &camera->bcrm_wrhs_work))
+	{
+		dev_err(&camera->i2c_client->dev,
+			"Write handshake already in progress!");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int wait_for_write_handshake(struct avt_dev *camera)
+{
+	ulong ret;
+
+	ret = wait_for_completion_timeout(&camera->bcrm_wrhs_completion,
+					  msecs_to_jiffies(camera->bcrm_handshake_timeout_ms));
+
+	// If wait_for_completion_timeout returns a positive value, then the handshake was successfully
+	// and ret contains the remaining time before the timeout would occur
+	if (ret > 0)
+	{
+		return 0;
+	}
+
+	atomic_set(&camera->bcrm_wrhs_enabled,0);
+	flush_work(&camera->bcrm_wrhs_work);
+
+	dev_err(&camera->i2c_client->dev,
+		"%s[%d]: Write handshake timeout\n",
+		__func__, __LINE__);
+
+	return -EIO;
+}
+
+static int bcrm_write(struct avt_dev *camera, u16 reg, u64 val, size_t len)
+{
+	struct device *dev = &camera->i2c_client->dev;
+	int ret;
+
+	WARN_ON(camera->mode != AVT_BCRM_MODE);
+
+	ret = prepare_write_handshake(camera);
+
+	if (ret < 0)
+		return ret;
+
+	ret = avt_write(camera, get_bcrm_addr(camera, reg), val, len);
+
+	if (ret < 0)
+	{
+		dev_err(dev,"%s[%d]: Writing value failed with: %d\n",__func__, __LINE__,ret);
+		return ret;
+	}
+
+	if (!camera->bcrm_write_handshake)
+	{
+		dev_info(dev,
+				 "%s[%d]: bcrm_write_handshake not supported. Use msleep(%u) at as fallback.",
+				 __func__, __LINE__, camera->bcrm_handshake_timeout_ms);
+		/* Handshake not supported. Use static sleep at least once as fallback */
+		msleep(camera->bcrm_handshake_timeout_ms);
+	}
+
+	return wait_for_write_handshake(camera);
+}
+
+static void bcrm_wrhs_work_func(struct work_struct *work)
+{
+	u8 handshake_val = 0;
+	static const int poll_interval_ms = 5;
+	int ret = 0;
+	int i = 0;
+
+	struct avt_dev *camera =
+		container_of(work, struct avt_dev, bcrm_wrhs_work);
+
+	atomic_set(&camera->bcrm_wrhs_enabled,1);
+
+	do
+	{
+		//TODO: Must we check the return value here ?
+		ret = bcrm_read8(camera, BCRM_WRITE_HANDSHAKE_8RW, &handshake_val);
+
+		if (handshake_val & BCRM_HANDSHAKE_STATUS_MASK)
+		{
+			//TODO: Must we check the return value here ?
+			ret = avt_write(camera,
+				get_bcrm_addr(camera, BCRM_WRITE_HANDSHAKE_8RW),
+				handshake_val & ~BCRM_HANDSHAKE_STATUS_MASK,
+				AV_CAM_DATA_SIZE_8);
+
+			complete(&camera->bcrm_wrhs_completion);
+
+			dev_dbg(&camera->i2c_client->dev, "%s[%d]: Handshake ok\n",
+						__func__, __LINE__);
+
+			break;
+		}
+		msleep(poll_interval_ms);
+		i++;
+	} while (atomic_read(&camera->bcrm_wrhs_enabled) != 0);
+
+	if (i == 300)
+		dev_info(&camera->i2c_client->dev, "%s[%d]: 0x%08llx current->pid 0x%08x %d\n",
+				 __func__, __LINE__, (u64)work, current->pid, i);
+}
+
+
+static int avt_detect(struct i2c_client *client)
+{
+	const u16 address = 0x0;
+	u32 value = 0;
+	int ret;
+	struct i2c_msg msgs[2] = {
+			{
+				.addr = client->addr,
+				.flags = 0,
+				.buf = (__u8*)&address,
+				.len = 2,
+			},
+			{
+				.addr = client->addr,
+				.flags = I2C_M_RD,
+				.buf = (__u8*)&value,
+				.len = 4,
+			},
+	};
+
+
+	ret = i2c_transfer(client->adapter, msgs, 2);
+
+	if (ret < 0)
+	{
+		return ret;
+	}
+
+	if (value == 0)
+	{
+		return -1;
+	}
+
+	return 0;
+}
+
+static ssize_t avt_i2c_xfer_read(struct file *filp, struct kobject *kobj,
+	struct bin_attribute *battr, char *buf, loff_t off, size_t len)
+{
+	struct avt_dev *camera = battr->private;
+	struct avt_i2c_xfer *xfer = &camera->next_fw_rd_transfer;
+	int ret = -EINVAL;
+
+	WARN_ON(off != 0);
+
+	mutex_lock(&camera->lock);
+
+	if (xfer->len == len) {
+		ret = avt_read_raw(camera, xfer->addr,
+			buf, xfer->len);
+
+		memset(xfer, 0, sizeof(*xfer));
+	}
+
+	mutex_unlock(&camera->lock);
+
+	return ret;
+}
+
+static ssize_t avt_i2c_xfer_write(struct file *filp, struct kobject *kobj,
+	struct bin_attribute *battr, char *buf, loff_t off, size_t len)
+{
+	const struct {
+		struct avt_i2c_xfer xfer;
+		u8 buf[];
+	} __packed *payload;
+	const struct avt_i2c_xfer *xfer;
+	struct avt_dev *camera = battr->private;
+	ssize_t ret = -EINVAL;
+
+	WARN_ON(off != 0);
+
+	if (len < sizeof(payload))
+		return -EINVAL;
+
+
+	payload = (typeof(payload))buf;
+	xfer = &payload->xfer;
+
+	if (xfer->len + sizeof(*xfer) > battr->size)
+		return -EINVAL;
+
+	mutex_lock(&camera->lock);
+
+	if (payload->xfer.rd) {
+		memcpy(&camera->next_fw_rd_transfer, xfer, sizeof(*xfer));
+
+		ret = 0;
+	} else {
+		if (xfer->len + sizeof(*xfer) != len)
+			goto out;
+
+		ret = avt_write_raw(camera, xfer->addr, payload->buf, xfer->len);
+		if (ret < 0)
+			goto out;
+
+		ret = xfer->len;
+	}
+
+out:
+	mutex_unlock(&camera->lock);
+
+	return ret;
+}
+
+static int avt_i2c_xfer_init(struct avt_dev *camera)
+{
+	struct device *dev = &camera->i2c_client->dev;
+	struct bin_attribute *i2c_xfer_attr;
+	int ret;
+
+	i2c_xfer_attr = devm_kzalloc(dev, sizeof(*i2c_xfer_attr), GFP_KERNEL);
+	if (!i2c_xfer_attr)
+		return -ENOMEM;
+
+	sysfs_bin_attr_init(i2c_xfer_attr);
+	i2c_xfer_attr->attr.name = "i2c_xfer";
+	i2c_xfer_attr->attr.mode = 0666; // Other read
+	i2c_xfer_attr->private = camera;
+	// TODO: Change to dynamic size
+	i2c_xfer_attr->size = sizeof(struct avt_i2c_xfer) + 1024;
+	i2c_xfer_attr->read = avt_i2c_xfer_read;
+	i2c_xfer_attr->write = avt_i2c_xfer_write;
+
+	ret = device_create_bin_file(dev, i2c_xfer_attr);
+	if (ret) {
+		devm_kfree(dev, i2c_xfer_attr);
+	} else {
+		camera->i2c_xfer_attr = i2c_xfer_attr;
+	}
+
+	return ret;
+}
+
+
+static ssize_t avt_mode_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct avt_dev *camera = client_to_avt_dev(client);
+
+	mutex_lock(&camera->lock);
+	if (camera->mode == AVT_GENCP_MODE)
+		sysfs_emit(buf, "%s\n","gencp");
+	else
+		sysfs_emit(buf, "%s\n", "bcm");
+
+	mutex_unlock(&camera->lock);
+
+	return strlen(buf);
+}
+
+
+static ssize_t avt_mode_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t len)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct avt_dev *camera = client_to_avt_dev(client);
+	u8 mode_req;
+	int ret;
+	const char *modestr = strim((char*)buf);
+
+	if (strcmp(modestr, "bcm") == 0) {
+		mode_req = 0;
+	} else if (strcmp(modestr, "gencp") == 0) {
+		mode_req = 1;
+	} else {
+		return -EINVAL;
+	}
+
+	mutex_lock(&camera->lock);
+
+	ret = avt_change_mode(camera, mode_req);
+	if (ret < 0)
+		goto out;
+
+	ret = len;
+out:
+	mutex_unlock(&camera->lock);
+
+	return ret;
+}
+
+static int avt_mode_attr_init(struct avt_dev *camera)
+{
+	struct device *dev = &camera->i2c_client->dev;
+	struct device_attribute *mode_attr;
+	int ret;
+
+	mode_attr = devm_kzalloc(dev, sizeof(*mode_attr), GFP_KERNEL);
+	if (!mode_attr)
+		return -ENOMEM;
+
+	sysfs_attr_init(&mode_attr->attr);
+	mode_attr->attr.name = "mode";
+	mode_attr->attr.mode = 0666;
+	mode_attr->show = avt_mode_show;
+	mode_attr->store = avt_mode_store;
+
+	ret = device_create_file(dev, mode_attr);
+	if (ret) {
+		devm_kfree(dev, mode_attr);
+	} else {
+		camera->mode_attr = mode_attr;
+	}
+
+	return ret;
+}
+
+
+static int avt_probe(struct i2c_client *client)
+{
+
+	struct device *dev = &client->dev;
+	struct avt_dev *camera;
+	struct v4l2_mbus_framefmt *fmt;
+	struct fwnode_handle *fwnode = dev_fwnode(dev);
+	struct v4l2_subdev *sd;
+	int ret;
+
+	dev_info(&client->dev, "%s[%d]: %s",
+			 __func__, __LINE__, __FILE__);
+
+	if (avt_detect(client) < 0)
+	{
+		dev_warn(&client->dev,"No camera detected!");
+		return -ENODEV;
+	}
+
+
+	camera = devm_kzalloc(dev, sizeof(*camera), GFP_KERNEL);
+	if (!camera)
+	{
+		return -ENOMEM;
+	}
+
+	camera->i2c_client = client;
+	camera->streamon_delay = 0;
+	camera->framerate_auto = true;
+
+	sd = get_sd(camera);
+
+	ret = fwnode_property_read_u32(fwnode,"streamon_delay",
+				       &camera->streamon_delay);
+	if (camera->streamon_delay)
+	{
+		dev_info(dev, "%s[%d]: use camera->streamon_delay of %u us\n", __func__, __LINE__, camera->streamon_delay);
+	}
+
+	camera->stream_start_phy_reset
+		= fwnode_property_present(fwnode,"phy_reset_on_start");
+
+	camera->force_reset_on_init = fwnode_property_present(dev_fwnode(&client->dev), "force_reset_on_init");
+	dev_dbg(dev, "%s[%d]: force_reset_on_init %d\n", __func__, __LINE__, camera->force_reset_on_init);
+
+	/* request optional power down pin */
+	camera->pwdn_gpio = devm_gpiod_get_optional(dev, "powerdown", camera->force_reset_on_init ? GPIOD_OUT_HIGH : GPIOD_ASIS);
+
+	if (NULL == camera->pwdn_gpio || IS_ERR(camera->pwdn_gpio))
+	{
+		dev_warn(&client->dev, "%s[%d]: no powerdown-gpios defined", __func__, __LINE__);
+	}
+	else
+	{
+		dev_info(dev, "%s[%d]: devm_gpiod_get_optional(dev, \"powerdown-gpios\" succeeded\n", __func__, __LINE__);
+		gpiod_set_value_cansleep(camera->pwdn_gpio, GPIOD_OUT_LOW);
+	}
+
+	/* request optional reset pin, only the first one will be used at the moment */
+	camera->reset_gpio = devm_gpiod_get_optional(dev, "reset", GPIOD_ASIS);
+	// GPIOD_OUT_LOW);
+	if (NULL == camera->reset_gpio || IS_ERR(camera->reset_gpio))
+	{
+		dev_warn(&client->dev, "%s[%d]: no reset-gpios defined", __func__, __LINE__);
+	}
+	else
+	{
+		dev_info(dev, "%s[%d]: devm_gpiod_get_optional(dev, \"reset-gpios\" succeeded\n", __func__, __LINE__);
+		gpiod_set_value_cansleep(camera->reset_gpio, GPIOD_OUT_LOW);
+	}
+
+	if (fwnode_property_present(dev_fwnode(&client->dev), "mipi_csi"))
+		dev_info(dev, "%s[%d]: fwnode_property_present mipi_csi\n", __func__, __LINE__);
+	else
+		dev_info(dev, "%s[%d]: fwnode_property_present failed to find mipi_csi\n", __func__, __LINE__);
+
+	camera->regmap = devm_regmap_init_i2c(client, &alvium_regmap_config);
+	if (IS_ERR(camera->regmap))
+	{
+		dev_err(dev, "%s[%d]: regmap init failed: %ld\n", __func__, __LINE__,
+				PTR_ERR(camera->regmap));
+		ret = -ENODEV;
+		goto err_exit;
+	}
+
+
+	ret = fwnode_property_read_u32(dev_fwnode(&client->dev),
+		"bcrm_wait_timeout", &camera->bcrm_handshake_timeout_ms);
+
+	if (ret)
+	{
+		dev_warn(dev, "%s[%d]: bcrm_wait_timeout not found, use default value\n", __func__, __LINE__);
+		camera->bcrm_handshake_timeout_ms = BCRM_WAIT_HANDSHAKE_TIMEOUT_MS;
+	}
+	dev_info(dev, "%s[%d]: bcrm_wait_timeout set to %dms\n", __func__, __LINE__, camera->bcrm_handshake_timeout_ms);
+
+	ret = avt_csi2_check_mipicfg(camera);
+	if (ret)
+	{
+		dev_err(dev, "%s[%d]: failed to parse endpoint\n", __func__, __LINE__);
+		ret = -EINVAL;
+		goto err_exit;
+	}
+
+	if (camera->v4l2_fwnode_ep.bus_type != V4L2_MBUS_CSI2_DPHY) {
+		dev_err(dev, "%s[%d]: invalid bus type %d specified\n",
+			__func__, __LINE__, camera->v4l2_fwnode_ep.bus_type);
+		ret = -EINVAL;
+		goto fwnode_cleanup;
+	}
+
+	/* request optional power down pin */
+	camera->pwdn_gpio = devm_gpiod_get_optional(dev, "powerdown",
+												GPIOD_OUT_HIGH);
+	if (NULL == camera->pwdn_gpio || IS_ERR(camera->pwdn_gpio))
+	{
+		dev_warn(&client->dev, "%s[%d]: no powerdown-gpios powerdown defined",
+				 __func__, __LINE__);
+		camera->pwdn_gpio = NULL;
+	}
+	else
+	{
+		dev_info(dev, "%s[%d]: devm_gpiod_get_optional(dev, \"powerdown-gpios\" succeeded\n", __func__, __LINE__);
+		gpiod_set_value(camera->pwdn_gpio, 0);
+	}
+
+	/* request optional reset pin, only the first one will be used at the moment */
+	camera->reset_gpio = devm_gpiod_get_optional(dev, "reset",
+												 GPIOD_OUT_HIGH);
+	if (NULL == camera->reset_gpio || IS_ERR(camera->reset_gpio))
+	{
+		dev_warn(&client->dev, "%s[%d]: no reset-gpios defined",
+				 __func__, __LINE__);
+		camera->reset_gpio = NULL;
+	}
+	else
+	{
+		dev_info(dev, "%s[%d]: devm_gpiod_get_optional(dev, \"reset-gpios\" succeeded\n", __func__, __LINE__);
+		gpiod_set_value(camera->reset_gpio, 0);
+	}
+
+#ifdef NVIDIA
+	camera->s_data.priv = camera;
+	camera->s_data.dev = &camera->i2c_client->dev;
+	camera->s_data.ctrl_handler = &camera->v4l2_ctrl_hdl;
+
+	ret = camera_common_initialize(&camera->s_data, "avt_csi2");
+
+	if (unlikely(ret)) {
+		goto fwnode_cleanup;
+	}
+#endif
+
+	/* now create the subdevice on i2c*/
+	v4l2_i2c_subdev_init(sd, client, &avt_subdev_ops);
+	sd->dev = &client->dev;
+	sd->internal_ops = &avt_subdev_internal_ops;
+	sd->flags |= V4L2_SUBDEV_FL_HAS_EVENTS | V4L2_SUBDEV_FL_HAS_DEVNODE;
+	camera->pad.flags = MEDIA_PAD_FL_SOURCE;
+	sd->entity.ops = &avt_sd_media_ops;
+	sd->entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	ret = media_entity_pads_init(&sd->entity, 1, &camera->pad);
+	if (ret < 0)
+		goto fwnode_cleanup;
+
+	mutex_init(&camera->lock);
+
+	{
+		enum avt_reset_type const reset_type = camera->force_reset_on_init ? RESET_TYPE_HARD : RESET_TYPE_SOFT;
+		if(reset_type == RESET_TYPE_HARD) {
+			avt_info(sd, "Hard reset requested by device tree");
+		}
+
+		ret = avt_reset(camera, reset_type);
+		if(ret < 0) {
+			avt_err(sd, "Camera reset failed");
+			goto fwnode_cleanup;
+		}
+	}
+
+	ret = read_cci_registers(client);
+
+	if (ret < 0)
+	{
+		dev_err(dev, "%s[%d]: read_cci_registers failed: %d\n",
+				__func__, __LINE__, ret);
+		goto entity_cleanup;
+	}
+	dev_info(dev, "%s[%d]: read_cci_registers succeeded\n", __func__, __LINE__);
+
+	ret = cci_version_check(client);
+	if (ret < 0)
+	{
+		dev_err(&client->dev, "%s[%d]: cci version mismatch - %d !\n",
+				__func__, __LINE__, ret);
+		goto entity_cleanup;
+	}
+
+	ret = bcrm_version_check(client);
+	if (ret < 0)
+	{
+		dev_err(&client->dev, "%s[%d]: bcrm version mismatch - %d !\n",
+				__func__, __LINE__, ret);
+		goto entity_cleanup;
+	}
+	dev_info(dev, "%s[%d]: bcrm_version_check succeeded\n", __func__, __LINE__);
+
+	camera->bcrm_write_handshake =
+		bcrm_get_write_handshake_availibility(client);
+
+
+	dev_info(dev,"Found camera %s %s",camera->cci_reg.reg.family_name,
+		 camera->cci_reg.reg.model_name);
+
+	/* reading the Firmware Version register */
+	ret = bcrm_read64(camera,BCRM_DEVICE_FIRMWARE_VERSION_64R,
+			  &camera->cam_firmware_version.value);
+
+	dev_info(&client->dev, "%s[%d]: Firmware version: %u.%u.%u.%x ret = %d\n",
+			 __func__, __LINE__,
+			 camera->cam_firmware_version.device_firmware.special_version,
+			 camera->cam_firmware_version.device_firmware.major_version,
+			 camera->cam_firmware_version.device_firmware.minor_version,
+			 camera->cam_firmware_version.device_firmware.patch_version,
+			 ret);
+
+	if (camera->cci_reg.reg.device_capabilities.caps.gencp)
+	{
+		ret = read_gencp_registers(client);
+		if (ret < 0)
+		{
+			dev_err(dev, "%s: read_gencp_registers failed: %d\n",
+					__func__, ret);
+			goto entity_cleanup;
+		}
+
+		ret = gcprm_version_check(client);
+		if (ret < 0)
+		{
+			dev_err(&client->dev, "gcprm version mismatch!\n");
+			goto free_ctrls;
+		}
+
+		dev_info(&client->dev, "correct gcprm version\n");
+	}
+
+	init_completion(&camera->bcrm_wrhs_completion);
+
+	camera->bcrm_wrhs_queue = create_singlethread_workqueue(sd->name);
+	if (!camera->bcrm_wrhs_queue)
+	{
+		dev_err(&client->dev, "%s[%d]: Could not create work queue\n", __func__, __LINE__);
+		ret = -ENOMEM;
+		goto fwnode_cleanup;
+	}
+
+	dev_info(&client->dev, "%s[%d]: INIT_WORK(&camera->bcrm_wrhs_work, bcrm_wrhs_work_func);\n", __func__, __LINE__);
+	INIT_WORK(&camera->bcrm_wrhs_work, bcrm_wrhs_work_func);
+	atomic_set(&camera->bcrm_wrhs_enabled,0);
+
+	CLEAR(camera->max_rect);
+	CLEAR(camera->min_rect);
+	CLEAR(camera->curr_rect);
+
+	ret = avt_get_sensor_capabilities(sd);
+	if (ret)
+		goto entity_cleanup;
+
+	ret = avt_query_binning(camera);
+	if (ret)
+		goto entity_cleanup;
+
+	ret = avt_get_fmt_available(client);
+
+	ret = avt_init_avail_formats(sd);
+	if (ret < 0)
+	{
+		dev_err(dev, "%s[%d]: avt_init_avail_formats failed with %d\n",
+				__func__, __LINE__, ret);
+		goto entity_cleanup;
+	}
+
+	sd->ctrl_handler = &camera->v4l2_ctrl_hdl;
+
+	fmt = &camera->mbus_framefmt;
+
+	ret = avt_init_current_format(camera, fmt);
+	if (ret)
+	{
+		goto entity_cleanup;
+	}
+
+	camera->streamcap.capability = V4L2_CAP_TIMEPERFRAME;
+	camera->streamcap.capturemode = V4L2_MODE_HIGHQUALITY;
+
+	// Init controls before registering the device, because the control handler must be fully initialized before
+	// the subdevice is registered.
+	ret = avt_init_controls(camera);
+	if (ret)
+	{
+		dev_err(dev, "%s[%d]: avt_init_controls failed with (%d)\n", __func__, __LINE__, ret);
+		goto entity_cleanup;
+	}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 19, 0))
+	ret = v4l2_subdev_init_finalize(sd);
+
+	if (ret) {
+		dev_err(dev, "Failed to finalize subdev init!");
+		goto free_ctrls;
+	}
+#endif
+
+	ret = v4l2_async_register_subdev(sd);
+
+	if (ret)
+	{
+		dev_err(dev, "%s[%d]: v4l2_async_register_subdev failed with (%d)\n", __func__, __LINE__, ret);
+		goto sd_cleanup;
+	}
+	dev_info(&client->dev, "camera %s registered\n", sd->name);
+
+	ret = device_add_group(dev, &avt_attr_grp);
+	dev_info(dev, " -> %s[%d]: sysfs group created! (%d)\n", __func__, __LINE__, ret);
+	if (ret)
+	{
+		dev_err(dev, "%s[%d]: Failed to create sysfs group (%d)\n", __func__, __LINE__, ret);
+		goto sd_cleanup;
+	}
+
+	ret = avt_mode_attr_init(camera);
+	if (ret) {
+		dev_err(dev, "Failed to create mode attribute!\n");
+		goto sysfs_cleanup;
+	}
+
+	ret = avt_i2c_xfer_init(camera);
+	if (ret) {
+		dev_err(dev, "Failed to create fw_transfer attribute!\n");
+		goto sysfs_cleanup;
+	}
+
+
+	ret = bcrm_write32(camera, BCRM_STREAM_ON_DELAY_32RW, camera->streamon_delay);
+
+	dev_info(&client->dev, "%s[%d]: probe success !\n", __func__, __LINE__);
+
+	return 0;
+
+sysfs_cleanup:
+	device_remove_group(dev, &avt_attr_grp);
+
+sd_cleanup:
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 19, 0))
+	v4l2_subdev_cleanup(sd);
+#endif
+
+free_ctrls:
+
+	v4l2_ctrl_handler_free(&camera->v4l2_ctrl_hdl);
+
+entity_cleanup:
+	media_entity_cleanup(&sd->entity);
+
+fwnode_cleanup:
+	if (camera->bcrm_wrhs_queue)
+		destroy_workqueue(camera->bcrm_wrhs_queue);
+	v4l2_fwnode_endpoint_free(&camera->v4l2_fwnode_ep);
+	fwnode_handle_put(camera->endpoint);
+
+err_exit:
+	if (camera->pwdn_gpio)
+		devm_gpiod_put(dev, camera->pwdn_gpio);
+	if (camera->reset_gpio)
+		devm_gpiod_put(dev, camera->reset_gpio);
+
+	mutex_destroy(&camera->lock);
+	return ret;
+}
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 1, 0))
+static int avt_remove(struct i2c_client *client)
+#else
+static void avt_remove(struct i2c_client *client)
+#endif
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct avt_dev *camera = to_avt_dev(sd);
+	struct device *dev = &client->dev;
+
+	avt_dbg(sd, "+");
+
+	v4l2_fwnode_endpoint_free(&camera->v4l2_fwnode_ep);
+	fwnode_handle_put(camera->endpoint);
+
+	device_remove_bin_file(dev, camera->i2c_xfer_attr);
+
+	device_remove_group(dev, &avt_attr_grp);
+	media_entity_cleanup(&sd->entity);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 19, 0))
+	v4l2_subdev_cleanup(sd);
+#endif
+
+	v4l2_ctrl_handler_free(&camera->v4l2_ctrl_hdl);
+
+#ifdef DPHY_RESET_WORKAROUND
+	avt_streamon_thread_disable(sd);
+#endif
+
+	if (camera->bcrm_wrhs_queue)
+		destroy_workqueue(camera->bcrm_wrhs_queue);
+
+	if (camera->pwdn_gpio)
+		devm_gpiod_put(&client->dev, camera->pwdn_gpio);
+
+	if (camera->reset_gpio)
+		devm_gpiod_put(&client->dev, camera->reset_gpio);
+
+	mutex_destroy(&camera->lock);
+
+	v4l2_async_unregister_subdev(sd);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 1, 0))
+	return 0;
+#endif
+}
+
+
+static const struct i2c_device_id avt_id[] = {
+	{"avt_csi2", 0},
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, avt_id);
+
+static const struct of_device_id avt_dt_ids[] = {
+	{
+		.compatible = "alliedvision,avt_csi2",
+	},
+	{}};
+MODULE_DEVICE_TABLE(of, avt_dt_ids);
+
+static struct i2c_driver avt_i2c_driver = {
+	.driver = {
+		.name = "avt_csi2",
+		.owner = THIS_MODULE,
+		.of_match_table = avt_dt_ids,
+	},
+	.id_table = avt_id,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(6, 3, 0))
+	.probe_new = avt_probe,
+#else
+	.probe = avt_probe,
+#endif
+	.remove = avt_remove,
+};
+
+module_i2c_driver(avt_i2c_driver);
+
+MODULE_DESCRIPTION("Allied Vision's MIPI-CSI2 Camera Driver");
+MODULE_AUTHOR("Allied Vision Inc.");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRIVER_VERSION);
diff --git a/drivers/media/i2c/tc358743.c b/drivers/media/i2c/tc358743.c
new file mode 100644
index 0000000..803ea09
--- /dev/null
+++ b/drivers/media/i2c/tc358743.c
@@ -0,0 +1,2383 @@
+/*
+ * References (c = chapter, p = page):
+ * REF_01 - Toshiba, TC358743XBG (H2C), Functional Specification, Rev 0.60
+ * REF_02 - Toshiba, TC358743XBG_HDMI-CSI_Tv11p_nm.xls
+ */
+#define DEBUG
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/hdmi.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/v4l2-dv-timings.h>
+#include <linux/videodev2.h>
+#include <linux/workqueue.h>
+#include <linux/gpio.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/of_graph.h>
+#include <linux/seq_file.h>
+#include <linux/fs.h>
+#include <linux/i2c-dev.h>
+
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-dv-timings.h>
+#include <media/v4l2-event.h>
+
+// OOT
+#include <media/camera_common.h>
+#include <media/tegra-v4l2-camera.h>
+
+#include <dt-bindings/gpio/tegra-gpio.h>
+
+#include <media/tc358743.h>
+
+/* RGB ouput selection */
+// #define TC358743_VOUT_RGB
+
+static int debug = 3;
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "debug level (0-3)");
+
+MODULE_DESCRIPTION("Toshiba TC358743 HDMI to CSI-2 bridge driver");
+MODULE_AUTHOR("Ramakrishnan Muthukrishnan <ram@rkrishnan.org>");
+MODULE_AUTHOR("Mikhail Khelik <mkhelik@cisco.com>");
+MODULE_AUTHOR("Mats Randgaard <matrandg@cisco.com>");
+MODULE_LICENSE("GPL");
+
+#define DELAY_ENABLE_INTERRUPT_MS 2000
+
+/* mode */
+enum {
+  tc358743_MODE_1280X720,
+  tc358743_MODE_1920X1080,
+};
+
+/* frame rate */
+static const int tc358743_30_60fps[] = {
+    30,
+    50,
+    60,
+};
+
+/* frame format */
+static const struct camera_common_frmfmt tc358743_frmfmt[] = {
+    {{1280, 720}, tc358743_30_60fps, 3, 0, tc358743_MODE_1280X720},
+    {{1920, 1080}, tc358743_30_60fps, 3, 0, tc358743_MODE_1920X1080},
+};
+
+// static const struct camera_common_colorfmt tc358743_color_fmts[] = {
+// 	{
+// 		MEDIA_BUS_FMT_SRGGB12_1X12,
+// 		V4L2_COLORSPACE_SRGB,
+// 		V4L2_PIX_FMT_SRGGB12,
+// 	},
+// 	{
+// 		MEDIA_BUS_FMT_UYVY8_1X16,
+// 		V4L2_COLORSPACE_SRGB,
+// 		V4L2_PIX_FMT_UYVY,
+// 	},
+// };
+
+#define EDID_NUM_BLOCKS_MAX 8
+#define EDID_BLOCK_SIZE 128
+static u8 edid[] = {
+
+    // #ifdef TC358743_VOUT_RGB
+    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x50, 0x21, 0x9C, 0x27,
+    0x00, 0x00, 0x00, 0x00, 0x19, 0x12, 0x01, 0x03, 0x80, 0x00, 0x00, 0x78,
+    0x0E, 0x00, 0xB2, 0xA0, 0x57, 0x49, 0x9B, 0x26, 0x10, 0x48, 0x4F, 0x2F,
+    0xCF, 0x00, 0x31, 0x59, 0x45, 0x59, 0x61, 0x59, 0x81, 0x99, 0x01, 0x01,
+    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x3A, 0x80, 0x18, 0x71, 0x38,
+    0x2D, 0x40, 0x58, 0x2C, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1E,
+    0x00, 0x00, 0x00, 0xFD, 0x00, 0x31, 0x55, 0x18, 0x5E, 0x11, 0x00, 0x0A,
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x54,
+    0x6F, 0x73, 0x68, 0x69, 0x62, 0x61, 0x2D, 0x48, 0x32, 0x43, 0x0A, 0x20,
+    0x00, 0x00, 0x00, 0xFD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc3, 0x02, 0x03, 0x1a, 0xc0,
+    0x48, 0xa2, 0x10, 0x04, 0x02, 0x01, 0x21, 0x14, 0x13, 0x23, 0x09, 0x07,
+    0x07, 0x65, 0x03, 0x0c, 0x00, 0x10, 0x00, 0xe2, 0x00, 0x2a, 0x01, 0x1d,
+    0x00, 0x80, 0x51, 0xd0, 0x1c, 0x20, 0x40, 0x80, 0x35, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x1e, 0x8c, 0x0a, 0xd0, 0x8a, 0x20, 0xe0, 0x2d, 0x10,
+    0x10, 0x3e, 0x96, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0xd7
+    // #else
+    // 0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,
+    // 0x52,0x62,0x88,0x88,0x00,0x88,0x88,0x88,
+    // 0x1C,0x15,0x01,0x03,0x80,0x00,0x00,0x78,
+    // 0x0A,0x0D,0xC9,0xA0,0x57,0x47,0x98,0x27,
+    // 0x12,0x48,0x4C,0x00,0x00,0x00,0x01,0x01,
+    // 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
+    // 0x01,0x01,0x01,0x01,0x01,0x01,0x02,0x3A,
+    // 0x80,0xD0,0x72,0x38,0x2D,0x40,0x10,0x2C,
+    // 0x45,0x80,0x66,0x4C,0x00,0x00,0x00,0x1E,
+    // 0x01,0x1D,0x00,0xBC,0x52,0xD0,0x1E,0x20,
+    // 0xB8,0x28,0x55,0x40,0x66,0x4C,0x00,0x00,
+    // 0x00,0x1E,0x00,0x00,0x00,0xFC,0x00,0x54,
+    // 0x6F,0x73,0x68,0x69,0x62,0x61,0x2D,0x48,
+    // 0x32,0x43,0x0A,0x20,0x00,0x00,0x00,0xFD,
+    // 0x00,0x14,0x78,0x01,0xFF,0x10,0x00,0x0A,
+    // 0x20,0x20,0x20,0x20,0x20,0x20,0x00,0xBA,
+    // 0x02,0x03,0x1A,0x71,0x47,0x9F,0x13,0x22,
+    // 0x1F,0x02,0x11,0x1F,0x23,0x09,0x07,0x01,
+    // 0x83,0x01,0x00,0x00,0x65,0x03,0x0C,0x00,
+    // 0x10,0x00,0x01,0x1D,0x80,0x18,0x71,0x38,
+    // 0x2D,0x40,0x58,0x2C,0x45,0x00,0x66,0x4C,
+    // 0x00,0x00,0x00,0x1E,0x02,0x3A,0x80,0xD0,
+    // 0x72,0x38,0x2D,0x40,0x10,0x2C,0x45,0x80,
+    // 0x66,0x4C,0x00,0x00,0x00,0x1E,0x8C,0x0A,
+    // 0xD0,0x8A,0x20,0xE0,0x2D,0x10,0x10,0x3E,
+    // 0x96,0x00,0x66,0x4C,0x00,0x00,0x00,0x18,
+    // 0x8C,0x0A,0xD0,0x90,0x20,0x40,0x31,0x20,
+    // 0x0C,0x40,0x55,0x00,0x66,0x4C,0x00,0x00,
+    // 0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00,
+    // 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    // 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    // 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,
+    // #endif
+};
+/* Max transfer size done by I2C transfer functions */
+#define MAX_XFER_SIZE (EDID_NUM_BLOCKS_MAX * EDID_BLOCK_SIZE + 2)
+
+static const struct v4l2_dv_timings_cap tc358743_timings_cap = {
+    .type = V4L2_DV_BT_656_1120,
+    /* keep this initialization for compatibility with GCC < 4.4.6 */
+    .reserved = {0},
+    /* Pixel clock from REF_01 p. 20. Min/max height/width are unknown */
+    V4L2_INIT_BT_TIMINGS(1, 10000, 1, 10000, 0, 165000000,
+                         V4L2_DV_BT_STD_CEA861 | V4L2_DV_BT_STD_DMT |
+                             V4L2_DV_BT_STD_GTF | V4L2_DV_BT_STD_CVT,
+                         V4L2_DV_BT_CAP_PROGRESSIVE |
+                             V4L2_DV_BT_CAP_REDUCED_BLANKING |
+                             V4L2_DV_BT_CAP_CUSTOM)};
+
+struct tc358743_state {
+  struct tc358743_platform_data pdata;
+  // struct v4l2_of_bus_mipi_csi2 bus;
+  struct v4l2_subdev sd;
+  struct media_pad pad;
+  struct v4l2_ctrl_handler hdl;
+  struct i2c_client *i2c_client;
+  struct regmap *regmap;
+  /* CONFCTL is modified in ops and tc358743_hdmi_sys_int_handler */
+  struct mutex confctl_mutex;
+
+  /* controls */
+  struct v4l2_ctrl *detect_tx_5v_ctrl;
+  struct v4l2_ctrl *audio_sampling_rate_ctrl;
+  struct v4l2_ctrl *audio_present_ctrl;
+
+  /* work queues */
+  struct workqueue_struct *work_queues;
+  struct delayed_work delayed_work_enable_hotplug;
+  struct delayed_work delayed_work_enable_interrupt;
+  struct work_struct process_isr;
+  struct mutex isr_lock;
+
+  /* edid  */
+  u8 edid_blocks_written;
+
+  /* used by i2c_wr() */
+  u8 wr_data[MAX_XFER_SIZE];
+
+  struct v4l2_dv_timings timings;
+  u32 mbus_fmt_code;
+
+  struct gpio_desc *reset_gpio;
+};
+
+static inline struct tc358743_state *to_state(struct v4l2_subdev *sd) {
+  return container_of(sd, struct tc358743_state, sd);
+}
+/*
+static char * sdo_bit_len [] = {
+    [0b000] = "16bit (lower 8bit discarded)",
+    [0b001] = "16bit (lower 8bit + 1 discarded)",
+    [0b010] = "18bit (lower 6bit discarded)",
+    [0b011] = "18bit (lower 6bit + 1 discarded)",
+    [0b100] = "20bit (lower 4bit discarded)",
+    [0b101] = "20bit (lower 4bit + 1 discarded)",
+    [0b110] = "24bit no rounding",
+    [0b111] = "Output OFF (Mute)",
+};
+
+static char * sdo_fmt [] = {
+    [MASK_SDO_FMT_RIGHT] = "Right justified",
+    [MASK_SDO_FMT_LEFT] = "Left justified",
+    [MASK_SDO_FMT_I2S] = "I2S",
+    [0b011] = "I2S",
+};
+
+static char * no_yes [] = {
+    [0] = "No",
+    [1] = "Yes",
+};
+
+static char * no_with [] = {
+    [0] = "No",
+    [1] = "With",
+};
+
+static char * off_on [] = {
+    [0b000] = "Off",
+    [0b001] = "On",
+};
+
+static char * audout_sel [] = {
+    [0b00] = "CSI2-TX",
+    [0b01] = "Reseved",
+    [0b10] = "I2S",
+    [0b11] = "TDM",
+};
+*/
+/* --------------- I2C --------------- */
+static int i2c_rd(struct v4l2_subdev *sd, u16 reg, u8 *values, u32 n) {
+  struct tc358743_state *state = to_state(sd);
+  struct i2c_client *client = state->i2c_client;
+  int err;
+  u8 buf[2] = {reg >> 8, reg & 0xff};
+  struct i2c_msg msgs[] = {
+      {
+          .addr = client->addr,
+          .flags = 0,
+          .len = 2,
+          .buf = buf,
+      },
+      {
+          .addr = client->addr,
+          .flags = I2C_M_RD,
+          .len = n,
+          .buf = values,
+      },
+  };
+
+  err = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
+  if (err != ARRAY_SIZE(msgs)) {
+    v4l2_err(sd, "%s: #### reading register0x%x from0x%x failed\n", __func__,
+             reg, client->addr);
+    return -1;
+  }
+  // udelay(10);
+  return 0;
+}
+
+static int i2c_wr(struct v4l2_subdev *sd, u16 reg, u8 *values, u32 n) {
+  struct tc358743_state *state = to_state(sd);
+  struct i2c_client *client = state->i2c_client;
+  u8 *data = state->wr_data;
+  int err, i;
+  struct i2c_msg msg;
+
+  if ((2 + n) > sizeof(state->wr_data)) {
+    v4l2_warn(sd, "i2c wr reg=%04x: len=%d is too big!\n", reg, 2 + n);
+    return -1;
+  }
+
+  msg.addr = client->addr;
+  msg.buf = data;
+  msg.len = 2 + n;
+  msg.flags = 0;
+
+  data[0] = reg >> 8;
+  data[1] = reg & 0xff;
+
+  for (i = 0; i < n; i++) data[2 + i] = values[i];
+
+  err = i2c_transfer(client->adapter, &msg, 1);
+  if (err != 1) {
+    v4l2_err(sd, "%s: writing register0x%x from0x%x failed\n", __func__, reg,
+             client->addr);
+    return -1;
+  }
+  return 0;
+}
+
+static u8 i2c_rd8(struct v4l2_subdev *sd, u16 reg) {
+  u8 val;
+
+  i2c_rd(sd, reg, &val, 1);
+
+  return val;
+}
+
+static void i2c_wr8(struct v4l2_subdev *sd, u16 reg, u8 val) {
+  i2c_wr(sd, reg, &val, 1);
+}
+
+static void i2c_wr8_and_or(struct v4l2_subdev *sd, u16 reg, u8 mask, u8 val) {
+  i2c_wr8(sd, reg, (i2c_rd8(sd, reg) & mask) | val);
+}
+
+static u16 i2c_rd16(struct v4l2_subdev *sd, u16 reg) {
+  u16 val;
+  int ret;
+  // v4l2_info(sd, "Reading i2c_rd16\n");
+
+  ret = i2c_rd(sd, reg, (u8 *)&val, 2);
+  // v4l2_info(sd, "RET %d\n", ret);
+
+  if (ret == -1) {
+    // Read failed
+    return 99;  // TODO. Make this better!
+  }
+
+  return val;
+}
+
+static void i2c_wr16(struct v4l2_subdev *sd, u16 reg, u16 val) {
+  i2c_wr(sd, reg, (u8 *)&val, 2);
+}
+
+static void i2c_wr16_and_or(struct v4l2_subdev *sd, u16 reg, u16 mask,
+                            u16 val) {
+  i2c_wr16(sd, reg, (i2c_rd16(sd, reg) & mask) | val);
+}
+
+static u32 i2c_rd32(struct v4l2_subdev *sd, u16 reg) {
+  u32 val;
+
+  i2c_rd(sd, reg, (u8 *)&val, 4);
+
+  return val;
+}
+
+static void i2c_wr32(struct v4l2_subdev *sd, u16 reg, u32 val) {
+  i2c_wr(sd, reg, (u8 *)&val, 4);
+}
+/* --------------- STATUS --------------- */
+
+static inline bool is_hdmi(struct v4l2_subdev *sd) {
+  v4l2_info(sd, "function %s\n", __func__);
+
+  return i2c_rd8(sd, SYS_STATUS) & MASK_S_HDMI;
+}
+
+static inline bool tx_5v_power_present(struct v4l2_subdev *sd) {
+  v4l2_info(sd, "function %s\n", __func__);
+  return i2c_rd8(sd, SYS_STATUS) & MASK_S_DDC5V;
+}
+
+static inline bool no_signal(struct v4l2_subdev *sd) {
+  v4l2_info(sd, "function %s\n", __func__);
+  return !(i2c_rd8(sd, SYS_STATUS) & MASK_S_TMDS);
+}
+
+static inline bool no_sync(struct v4l2_subdev *sd) {
+  v4l2_info(sd, "function %s\n", __func__);
+  return !(i2c_rd8(sd, SYS_STATUS) & MASK_S_SYNC);
+}
+
+static inline bool audio_present(struct v4l2_subdev *sd) {
+  v4l2_info(sd, "function %s\n", __func__);
+  return i2c_rd8(sd, AU_STATUS0) & MASK_S_A_SAMPLE;
+}
+
+static int get_audio_sampling_rate(struct v4l2_subdev *sd) {
+  static const int code_to_rate[] = {
+      44100, 0,      48000, 32000,  22050,  384000, 24000,  352800,
+      88200, 768000, 96000, 705600, 176400, 0,      192000, 0};
+  v4l2_info(sd, "function %s\n", __func__);
+  /* Register FS_SET is not cleared when the cable is disconnected */
+  if (no_signal(sd)) return 0;
+
+  return code_to_rate[i2c_rd8(sd, FS_SET) & MASK_FS];
+}
+
+static unsigned tc358743_num_csi_lanes_in_use(struct v4l2_subdev *sd) {
+  v4l2_info(sd, "function %s\n", __func__);
+  return ((i2c_rd32(sd, CSI_CONTROL) & MASK_NOL) >> 1) + 1;
+}
+
+/* --------------- TIMINGS --------------- */
+
+static inline unsigned fps(const struct v4l2_bt_timings *t) {
+  if (!V4L2_DV_BT_FRAME_HEIGHT(t) || !V4L2_DV_BT_FRAME_WIDTH(t)) return 0;
+
+  return DIV_ROUND_CLOSEST(
+      (unsigned)t->pixelclock,
+      V4L2_DV_BT_FRAME_HEIGHT(t) * V4L2_DV_BT_FRAME_WIDTH(t));
+}
+
+static int tc358743_get_detected_timings(struct v4l2_subdev *sd,
+                                         struct v4l2_dv_timings *timings) {
+  struct v4l2_bt_timings *bt = &timings->bt;
+  unsigned width, height, frame_width, frame_height, frame_interval, fps;
+
+  memset(timings, 0, sizeof(struct v4l2_dv_timings));
+
+  if (no_signal(sd)) {
+    v4l2_info(sd, "%s: no valid signal\n", __func__);
+    return -ENOLINK;
+  }
+  if (no_sync(sd)) {
+    v4l2_info(sd, "%s: no sync on signal\n", __func__);
+    return -ENOLCK;
+  }
+
+  timings->type = V4L2_DV_BT_656_1120;
+  bt->interlaced = i2c_rd8(sd, VI_STATUS1) & MASK_S_V_INTERLACE
+                       ? V4L2_DV_INTERLACED
+                       : V4L2_DV_PROGRESSIVE;
+
+  width =
+      ((i2c_rd8(sd, DE_WIDTH_H_HI) & 0x1f) << 8) + i2c_rd8(sd, DE_WIDTH_H_LO);
+  height =
+      ((i2c_rd8(sd, DE_WIDTH_V_HI) & 0x1f) << 8) + i2c_rd8(sd, DE_WIDTH_V_LO);
+  frame_width = ((i2c_rd8(sd, H_SIZE_HI) & 0x1f) << 8) + i2c_rd8(sd, H_SIZE_LO);
+  frame_height =
+      (((i2c_rd8(sd, V_SIZE_HI) & 0x3f) << 8) + i2c_rd8(sd, V_SIZE_LO)) / 2;
+  /* frame interval in milliseconds * 10
+   * Require SYS_FREQ0 and SYS_FREQ1 are precisely set */
+  frame_interval =
+      ((i2c_rd8(sd, FV_CNT_HI) & 0x3) << 8) + i2c_rd8(sd, FV_CNT_LO);
+  fps = (frame_interval > 0) ? DIV_ROUND_CLOSEST(10000, frame_interval) : 0;
+
+  bt->width = width;
+  bt->height = height;
+  bt->vsync = frame_height - height;
+  bt->hsync = frame_width - width;
+  bt->pixelclock = frame_width * frame_height * fps;
+  if (bt->interlaced == V4L2_DV_INTERLACED) {
+    bt->height *= 2;
+    bt->il_vsync = bt->vsync + 1;
+    bt->pixelclock /= 2;
+  }
+  v4l2_info(sd, "%d:%s: width %d heigh %d interlaced %d\n", __LINE__,
+            __FUNCTION__, bt->width, bt->height, bt->interlaced);
+  return 0;
+}
+/* --------------- HOTPLUG / HDCP / EDID --------------- */
+
+static void tc358743_delayed_work_enable_hotplug(struct work_struct *work) {
+  struct delayed_work *dwork = to_delayed_work(work);
+  struct tc358743_state *state =
+      container_of(dwork, struct tc358743_state, delayed_work_enable_hotplug);
+  struct v4l2_subdev *sd = &state->sd;
+
+  v4l2_info(sd, "%s:\n", __func__);
+
+  i2c_wr8_and_or(sd, HPD_CTL, ~MASK_HPD_OUT0, MASK_HPD_OUT0);
+  /*hainh
+  i2c_wr8_and_or(sd, HPD_CTL, ~MASK_HPD_CTL0, MASK_HPD_CTL0);
+  */
+}
+
+static void tc358743_set_hdmi_hdcp(struct v4l2_subdev *sd, bool enable) {
+  v4l2_info(sd, "%s: %s\n", __func__, enable ? "enable" : "disable");
+
+  i2c_wr8_and_or(sd, HDCP_REG1, ~(MASK_AUTH_UNAUTH_SEL | MASK_AUTH_UNAUTH),
+                 MASK_AUTH_UNAUTH_SEL_16_FRAMES | MASK_AUTH_UNAUTH_AUTO);
+
+  i2c_wr8_and_or(sd, HDCP_REG2, ~MASK_AUTO_P3_RESET,
+                 SET_AUTO_P3_RESET_FRAMES(0x0f));
+
+  /* HDCP is disabled by configuring the receiver as HDCP repeater. The
+   * repeater mode require software support to work, so HDCP
+   * authentication will fail. */
+  i2c_wr8_and_or(sd, HDCP_REG3, ~KEY_RD_CMD, enable ? KEY_RD_CMD : 0);
+  i2c_wr8_and_or(sd, HDCP_MODE, ~(MASK_AUTO_CLR | MASK_MODE_RST_TN),
+                 enable ? (MASK_AUTO_CLR | MASK_MODE_RST_TN) : 0);
+
+  /* Apple MacBook Pro gen.8 has a bug that makes it freeze every fifth
+   * second when HDCP is disabled, but the MAX_EXCED bit is handled
+   * correctly and HDCP is disabled on the HDMI output. */
+  i2c_wr8_and_or(sd, BSTATUS1, ~MASK_MAX_EXCED, enable ? 0 : MASK_MAX_EXCED);
+  i2c_wr8_and_or(sd, BCAPS, ~(MASK_REPEATER | MASK_READY),
+                 enable ? 0 : MASK_REPEATER | MASK_READY);
+}
+
+static void tc358743_disable_edid(struct v4l2_subdev *sd) {
+  struct tc358743_state *state = to_state(sd);
+
+  v4l2_info(sd, "%s:\n", __func__);
+
+  cancel_delayed_work_sync(&state->delayed_work_enable_hotplug);
+
+  /* DDC access to EDID is also disabled when hotplug is disabled. See
+   * register DDC_CTL */
+  i2c_wr8_and_or(sd, HPD_CTL, ~MASK_HPD_OUT0, 0x0);
+}
+
+static void tc358743_erase_bksv(struct v4l2_subdev *sd) {
+  int i;
+  v4l2_info(sd, "function %s\n", __func__);
+  for (i = 0; i < 5; i++) i2c_wr8(sd, BKSV + i, 0);
+}
+
+/* --------------- AVI infoframe --------------- */
+
+static void print_avi_infoframe(struct v4l2_subdev *sd) {
+  struct i2c_client *client = v4l2_get_subdevdata(sd);
+  struct device *dev = &client->dev;
+  union hdmi_infoframe frame;
+  u8 buffer[HDMI_INFOFRAME_SIZE(AVI)];
+  v4l2_info(sd, "function %s\n", __func__);
+  if (!is_hdmi(sd)) {
+    v4l2_info(sd, "DVI-D signal - AVI infoframe not supported\n");
+    return;
+  }
+
+  i2c_rd(sd, PK_AVI_0HEAD, buffer, HDMI_INFOFRAME_SIZE(AVI));
+
+  if (hdmi_infoframe_unpack(&frame, buffer, sizeof(buffer)) < 0) {
+    v4l2_err(sd, "%s: unpack of AVI infoframe failed\n", __func__);
+    return;
+  }
+
+  hdmi_infoframe_log(KERN_INFO, dev, &frame);
+}
+
+/* --------------- CTRLS --------------- */
+
+static int tc358743_s_ctrl_detect_tx_5v(struct v4l2_subdev *sd) {
+  struct tc358743_state *state = to_state(sd);
+  v4l2_info(sd, "function %s\n", __func__);
+  return v4l2_ctrl_s_ctrl(state->detect_tx_5v_ctrl, tx_5v_power_present(sd));
+}
+
+static int tc358743_s_ctrl_audio_sampling_rate(struct v4l2_subdev *sd) {
+  struct tc358743_state *state = to_state(sd);
+  v4l2_info(sd, "function %s\n", __func__);
+  return v4l2_ctrl_s_ctrl(state->audio_sampling_rate_ctrl,
+                          get_audio_sampling_rate(sd));
+}
+
+static int tc358743_s_ctrl_audio_present(struct v4l2_subdev *sd) {
+  struct tc358743_state *state = to_state(sd);
+  v4l2_info(sd, "function %s\n", __func__);
+  return v4l2_ctrl_s_ctrl(state->audio_present_ctrl, audio_present(sd));
+}
+
+static int tc358743_update_controls(struct v4l2_subdev *sd) {
+  int ret = 0;
+  v4l2_info(sd, "function %s\n", __func__);
+
+  ret |= tc358743_s_ctrl_detect_tx_5v(sd);
+  ret |= tc358743_s_ctrl_audio_sampling_rate(sd);
+  ret |= tc358743_s_ctrl_audio_present(sd);
+
+  return ret;
+}
+
+static unsigned tc358743_num_csi_lanes_needed(struct v4l2_subdev *sd) {
+  // return 2;
+  struct tc358743_state *state = to_state(sd);
+  struct v4l2_bt_timings *bt = &state->timings.bt;
+  struct tc358743_platform_data *pdata = &state->pdata;
+  u32 bits_pr_pixel =
+      (state->mbus_fmt_code == MEDIA_BUS_FMT_UYVY8_1X16) ? 16 : 24;
+  u32 bps = bt->width * bt->height * fps(bt) * bits_pr_pixel;
+  u32 bps_pr_lane = (pdata->refclk_hz / pdata->pll_prd) * pdata->pll_fbd;
+  v4l2_info(sd, "function %s bps %d bps_pr_lane%d \n", __func__, bps,
+            bps_pr_lane);
+  return DIV_ROUND_UP(bps, bps_pr_lane);
+}
+
+static int tc358743_get_edid(struct v4l2_subdev *sd) {
+  u8 edid_read[256];
+  int result = 0;
+  u32 n = sizeof(edid_read);
+
+  result = i2c_rd(sd, EDID_RAM, edid_read, n);
+  v4l2_info(sd, "%s i2c_rd return %d\r\n", __func__, result);
+  v4l2_info(sd, "%s done\r\n", __func__);
+  return 0;
+}
+
+static int tc358743_log_status(struct v4l2_subdev *sd) {
+  struct tc358743_state *state = to_state(sd);
+  struct v4l2_dv_timings timings;
+  uint8_t hdmi_sys_status = i2c_rd8(sd, SYS_STATUS);
+  uint16_t sysctl = i2c_rd16(sd, SYSCTL);
+  u8 vi_status3 = i2c_rd8(sd, VI_STATUS3);
+  const int deep_color_mode[4] = {8, 10, 12, 16};
+  static const char *const input_color_space[] = {
+      "RGB",       "YCbCr 601", "Adobe RGB", "YCbCr 709",    "NA (4)",
+      "xvYCC 601", "NA(6)",     "xvYCC 709", "NA(8)",        "sYCC601",
+      "NA(10)",    "NA(11)",    "NA(12)",    "Adobe YCC 601"};
+  tc358743_get_edid(sd);
+  v4l2_info(sd, "-----Chip status-----\n");
+  v4l2_info(sd, "Chip ID:0x%02x\n", (i2c_rd16(sd, CHIPID) & MASK_CHIPID) >> 8);
+  v4l2_info(sd, "Chip revision:0x%02x\n", i2c_rd16(sd, CHIPID) & MASK_REVID);
+  v4l2_info(sd, "Reset: IR: %d, CEC: %d, CSI TX: %d, HDMI: %d\n",
+            !!(sysctl & MASK_IRRST), !!(sysctl & MASK_CECRST),
+            !!(sysctl & MASK_CTXRST), !!(sysctl & MASK_HDMIRST));
+  v4l2_info(sd, "Sleep mode: %s\n", sysctl & MASK_SLEEP ? "on" : "off");
+  v4l2_info(sd, "Cable detected (+5V power): %s\n",
+            hdmi_sys_status & MASK_S_DDC5V ? "yes" : "no");
+  v4l2_info(sd, "DDC lines enabled: %s\n",
+            (i2c_rd8(sd, EDID_MODE) & MASK_EDID_MODE_E_DDC) ? "yes" : "no");
+  v4l2_info(sd, "Hotplug enabled: %s\n",
+            (i2c_rd8(sd, HPD_CTL) & MASK_HPD_OUT0) ? "yes" : "no");
+  v4l2_info(sd, "CEC enabled: %s\n",
+            (i2c_rd16(sd, CECEN) & MASK_CECEN) ? "yes" : "no");
+  v4l2_info(sd, "-----Signal status-----\n");
+  v4l2_info(sd, "TMDS signal detected: %s\n",
+            hdmi_sys_status & MASK_S_TMDS ? "yes" : "no");
+  v4l2_info(sd, "Stable sync signal: %s\n",
+            hdmi_sys_status & MASK_S_SYNC ? "yes" : "no");
+  v4l2_info(sd, "PHY PLL locked: %s\n",
+            hdmi_sys_status & MASK_S_PHY_PLL ? "yes" : "no");
+  v4l2_info(sd, "PHY DE detected: %s\n",
+            hdmi_sys_status & MASK_S_PHY_SCDT ? "yes" : "no");
+
+  if (tc358743_get_detected_timings(sd, &timings)) {
+    v4l2_info(sd, "No video detected\n");
+  } else {
+    v4l2_print_dv_timings(sd->name, "Detected format: ", &timings, true);
+  }
+  v4l2_print_dv_timings(sd->name, "Configured format: ", &state->timings, true);
+
+  v4l2_info(sd, "-----CSI-TX status-----\n");
+  v4l2_info(sd, "Lanes needed: %d\n", tc358743_num_csi_lanes_needed(sd));
+  v4l2_info(sd, "Lanes in use: %d\n", tc358743_num_csi_lanes_in_use(sd));
+  v4l2_info(sd, "Waiting for particular sync signal: %s\n",
+            (i2c_rd16(sd, CSI_STATUS) & MASK_S_WSYNC) ? "yes" : "no");
+  v4l2_info(sd, "Transmit mode: %s\n",
+            (i2c_rd16(sd, CSI_STATUS) & MASK_S_TXACT) ? "yes" : "no");
+  v4l2_info(sd, "Receive mode: %s\n",
+            (i2c_rd16(sd, CSI_STATUS) & MASK_S_RXACT) ? "yes" : "no");
+  v4l2_info(sd, "Stopped: %s\n",
+            (i2c_rd16(sd, CSI_STATUS) & MASK_S_HLT) ? "yes" : "no");
+  v4l2_info(sd, "Color space: %s\n",
+            state->mbus_fmt_code == MEDIA_BUS_FMT_UYVY8_1X16
+                ? "YCbCr 422 16-bit"
+                : state->mbus_fmt_code == MEDIA_BUS_FMT_RGB888_1X24
+                      ? "RGB 888 24-bit"
+                      : "Unsupported");
+
+  v4l2_info(sd, "-----%s status-----\n", is_hdmi(sd) ? "HDMI" : "DVI-D");
+  v4l2_info(sd, "HDCP encrypted content: %s\n",
+            hdmi_sys_status & MASK_S_HDCP ? "yes" : "no");
+  v4l2_info(sd, "Input color space: %s %s range\n",
+            input_color_space[(vi_status3 & MASK_S_V_COLOR) >> 1],
+            (vi_status3 & MASK_LIMITED) ? "limited" : "full");
+  if (!is_hdmi(sd)) return 0;
+  v4l2_info(sd, "AV Mute: %s\n",
+            hdmi_sys_status & MASK_S_AVMUTE ? "on" : "off");
+  v4l2_info(sd, "Deep color mode: %d-bits per channel\n",
+            deep_color_mode[(i2c_rd8(sd, VI_STATUS1) & MASK_S_DEEPCOLOR) >> 2]);
+  print_avi_infoframe(sd);
+
+  return 0;
+}
+
+/* --------------- INIT --------------- */
+
+static void tc358743_reset_phy(struct v4l2_subdev *sd) {
+  v4l2_info(sd, "%s:\n", __func__);
+
+  i2c_wr8_and_or(sd, PHY_RST, ~MASK_RESET_CTRL, 0);
+  i2c_wr8_and_or(sd, PHY_RST, ~MASK_RESET_CTRL, MASK_RESET_CTRL);
+}
+
+static void tc358743_reset(struct v4l2_subdev *sd, uint16_t mask) {
+  u16 sysctl = i2c_rd16(sd, SYSCTL);
+  v4l2_info(sd, "function %s\n", __func__);
+
+  i2c_wr16(sd, SYSCTL, sysctl | mask);
+  i2c_wr16(sd, SYSCTL, sysctl & ~mask);
+}
+
+static inline void tc358743_sleep_mode(struct v4l2_subdev *sd, bool enable) {
+  v4l2_info(sd, "function %s\n", __func__);
+
+  i2c_wr16_and_or(sd, SYSCTL, ~MASK_SLEEP, enable ? MASK_SLEEP : 0);
+}
+
+static inline void enable_stream(struct v4l2_subdev *sd, bool enable) {
+  struct tc358743_state *state = to_state(sd);
+
+  v4l2_info(sd, "LDS> Transmit mode: %s\n",
+            (i2c_rd16(sd, CSI_STATUS) & MASK_S_TXACT) ? "yes" : "no");
+  v4l2_info(sd, "LDS> %s: %sable\n", __func__, enable ? "en" : "dis");
+
+  if (enable) {
+    /* It is critical for CSI receiver to see lane transition
+     * LP11->HS. Set to non-continuous mode to enable clock lane
+     * LP11 state. */
+    i2c_wr32(sd, TXOPTIONCNTRL, 0);
+    /* Set to continuous mode to trigger LP11->HS transition */
+    i2c_wr32(sd, TXOPTIONCNTRL, MASK_CONTCLKMODE);
+    /* Unmute video */
+    i2c_wr8(sd, VI_MUTE, MASK_AUTO_MUTE);
+  } else {
+    /* Mute video so that all data lanes go to LSP11 state.
+     * No data is output to CSI Tx block. */
+    i2c_wr8(sd, VI_MUTE, MASK_AUTO_MUTE | MASK_VI_MUTE);
+  }
+
+  mutex_lock(&state->confctl_mutex);
+  i2c_wr16_and_or(sd, CONFCTL, ~(MASK_VBUFEN | MASK_ABUFEN),
+                  enable ? (MASK_VBUFEN | MASK_ABUFEN) : 0x0);
+  mutex_unlock(&state->confctl_mutex);
+  v4l2_info(sd, "%d:%s: end\n", __LINE__, __FUNCTION__);
+}
+
+static void tc358743_set_pll(struct v4l2_subdev *sd) {
+  struct tc358743_state *state = to_state(sd);
+  struct tc358743_platform_data *pdata = &state->pdata;
+  u16 pllctl0 = i2c_rd16(sd, PLLCTL0);
+  u16 pllctl1 = i2c_rd16(sd, PLLCTL1);
+  u16 pllctl0_new = SET_PLL_PRD(pdata->pll_prd) | SET_PLL_FBD(pdata->pll_fbd);
+  u32 hsck = (pdata->refclk_hz / pdata->pll_prd) * pdata->pll_fbd;
+
+  v4l2_info(sd, "%s:\n", __func__);
+
+  /* Only rewrite when needed (new value or disabled), since rewriting
+   * triggers another format change event. */
+  if ((pllctl0 != pllctl0_new) || ((pllctl1 & MASK_PLL_EN) == 0)) {
+    u16 pll_frs;
+
+    if (hsck > 500000000)
+      pll_frs = 0x0;
+    else if (hsck > 250000000)
+      pll_frs = 0x1;
+    else if (hsck > 125000000)
+      pll_frs = 0x2;
+    else
+      pll_frs = 0x3;
+    v4l2_info(sd, "%s: updating PLL clock\n", __func__);
+    tc358743_sleep_mode(sd, true);
+    i2c_wr16(sd, PLLCTL0, pllctl0_new);
+    i2c_wr16_and_or(sd, PLLCTL1, ~(MASK_PLL_FRS | MASK_RESETB | MASK_PLL_EN),
+                    (SET_PLL_FRS(pll_frs) | MASK_RESETB | MASK_PLL_EN));
+    udelay(10); /* REF_02, Sheet "Source HDMI" */
+    i2c_wr16_and_or(sd, PLLCTL1, ~MASK_CKEN, MASK_CKEN);
+    tc358743_sleep_mode(sd, false);
+  }
+}
+
+static void tc358743_set_ref_clk(struct v4l2_subdev *sd) {
+  struct tc358743_state *state = to_state(sd);
+  struct tc358743_platform_data *pdata = &state->pdata;
+  u32 sys_freq;
+  u32 lockdet_ref;
+  u16 fh_min;
+  u16 fh_max;
+  v4l2_info(sd, "function %s\n", __func__);
+
+  sys_freq = pdata->refclk_hz / 10000;
+  i2c_wr8(sd, SYS_FREQ0, sys_freq & 0x00ff);
+  i2c_wr8(sd, SYS_FREQ1, (sys_freq & 0xff00) >> 8);
+
+  i2c_wr8_and_or(sd, PHY_CTL0, ~MASK_PHY_SYSCLK_IND,
+                 (pdata->refclk_hz == 42000000) ? MASK_PHY_SYSCLK_IND : 0x0);
+
+  fh_min = pdata->refclk_hz / 100000;
+  i2c_wr8(sd, FH_MIN0, fh_min & 0x00ff);
+  i2c_wr8(sd, FH_MIN1, (fh_min & 0xff00) >> 8);
+
+  fh_max = (fh_min * 66) / 10;
+  i2c_wr8(sd, FH_MAX0, fh_max & 0x00ff);
+  i2c_wr8(sd, FH_MAX1, (fh_max & 0xff00) >> 8);
+
+  lockdet_ref = pdata->refclk_hz / 100;
+  i2c_wr8(sd, LOCKDET_REF0, lockdet_ref & 0x0000ff);
+  i2c_wr8(sd, LOCKDET_REF1, (lockdet_ref & 0x00ff00) >> 8);
+  i2c_wr8(sd, LOCKDET_REF2, (lockdet_ref & 0x0f0000) >> 16);
+
+  i2c_wr8_and_or(sd, NCO_F0_MOD, ~MASK_NCO_F0_MOD,
+                 (pdata->refclk_hz == 27000000) ? MASK_NCO_F0_MOD_27MHZ : 0x0);
+}
+
+static void tc358743_set_csi_color_space(struct v4l2_subdev *sd) {
+  struct tc358743_state *state = to_state(sd);
+  v4l2_info(sd, "function %s\n", __func__);
+
+  switch (state->mbus_fmt_code) {
+    case MEDIA_BUS_FMT_UYVY8_1X16:
+      v4l2_info(sd, "%s: YCbCr 422 16-bit\n", __func__);
+      i2c_wr8_and_or(sd, VOUT_SET2,
+                     ~(MASK_SEL422 | MASK_VOUT_422FIL_100) & 0xff,
+                     MASK_SEL422 | MASK_VOUT_422FIL_100);
+      i2c_wr8_and_or(sd, VI_REP, ~MASK_VOUT_COLOR_SEL & 0xff,
+                     MASK_VOUT_COLOR_601_YCBCR_LIMITED);
+      mutex_lock(&state->confctl_mutex);
+      i2c_wr16_and_or(sd, CONFCTL, ~MASK_YCBCRFMT, MASK_YCBCRFMT_422_8_BIT);
+      mutex_unlock(&state->confctl_mutex);
+      break;
+
+      // v4l2_info(sd, "LDS> %s: TEST pattern\n", __func__);
+      // i2c_wr8_and_or(sd, VOUT_SET2, ~(MASK_SEL422 | MASK_VOUT_422FIL_100) & 0xff, MASK_SEL422 | MASK_VOUT_422FIL_100);
+      // i2c_wr8_and_or(sd, VI_REP, ~MASK_VOUT_COLOR_SEL & 0xff, MASK_VOUT_COLOR_601_YCBCR_LIMITED);
+      // mutex_lock(&state->confctl_mutex);
+      // i2c_wr16_and_or(sd, CONFCTL, ~MASK_YCBCRFMT, MASK_YCBCRFMT_COLORBAR);
+      // mutex_unlock(&state->confctl_mutex);
+      // break;
+
+    case MEDIA_BUS_FMT_RGB888_1X24:
+      v4l2_info(sd, "%s: RGB 888 24-bit\n", __func__);
+      i2c_wr8_and_or(sd, VOUT_SET2,
+                     ~(MASK_SEL422 | MASK_VOUT_422FIL_100) & 0xff, 0x00);
+      i2c_wr8_and_or(sd, VI_REP, ~MASK_VOUT_COLOR_SEL & 0xff,
+                     MASK_VOUT_COLOR_RGB_FULL);
+      mutex_lock(&state->confctl_mutex);
+      i2c_wr16_and_or(sd, CONFCTL, ~MASK_YCBCRFMT, 0);
+      mutex_unlock(&state->confctl_mutex);
+      break;
+    default:
+      v4l2_dbg(2, debug, sd, "%s: Unsupported format code 0x%x\n", __func__,
+               state->mbus_fmt_code);
+      break;
+  }
+
+  // enable_stream(sd, true);  // Just put here for testing
+}
+
+static void tc358743_set_csi(struct v4l2_subdev *sd) {
+  struct tc358743_state *state = to_state(sd);
+  struct tc358743_platform_data *pdata = &state->pdata;
+  unsigned lanes = tc358743_num_csi_lanes_needed(sd);
+
+  v4l2_info(sd, "%s:\n", __func__);
+
+  tc358743_reset(sd, MASK_CTXRST);
+
+  if (lanes < 1) i2c_wr32(sd, CLW_CNTRL, MASK_CLW_LANEDISABLE);
+  if (lanes < 1) i2c_wr32(sd, D0W_CNTRL, MASK_D0W_LANEDISABLE);
+  if (lanes < 2) i2c_wr32(sd, D1W_CNTRL, MASK_D1W_LANEDISABLE);
+  if (lanes < 3) i2c_wr32(sd, D2W_CNTRL, MASK_D2W_LANEDISABLE);
+  if (lanes < 4) i2c_wr32(sd, D3W_CNTRL, MASK_D3W_LANEDISABLE);
+
+  i2c_wr32(sd, LINEINITCNT, pdata->lineinitcnt);
+  i2c_wr32(sd, LPTXTIMECNT, pdata->lptxtimecnt);
+  i2c_wr32(sd, TCLK_HEADERCNT, pdata->tclk_headercnt);
+  i2c_wr32(sd, TCLK_TRAILCNT, pdata->tclk_trailcnt);
+  i2c_wr32(sd, THS_HEADERCNT, pdata->ths_headercnt);
+  i2c_wr32(sd, TWAKEUP, pdata->twakeup);
+  i2c_wr32(sd, TCLK_POSTCNT, pdata->tclk_postcnt);
+  i2c_wr32(sd, THS_TRAILCNT, pdata->ths_trailcnt);
+  i2c_wr32(sd, HSTXVREGCNT, pdata->hstxvregcnt);
+
+  i2c_wr32(sd, HSTXVREGEN,
+           ((lanes > 0) ? MASK_CLM_HSTXVREGEN : 0x0) |
+               ((lanes > 0) ? MASK_D0M_HSTXVREGEN : 0x0) |
+               ((lanes > 1) ? MASK_D1M_HSTXVREGEN : 0x0) |
+               ((lanes > 2) ? MASK_D2M_HSTXVREGEN : 0x0) |
+               ((lanes > 3) ? MASK_D3M_HSTXVREGEN : 0x0));
+
+  i2c_wr32(
+      sd, TXOPTIONCNTRL,
+      (pdata->endpoint.bus.mipi_csi2.flags & V4L2_MBUS_CSI2_CONTINUOUS_CLOCK)
+          ? MASK_CONTCLKMODE
+          : 0);
+  i2c_wr32(sd, STARTCNTRL, MASK_START);
+  i2c_wr32(sd, CSI_START, MASK_STRT);
+
+  i2c_wr32(sd, CSI_CONFW,
+           MASK_MODE_SET | MASK_ADDRESS_CSI_CONTROL | MASK_CSI_MODE |
+               MASK_TXHSMD |
+               ((lanes == 4)
+                    ? MASK_NOL_4
+                    : (lanes == 3) ? MASK_NOL_3
+                                   : (lanes == 2) ? MASK_NOL_2 : MASK_NOL_1));
+
+  i2c_wr32(sd, CSI_CONFW,
+           MASK_MODE_SET | MASK_ADDRESS_CSI_ERR_INTENA | MASK_TXBRK |
+               MASK_QUNK | MASK_WCER | MASK_INER);
+
+  i2c_wr32(
+      sd, CSI_CONFW,
+      MASK_MODE_CLEAR | MASK_ADDRESS_CSI_ERR_HALT | MASK_TXBRK | MASK_QUNK);
+
+  i2c_wr32(sd, CSI_CONFW,
+           MASK_MODE_SET | MASK_ADDRESS_CSI_INT_ENA | MASK_INTER);
+}
+
+static void tc358743_set_hdmi_phy(struct v4l2_subdev *sd) {
+  struct tc358743_state *state = to_state(sd);
+  struct tc358743_platform_data *pdata = &state->pdata;
+  v4l2_info(sd, "function %s\n", __func__);
+
+  /* Default settings from REF_02, sheet "Source HDMI"
+   * and custom settings as platform data */
+  // turn of physics
+  i2c_wr8_and_or(sd, PHY_EN, ~MASK_ENABLE_PHY, 0x0);
+  i2c_wr8(sd, PHY_CTL1,
+          SET_PHY_AUTO_RST1_US(1600) | SET_FREQ_RANGE_MODE_CYCLES(1));
+  i2c_wr8_and_or(
+      sd, PHY_CTL2, ~MASK_PHY_AUTO_RSTn,
+      (pdata->hdmi_phy_auto_reset_tmds_detected ? MASK_PHY_AUTO_RST2 : 0) |
+          (pdata->hdmi_phy_auto_reset_tmds_in_range ? MASK_PHY_AUTO_RST3 : 0) |
+          (pdata->hdmi_phy_auto_reset_tmds_valid ? MASK_PHY_AUTO_RST4 : 0));
+  i2c_wr8(sd, PHY_BIAS, 0x40);
+  i2c_wr8(sd, PHY_CSQ, SET_CSQ_CNT_LEVEL(0x0a));
+  i2c_wr8(sd, AVM_CTL, 45);
+  i2c_wr8_and_or(sd, HDMI_DET, ~MASK_HDMI_DET_V,
+                 pdata->hdmi_detection_delay << 4);
+
+  i2c_wr8_and_or(
+      sd, HV_RST, ~(MASK_H_PI_RST | MASK_V_PI_RST),
+      (pdata->hdmi_phy_auto_reset_hsync_out_of_range ? MASK_H_PI_RST : 0) |
+          (pdata->hdmi_phy_auto_reset_vsync_out_of_range ? MASK_V_PI_RST : 0));
+  // turn on physics
+  i2c_wr8_and_or(sd, PHY_EN, ~MASK_ENABLE_PHY, MASK_ENABLE_PHY);
+}
+
+static void tc358743_set_hdmi_audio(struct v4l2_subdev *sd) {
+  struct tc358743_state *state = to_state(sd);
+  v4l2_info(sd, "function %s\n", __func__);
+
+  /* Default settings from REF_02, sheet "Source HDMI" */
+  i2c_wr8(sd, FORCE_MUTE, 0x00);
+  i2c_wr8(sd, AUTO_CMD0,
+          MASK_AUTO_MUTE7 | MASK_AUTO_MUTE6 | MASK_AUTO_MUTE5 |
+              MASK_AUTO_MUTE4 | MASK_AUTO_MUTE1 | MASK_AUTO_MUTE0);
+  i2c_wr8(sd, AUTO_CMD1, MASK_AUTO_MUTE9);
+  i2c_wr8(sd, AUTO_CMD2, MASK_AUTO_PLAY3 | MASK_AUTO_PLAY2);
+  i2c_wr8(sd, BUFINIT_START, SET_BUFINIT_START_MS(500));
+  i2c_wr8(sd, FS_MUTE, 0x00);
+  i2c_wr8(sd, FS_IMODE, MASK_NLPCM_SMODE | MASK_FS_SMODE);
+  i2c_wr8(sd, ACR_MODE, MASK_CTS_MODE);
+  i2c_wr8(sd, ACR_MDF0, MASK_ACR_L2MDF_1976_PPM | MASK_ACR_L1MDF_976_PPM);
+  i2c_wr8(sd, ACR_MDF1, MASK_ACR_L3MDF_3906_PPM);
+  i2c_wr8(sd, SDO_MODE1, MASK_SDO_FMT_I2S);
+  i2c_wr8(sd, DIV_MODE, SET_DIV_DLY_MS(100));
+
+  mutex_lock(&state->confctl_mutex);
+  i2c_wr16_and_or(sd, CONFCTL, 0xffff,
+                  MASK_AUDCHNUM_2 | MASK_AUDOUTSEL_I2S | MASK_AUTOINDEX);
+  mutex_unlock(&state->confctl_mutex);
+}
+
+static void tc358743_set_hdmi_info_frame_mode(struct v4l2_subdev *sd) {
+  /* Default settings from REF_02, sheet "Source HDMI" */
+  v4l2_info(sd, "function %s\n", __func__);
+
+  i2c_wr8(sd, PK_INT_MODE,
+          MASK_ISRC2_INT_MODE | MASK_ISRC_INT_MODE | MASK_ACP_INT_MODE |
+              MASK_VS_INT_MODE | MASK_SPD_INT_MODE | MASK_MS_INT_MODE |
+              MASK_AUD_INT_MODE | MASK_AVI_INT_MODE);
+  i2c_wr8(sd, NO_PKT_LIMIT, 0x2c);
+  i2c_wr8(sd, NO_PKT_CLR, 0x53);
+  i2c_wr8(sd, ERR_PK_LIMIT, 0x01);
+  i2c_wr8(sd, NO_PKT_LIMIT2, 0x30);
+  i2c_wr8(sd, NO_GDB_LIMIT, 0x10);
+}
+
+static void tc358743_initial_setup(struct v4l2_subdev *sd) {
+  struct tc358743_state *state = to_state(sd);
+  struct tc358743_platform_data *pdata = &state->pdata;
+  v4l2_info(sd, "function %s\n", __func__);
+
+  /* CEC and IR are not supported by this driver */
+  i2c_wr16_and_or(sd, SYSCTL, ~(MASK_CECRST | MASK_IRRST),
+                  (MASK_CECRST | MASK_IRRST));
+
+  tc358743_reset(sd, MASK_CTXRST | MASK_HDMIRST);
+  tc358743_sleep_mode(sd, false);
+
+  i2c_wr16(sd, FIFOCTL, pdata->fifo_level);
+
+  tc358743_set_ref_clk(sd);
+
+  i2c_wr8_and_or(sd, DDC_CTL, ~MASK_DDC5V_MODE,
+                 pdata->ddc5v_delay & MASK_DDC5V_MODE);
+
+  i2c_wr8_and_or(sd, EDID_MODE, ~MASK_EDID_MODE, MASK_EDID_MODE_E_DDC);
+
+  tc358743_set_hdmi_phy(sd);
+  tc358743_set_hdmi_hdcp(sd, pdata->enable_hdcp);
+  tc358743_set_hdmi_audio(sd);
+  tc358743_set_hdmi_info_frame_mode(sd);
+
+  /* All CE and IT formats are detected as RGB full range in DVI mode */
+  i2c_wr8_and_or(sd, VI_MODE, ~MASK_RGB_DVI, 0);
+
+  i2c_wr8_and_or(sd, VOUT_SET2, ~MASK_VOUTCOLORMODE, MASK_VOUTCOLORMODE_AUTO);
+  i2c_wr8(sd, VOUT_SET3, MASK_VOUT_EXTCNT);
+}
+
+/* --------------- IRQ --------------- */
+
+static void tc358743_format_change(struct v4l2_subdev *sd) {
+  struct tc358743_state *state = to_state(sd);
+  struct v4l2_dv_timings timings;
+  const struct v4l2_event tc358743_ev_fmt = {
+      .type = V4L2_EVENT_SOURCE_CHANGE,
+      .u.src_change.changes = V4L2_EVENT_SRC_CH_RESOLUTION,
+  };
+
+  v4l2_info(sd, "%s: Format changed\n", __func__);
+
+  if (tc358743_get_detected_timings(sd, &timings)) {
+    enable_stream(sd, false);
+
+    v4l2_info(sd, "%s: Format changed. No signal\n", __func__);
+  } else {
+    if (!v4l2_match_dv_timings(&state->timings, &timings, 0, false))
+      enable_stream(sd, false);
+
+    v4l2_print_dv_timings(
+        sd->name,
+        "tc358743_format_change: Format change`d. New format: ", &timings,
+        false);
+  }
+
+  if (sd->devnode) v4l2_subdev_notify_event(sd, &tc358743_ev_fmt);
+}
+
+static void tc358743_init_interrupts(struct v4l2_subdev *sd) {
+  u16 i;
+  v4l2_info(sd, "function %s\n", __func__);
+
+  /* clear interrupt status registers */
+  for (i = SYS_INT; i <= KEY_INT; i++) i2c_wr8(sd, i, 0xff);
+
+  i2c_wr16(sd, INTSTATUS, 0xffff);
+}
+
+static void tc358743_enable_interrupts(struct v4l2_subdev *sd,
+                                       bool cable_connected) {
+  v4l2_info(sd, "%s: cable connected = %d\n", __func__, cable_connected);
+
+  if (cable_connected) {
+    i2c_wr8(sd, SYS_INTM,
+            ~(MASK_M_DDC | MASK_M_DVI_DET | MASK_M_HDMI_DET) & 0xff);
+    i2c_wr8(sd, CLK_INTM, ~MASK_M_IN_DE_CHG);
+    i2c_wr8(sd, CBIT_INTM,
+            ~(MASK_M_CBIT_FS | MASK_M_AF_LOCK | MASK_M_AF_UNLOCK) & 0xff);
+    i2c_wr8(sd, AUDIO_INTM, ~MASK_M_BUFINIT_END);
+    i2c_wr8(sd, MISC_INTM, ~MASK_M_SYNC_CHG);
+  } else {
+    i2c_wr8(sd, SYS_INTM, ~MASK_M_DDC & 0xff);
+    i2c_wr8(sd, CLK_INTM, 0xff);
+    i2c_wr8(sd, CBIT_INTM, 0xff);
+    i2c_wr8(sd, AUDIO_INTM, 0xff);
+    i2c_wr8(sd, MISC_INTM, 0xff);
+  }
+}
+
+static void tc358743_hdmi_audio_int_handler(struct v4l2_subdev *sd,
+                                            bool *handled) {
+  u8 audio_int_mask = i2c_rd8(sd, AUDIO_INTM);
+  u8 audio_int = i2c_rd8(sd, AUDIO_INT) & ~audio_int_mask;
+
+  i2c_wr8(sd, AUDIO_INT, audio_int);
+
+  v4l2_info(sd, "%s: AUDIO_INT =0x%02x\n", __func__, audio_int);
+
+  tc358743_s_ctrl_audio_sampling_rate(sd);
+  tc358743_s_ctrl_audio_present(sd);
+}
+
+static void tc358743_csi_err_int_handler(struct v4l2_subdev *sd,
+                                         bool *handled) {
+  v4l2_err(sd, "%s: CSI_ERR =0x%x\n", __func__, i2c_rd32(sd, CSI_ERR));
+
+  i2c_wr32(sd, CSI_INT_CLR, MASK_ICRER);
+}
+
+static void tc358743_hdmi_misc_int_handler(struct v4l2_subdev *sd,
+                                           bool *handled) {
+  u8 misc_int_mask = i2c_rd8(sd, MISC_INTM);
+  u8 misc_int = i2c_rd8(sd, MISC_INT) & ~misc_int_mask;
+
+  i2c_wr8(sd, MISC_INT, misc_int);
+
+  v4l2_info(sd, "%s: MISC_INT =0x%02x\n", __func__, misc_int);
+
+  if (misc_int & MASK_I_SYNC_CHG) {
+    /* Reset the HDMI PHY to try to trigger proper lock on the
+     * incoming video format. Erase BKSV to prevent that old keys
+     * are used when a new source is connected. */
+    if (no_sync(sd) || no_signal(sd)) {
+      tc358743_reset_phy(sd);
+      tc358743_erase_bksv(sd);
+    }
+
+    tc358743_format_change(sd);
+
+    misc_int &= ~MASK_I_SYNC_CHG;
+    if (handled) *handled = true;
+  }
+
+  if (misc_int) {
+    v4l2_err(sd, "%s: Unhandled MISC_INT interrupts:0x%02x\n", __func__,
+             misc_int);
+  }
+}
+
+static void tc358743_hdmi_cbit_int_handler(struct v4l2_subdev *sd,
+                                           bool *handled) {
+  u8 cbit_int_mask = i2c_rd8(sd, CBIT_INTM);
+  u8 cbit_int = i2c_rd8(sd, CBIT_INT) & ~cbit_int_mask;
+
+  i2c_wr8(sd, CBIT_INT, cbit_int);
+
+  v4l2_info(sd, "%s: CBIT_INT =0x%02x\n", __func__, cbit_int);
+
+  if (cbit_int & MASK_I_CBIT_FS) {
+    v4l2_info(sd, "%s: Audio sample rate changed\n", __func__);
+    tc358743_s_ctrl_audio_sampling_rate(sd);
+
+    cbit_int &= ~MASK_I_CBIT_FS;
+    if (handled) *handled = true;
+  }
+
+  if (cbit_int & (MASK_I_AF_LOCK | MASK_I_AF_UNLOCK)) {
+    v4l2_info(sd, "%s: Audio present changed\n", __func__);
+    tc358743_s_ctrl_audio_present(sd);
+
+    cbit_int &= ~(MASK_I_AF_LOCK | MASK_I_AF_UNLOCK);
+    if (handled) *handled = true;
+  }
+
+  if (cbit_int) {
+    v4l2_err(sd, "%s: Unhandled CBIT_INT interrupts:0x%02x\n", __func__,
+             cbit_int);
+  }
+}
+
+static void tc358743_hdmi_clk_int_handler(struct v4l2_subdev *sd,
+                                          bool *handled) {
+  u8 clk_int_mask = i2c_rd8(sd, CLK_INTM);
+  u8 clk_int = i2c_rd8(sd, CLK_INT) & ~clk_int_mask;
+
+  /* Bit 7 and bit 6 are set even when they are masked */
+  i2c_wr8(sd, CLK_INT, clk_int | 0x80 | MASK_I_OUT_H_CHG);
+
+  v4l2_info(sd, "%s: CLK_INT =0x%02x\n", __func__, clk_int);
+
+  if (clk_int & (MASK_I_IN_DE_CHG)) {
+    v4l2_info(sd, "%s: DE size or position has changed\n", __func__);
+
+    /* If the source switch to a new resolution with the same pixel
+     * frequency as the existing (e.g. 1080p25 -> 720p50), the
+     * I_SYNC_CHG interrupt is not always triggered, while the
+     * I_IN_DE_CHG interrupt seems to work fine. Format change
+     * notifications are only sent when the signal is stable to
+     * reduce the number of notifications. */
+    if (!no_signal(sd) && !no_sync(sd)) tc358743_format_change(sd);
+
+    clk_int &= ~(MASK_I_IN_DE_CHG);
+    if (handled) *handled = true;
+  }
+
+  if (clk_int) {
+    v4l2_err(sd, "%s: Unhandled CLK_INT interrupts:0x%02x\n", __func__,
+             clk_int);
+  }
+}
+
+static void tc358743_enable_edid(struct v4l2_subdev *sd) {
+  struct tc358743_state *state = to_state(sd);
+
+  v4l2_info(sd, "%s\n", __func__);
+  if (state->edid_blocks_written == 0) {
+    v4l2_info(sd, "%s: no EDID -> no hotplug\n", __func__);
+    return;
+  }
+
+  v4l2_info(sd, "%s:\n", __func__);
+
+  /* Enable hotplug after 100 ms. DDC access to EDID is also enabled when
+   * hotplug is enabled. See register DDC_CTL */
+  queue_delayed_work(state->work_queues, &state->delayed_work_enable_hotplug,
+                     HZ / 10);
+
+  tc358743_enable_interrupts(sd, true);
+  tc358743_s_ctrl_detect_tx_5v(sd);
+  v4l2_info(sd, "%s completed successfully", __FUNCTION__);
+}
+
+static void tc358743_delayed_work_enable_interrupt(struct work_struct *work) {
+  struct delayed_work *dwork = to_delayed_work(work);
+  struct tc358743_state *state =
+      container_of(dwork, struct tc358743_state, delayed_work_enable_interrupt);
+  struct v4l2_subdev *sd = &state->sd;
+
+  v4l2_dbg(2, debug, sd, "%s:\n", __func__);
+
+  tc358743_enable_interrupts(sd, tx_5v_power_present(sd));
+
+  // /* Temporary EDID. Should be set by userspace */
+  // tc358743_s_edid(sd, &sd_edid);
+}
+
+static void tc358743_hdmi_sys_int_handler(struct v4l2_subdev *sd,
+                                          bool *handled) {
+  struct tc358743_state *state = to_state(sd);
+  u8 sys_int_mask = i2c_rd8(sd, SYS_INTM);
+  u8 sys_int = i2c_rd8(sd, SYS_INT) & ~sys_int_mask;
+
+  i2c_wr8(sd, SYS_INT, sys_int);
+
+  v4l2_info(sd, "%s: SYS_INT =0x%02x\n", __func__, sys_int);
+
+  if (sys_int & MASK_I_DDC) {
+    bool tx_5v = tx_5v_power_present(sd);
+
+    v4l2_info(sd, "%s: Tx 5V power present: %s\n", __func__,
+              tx_5v ? "yes" : "no");
+
+    if (tx_5v) {
+      tc358743_enable_edid(sd);
+    } else {
+      tc358743_enable_interrupts(sd, false);
+      tc358743_disable_edid(sd);
+      memset(&state->timings, 0, sizeof(state->timings));
+      tc358743_erase_bksv(sd);
+      tc358743_update_controls(sd);
+    }
+
+    sys_int &= ~MASK_I_DDC;
+    if (handled) *handled = true;
+  }
+
+  if (sys_int & MASK_I_DVI) {
+    v4l2_info(sd, "%s: HDMI->DVI change detected\n", __func__);
+
+    /* Reset the HDMI PHY to try to trigger proper lock on the
+     * incoming video format. Erase BKSV to prevent that old keys
+     * are used when a new source is connected. */
+    if (no_sync(sd) || no_signal(sd)) {
+      tc358743_reset_phy(sd);
+      tc358743_erase_bksv(sd);
+    }
+
+    sys_int &= ~MASK_I_DVI;
+    if (handled) *handled = true;
+  }
+
+  if (sys_int & MASK_I_HDMI) {
+    v4l2_info(sd, "%s: DVI->HDMI change detected\n", __func__);
+
+    /* Register is reset in DVI mode (REF_01, c. 6.6.41) */
+    i2c_wr8(sd, ANA_CTL, MASK_APPL_PCSX_NORMAL | MASK_ANALOG_ON);
+
+    sys_int &= ~MASK_I_HDMI;
+    if (handled) *handled = true;
+  }
+
+  if (sys_int) {
+    v4l2_err(sd, "%s: Unhandled SYS_INT interrupts:0x%02x\n", __func__,
+             sys_int);
+  }
+}
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+static void tc358743_print_register_map(struct v4l2_subdev *sd) {
+  v4l2_info(sd, "0x00000x00FF: Global Control Register\n");
+  v4l2_info(sd, "0x01000x01FF: CSI2-TX PHY Register\n");
+  v4l2_info(sd, "0x02000x03FF: CSI2-TX PPI Register\n");
+  v4l2_info(sd, "0x04000x05FF: Reserved\n");
+  v4l2_info(sd, "0x06000x06FF: CEC Register\n");
+  v4l2_info(sd, "0x07000x84FF: Reserved\n");
+  v4l2_info(sd, "0x85000x85FF: HDMIRX System Control Register\n");
+  v4l2_info(sd, "0x86000x86FF: HDMIRX Audio Control Register\n");
+  v4l2_info(sd, "0x87000x87FF: HDMIRX InfoFrame packet data Register\n");
+  v4l2_info(sd, "0x88000x88FF: HDMIRX HDCP Port Register\n");
+  v4l2_info(sd, "0x89000x89FF: HDMIRX Video Output Port & 3D Register\n");
+  v4l2_info(sd, "0x8A000x8BFF: Reserved\n");
+  v4l2_info(sd, "0x8C000x8FFF: HDMIRX EDID-RAM (1024bytes)\n");
+  v4l2_info(sd, "0x90000x90FF: HDMIRX GBD Extraction Control\n");
+  v4l2_info(sd, "0x91000x92FF: HDMIRX GBD RAM read\n");
+  v4l2_info(sd, "0x9300-      : Reserved\n");
+}
+
+static int tc358743_get_reg_size(u16 address) {
+  /* REF_01 p. 66-72 */
+  if (address <= 0x00ff)
+    return 2;
+  else if ((address >= 0x0100) && (address <= 0x06FF))
+    return 4;
+  else if ((address >= 0x0700) && (address <= 0x84ff))
+    return 2;
+  else
+    return 1;
+}
+
+static int tc358743_g_register(struct v4l2_subdev *sd,
+                               struct v4l2_dbg_register *reg) {
+  if (reg->reg > 0xffff) {
+    tc358743_print_register_map(sd);
+    return -EINVAL;
+  }
+
+  reg->size = tc358743_get_reg_size(reg->reg);
+
+  i2c_rd(sd, reg->reg, (u8 *)&reg->val, reg->size);
+
+  return 0;
+}
+
+static int tc358743_s_register(struct v4l2_subdev *sd,
+                               const struct v4l2_dbg_register *reg) {
+  if (reg->reg > 0xffff) {
+    tc358743_print_register_map(sd);
+    return -EINVAL;
+  }
+
+  /* It should not be possible for the user to enable HDCP with a simple
+   * v4l2-dbg command.
+   *
+   * DO NOT REMOVE THIS unless all other issues with HDCP have been
+   * resolved.
+   */
+  if (reg->reg == HDCP_MODE || reg->reg == HDCP_REG1 || reg->reg == HDCP_REG2 ||
+      reg->reg == HDCP_REG3 || reg->reg == BCAPS)
+    return 0;
+
+  i2c_wr(sd, (u16)reg->reg, (u8 *)&reg->val, tc358743_get_reg_size(reg->reg));
+
+  return 0;
+}
+#endif
+
+static int tc358743_isr(struct v4l2_subdev *sd, u32 status, bool *handled) {
+  u16 intstatus = i2c_rd16(sd, INTSTATUS);
+
+  if (intstatus & MASK_HDMI_INT) {
+    u8 hdmi_int0 = i2c_rd8(sd, HDMI_INT0);
+    u8 hdmi_int1 = i2c_rd8(sd, HDMI_INT1);
+
+    if (hdmi_int0 & MASK_I_MISC) tc358743_hdmi_misc_int_handler(sd, handled);
+    if (hdmi_int1 & MASK_I_CBIT) tc358743_hdmi_cbit_int_handler(sd, handled);
+    if (hdmi_int1 & MASK_I_CLK) tc358743_hdmi_clk_int_handler(sd, handled);
+    if (hdmi_int1 & MASK_I_SYS) tc358743_hdmi_sys_int_handler(sd, handled);
+    if (hdmi_int1 & MASK_I_AUD) tc358743_hdmi_audio_int_handler(sd, handled);
+
+    i2c_wr16(sd, INTSTATUS, MASK_HDMI_INT);
+    intstatus &= ~MASK_HDMI_INT;
+  }
+
+  if (intstatus & MASK_CSI_INT) {
+    u32 csi_int = i2c_rd32(sd, CSI_INT);
+
+    if (csi_int & MASK_INTER) tc358743_csi_err_int_handler(sd, handled);
+
+    i2c_wr16(sd, INTSTATUS, MASK_CSI_INT);
+    intstatus &= ~MASK_CSI_INT;
+  }
+
+  intstatus = i2c_rd16(sd, INTSTATUS);
+  if (intstatus) {
+    v4l2_info(sd, "%s: Unhandled IntStatus interrupts:0x%02x\n", __func__,
+              intstatus);
+  }
+
+  return 0;
+}
+
+static void tc358743_process_isr(struct work_struct *work) {
+  struct tc358743_state *state =
+      container_of(work, struct tc358743_state, process_isr);
+  struct v4l2_subdev *sd = &state->sd;
+  bool handled;
+
+  v4l2_dbg(2, debug, sd, "%s:\n", __func__);
+
+  mutex_lock(&state->isr_lock);
+  tc358743_isr(sd, 0, &handled);
+  mutex_unlock(&state->isr_lock);
+}
+
+static irqreturn_t tc358743_irq_handler(int irq, void *dev_id) {
+  struct tc358743_state *state = dev_id;
+
+  queue_work(state->work_queues, &state->process_isr);
+
+  return IRQ_HANDLED;
+}
+
+static int tc358743_subscribe_event(struct v4l2_subdev *sd, struct v4l2_fh *fh,
+                                    struct v4l2_event_subscription *sub) {
+  v4l2_info(sd, "Calling %s\n", __FUNCTION__);
+  switch (sub->type) {
+    case V4L2_EVENT_SOURCE_CHANGE:
+      return v4l2_src_change_event_subdev_subscribe(sd, fh, sub);
+    case V4L2_EVENT_CTRL:
+      return v4l2_ctrl_subdev_subscribe_event(sd, fh, sub);
+    default:
+      return -EINVAL;
+  }
+}
+
+/* --------------- VIDEO OPS --------------- */
+
+static int tc358743_s_dv_timings(struct v4l2_subdev *sd,
+                                 struct v4l2_dv_timings *timings) {
+  struct tc358743_state *state = to_state(sd);
+  v4l2_info(sd, "1111 %s\n", __func__);
+  if (!timings) return -EINVAL;
+
+  if (v4l2_match_dv_timings(&state->timings, timings, 0, false)) {
+    v4l2_info(sd, "%s: no change\n", __func__);
+    return 0;
+  }
+
+  if (!v4l2_valid_dv_timings(timings, &tc358743_timings_cap, NULL, NULL)) {
+    v4l2_err(sd, "%s: timings out of range\n", __func__);
+    return -ERANGE;
+  }
+
+  state->timings = *timings;
+
+  enable_stream(sd, false);
+  tc358743_set_pll(sd);
+  tc358743_set_csi(sd);
+  v4l2_info(sd, "2222 %s\n", __func__);
+  return 0;
+}
+
+static int tc358743_g_dv_timings(struct v4l2_subdev *sd,
+                                 struct v4l2_dv_timings *timings) {
+  struct tc358743_state *state = to_state(sd);
+  v4l2_info(sd, "Calling %s\n", __FUNCTION__);
+  if (state) {
+    *timings = state->timings;
+    return 0;
+  }
+  return -EINVAL;
+}
+
+static int tc358743_enum_dv_timings(struct v4l2_subdev *sd,
+                                    struct v4l2_enum_dv_timings *timings) {
+  v4l2_info(sd, "Calling %s\n", __FUNCTION__);
+  if (timings && timings->pad != 0) {
+    v4l2_err(sd, "%s: failed %d\n", __func__, EINVAL);
+    return -EINVAL;
+  }
+
+  return v4l2_enum_dv_timings_cap(timings, &tc358743_timings_cap, NULL, NULL);
+}
+
+static int tc358743_query_dv_timings(struct v4l2_subdev *sd,
+                                     struct v4l2_dv_timings *timings) {
+  int ret;
+  v4l2_info(sd, "Calling %s\n", __FUNCTION__);
+
+  ret = tc358743_get_detected_timings(sd, timings);
+  if (ret) {
+    v4l2_err(sd, "%s: @@@@@ timings detected error\n", __func__);
+    return ret;
+  }
+
+  if (debug)
+    v4l2_print_dv_timings(sd->name, "tc358743_query_dv_timings: ", timings,
+                          false);
+
+  if (!v4l2_valid_dv_timings(timings, &tc358743_timings_cap, NULL, NULL)) {
+    v4l2_err(sd, "%s: @@@@@ timings out of range\n", __func__);
+    return -ERANGE;
+  }
+
+  return 0;
+}
+
+static int tc358743_g_input_status(struct v4l2_subdev *sd, u32 *status) {
+  struct tc358743_state *state = to_state(sd);
+  struct v4l2_dv_timings *timings = &(state->timings);
+
+  v4l2_info(sd, "Calling %s\n", __FUNCTION__);
+  *status = 0;
+  *status |= no_signal(sd) ? V4L2_IN_ST_NO_SIGNAL : 0;
+  *status |= no_sync(sd) ? V4L2_IN_ST_NO_SYNC : 0;
+
+  v4l2_info(sd, "%s: status =0x%x\n", __func__, *status);
+
+  v4l2_info(sd, "Now getting and setting dv timings");
+  tc358743_query_dv_timings(sd, timings);
+  tc358743_s_dv_timings(sd, timings);
+
+  return 0;
+}
+
+static int tc358743_dv_timings_cap(struct v4l2_subdev *sd,
+                                   struct v4l2_dv_timings_cap *cap) {
+  v4l2_info(sd, "Calling %s\n", __FUNCTION__);
+  if (cap && cap->pad != 0) return -EINVAL;
+
+  *cap = tc358743_timings_cap;
+
+  return 0;
+}
+
+static int tc358743_g_mbus_config(struct v4l2_subdev *sd,
+                                  unsigned int pad,
+                                  struct v4l2_mbus_config *cfg) {
+  v4l2_info(sd, "Calling %s\n", __FUNCTION__);
+//  cfg->type = V4L2_MBUS_CSI2;
+  cfg->type = V4L2_MBUS_CSI2_DPHY;
+
+  /* Support for non-continuous CSI-2 clock is missing in the driver */
+  cfg->flags = V4L2_MBUS_CSI2_CONTINUOUS_CLOCK;
+
+  switch (tc358743_num_csi_lanes_in_use(sd)) {
+    case 1:
+      cfg->flags |= V4L2_MBUS_CSI2_1_LANE;
+      break;
+    case 2:
+      cfg->flags |= V4L2_MBUS_CSI2_2_LANE;
+      break;
+    case 3:
+      cfg->flags |= V4L2_MBUS_CSI2_3_LANE;
+      break;
+    case 4:
+      cfg->flags |= V4L2_MBUS_CSI2_4_LANE;
+      break;
+    default:
+      return -EINVAL;
+  }
+
+  return 0;
+}
+
+static int tc358743_s_stream(struct v4l2_subdev *sd, int enable) {
+  v4l2_info(sd, "Calling %s\n", __FUNCTION__);
+  enable_stream(sd, true);
+  return 0;
+}
+
+/* --------------- PAD OPS --------------- */
+
+static int tc358743_get_fmt(struct v4l2_subdev *sd,
+                            struct v4l2_subdev_state *sd_state,
+                            struct v4l2_subdev_format *format) {
+  struct tc358743_state *state = to_state(sd);
+  u8 vi_rep = i2c_rd8(sd, VI_REP);
+  v4l2_info(sd, "Calling %s\n", __FUNCTION__);
+
+  if (format->pad != 0) {
+    v4l2_err(sd, "%s Error\n", __FUNCTION__);
+    return -EINVAL;
+  }
+
+  format->format.code = state->mbus_fmt_code;
+  format->format.width = state->timings.bt.width;
+  format->format.height = state->timings.bt.height;
+  format->format.field = V4L2_FIELD_NONE;
+
+  switch (vi_rep & MASK_VOUT_COLOR_SEL) {
+    case MASK_VOUT_COLOR_RGB_FULL:
+    case MASK_VOUT_COLOR_RGB_LIMITED:
+      format->format.colorspace = V4L2_COLORSPACE_SRGB;
+      break;
+    case MASK_VOUT_COLOR_601_YCBCR_LIMITED:
+    case MASK_VOUT_COLOR_601_YCBCR_FULL:
+      v4l2_info(sd, "Here 6b, colorspace: %d\n", V4L2_COLORSPACE_SMPTE170M);
+      format->format.colorspace = V4L2_COLORSPACE_SMPTE170M;
+      break;
+    case MASK_VOUT_COLOR_709_YCBCR_FULL:
+    case MASK_VOUT_COLOR_709_YCBCR_LIMITED:
+      format->format.colorspace = V4L2_COLORSPACE_REC709;
+      break;
+    default:
+      format->format.colorspace = 0;
+      v4l2_info(sd, "%d:%s colorspace = 0\n", __LINE__, __FUNCTION__);
+      break;
+  }
+
+  v4l2_info(sd, "get fmt complete\n");
+  v4l2_info(sd, "format width %d\n", format->format.width);
+  v4l2_info(sd, "format height %d\n", format->format.height);
+
+  v4l2_info(sd, "fmt_code: %d\n", format->format.code);
+  v4l2_info(sd, "RGB888 code: %d\n", MEDIA_BUS_FMT_RGB888_1X24);
+  v4l2_info(sd, "UYVY8 code: %d\n", MEDIA_BUS_FMT_UYVY8_1X16);
+  return 0;
+}
+
+static int tc358743_set_fmt(struct v4l2_subdev *sd,
+                            struct v4l2_subdev_state *sd_state,
+                            struct v4l2_subdev_format *format) {
+  struct tc358743_state *state = to_state(sd);
+  u32 code = format->format.code;
+  int ret = tc358743_get_fmt(sd, sd_state, format);
+
+  v4l2_dbg(3, debug, sd, "%s(), ret: %d\n", __func__, ret);
+  v4l2_dbg(3, debug, sd, "Set format code: %d\n", code);
+
+  format->format.code = code;
+
+  if (ret) return ret;
+
+  switch (code) {
+    case MEDIA_BUS_FMT_RGB888_1X24:
+    case MEDIA_BUS_FMT_UYVY8_1X16:
+      v4l2_dbg(3, debug, sd, "Good code %d\n", code);
+      break;
+    default:
+      v4l2_err(sd, "Bad code %d\n", code);
+      return -EINVAL;
+  }
+
+  if (format->which == V4L2_SUBDEV_FORMAT_TRY) return 0;
+
+  state->mbus_fmt_code = format->format.code;
+
+  enable_stream(sd, false);
+  tc358743_set_pll(sd);
+  tc358743_set_csi(sd);
+  tc358743_set_csi_color_space(sd);
+  v4l2_info(sd, "Called %s, completed successfully\n", __FUNCTION__);
+  return 0;
+}
+
+static int tc358743_g_edid(struct v4l2_subdev *sd,
+                           struct v4l2_subdev_edid *edid) {
+  struct tc358743_state *state = to_state(sd);
+  // int i=0;
+  v4l2_info(sd, "Calling %s\n", __FUNCTION__);
+
+  if (edid->pad != 0) return -EINVAL;
+
+  if (edid->start_block == 0 && edid->blocks == 0) {
+    edid->blocks = state->edid_blocks_written;
+    return 0;
+  }
+
+  if (state->edid_blocks_written == 0) return -ENODATA;
+
+  if (edid->start_block >= state->edid_blocks_written || edid->blocks == 0)
+    return -EINVAL;
+
+  if (edid->start_block + edid->blocks > state->edid_blocks_written)
+    edid->blocks = state->edid_blocks_written - edid->start_block;
+
+  i2c_rd(sd, EDID_RAM + (edid->start_block * EDID_BLOCK_SIZE), edid->edid,
+         edid->blocks * EDID_BLOCK_SIZE);
+  v4l2_info(sd, "EDID_RAM has %d byte from: 0x%04x to 0x%04x \r\n",
+            edid->blocks * EDID_BLOCK_SIZE,
+            EDID_RAM + (edid->start_block * EDID_BLOCK_SIZE),
+            EDID_RAM + (edid->start_block * EDID_BLOCK_SIZE) +
+                edid->blocks * EDID_BLOCK_SIZE);
+  // for(i=0;i<edid->blocks * EDID_BLOCK_SIZE;i++){
+  // 	printk("%02x ",edid->edid[i]);
+  // }
+  // v4l2_info(sd,"\r\n");
+  v4l2_info(sd, "%s completed successfully", __FUNCTION__);
+  return 0;
+}
+
+static int tc358743_s_edid(struct v4l2_subdev *sd,
+                           struct v4l2_subdev_edid *edid) {
+  struct tc358743_state *state = to_state(sd);
+  u16 edid_len = edid->blocks * EDID_BLOCK_SIZE;
+
+  v4l2_info(sd, "%s, pad %d, start block %d, blocks %d\n", __func__, edid->pad,
+            edid->start_block, edid->blocks);
+
+  if (edid->pad != 0) return -EINVAL;
+
+  if (edid->start_block != 0) return -EINVAL;
+
+  if (edid->blocks > EDID_NUM_BLOCKS_MAX) {
+    edid->blocks = EDID_NUM_BLOCKS_MAX;
+    return -E2BIG;
+  }
+
+  tc358743_disable_edid(sd);
+
+  i2c_wr8(sd, EDID_LEN1, edid_len & 0xff);
+  i2c_wr8(sd, EDID_LEN2, edid_len >> 8);
+
+  if (edid->blocks == 0) {
+    state->edid_blocks_written = 0;
+    return 0;
+  }
+  i2c_wr(sd, EDID_RAM, edid->edid, edid_len);
+  /* richardyou
+  for (i=0; i<edid_len; i++) {
+          i2c_wr8(sd, EDID_RAM + i, edid->edid[i]);
+  }
+  */
+  state->edid_blocks_written = edid->blocks;
+
+  //	if (tx_5v_power_present(sd))
+  tc358743_enable_edid(sd);
+
+  v4l2_info(sd, "%s completed successfully", __FUNCTION__);
+  return 0;
+}
+
+// static int tc358743_mbus_fmt(struct v4l2_subdev *sd,
+//                              struct v4l2_mbus_framefmt *mf) {
+//   struct tc358743_state *state = to_state(sd);
+//   u8 vi_rep = i2c_rd8(sd, VI_REP);
+
+//   mf->code = state->mbus_fmt_code;
+//   mf->width = state->timings.bt.width;
+//   mf->height = state->timings.bt.height;
+//   mf->field = V4L2_FIELD_NONE;
+//   switch (vi_rep & MASK_VOUT_COLOR_SEL) {
+//     case MASK_VOUT_COLOR_RGB_FULL:
+//     case MASK_VOUT_COLOR_RGB_LIMITED:
+//       mf->colorspace = V4L2_COLORSPACE_SRGB;
+//       break;
+//     case MASK_VOUT_COLOR_601_YCBCR_LIMITED:
+//     case MASK_VOUT_COLOR_601_YCBCR_FULL:
+//       mf->colorspace = V4L2_COLORSPACE_SMPTE170M;
+//       break;
+//     case MASK_VOUT_COLOR_709_YCBCR_FULL:
+//     case MASK_VOUT_COLOR_709_YCBCR_LIMITED:
+//       mf->colorspace = V4L2_COLORSPACE_REC709;
+//       break;
+//     default:
+//       mf->colorspace = 0;
+//       break;
+//   }
+//   return 0;
+// }
+
+static int tc358743_enum_mbus_code(struct v4l2_subdev *sd,
+                                   struct v4l2_subdev_state *sd_state,
+                                   struct v4l2_subdev_mbus_code_enum *code) {
+  v4l2_info(sd, "%s()\n", __func__);
+
+  //	if (code->index >= 2) {
+  //		v4l2_err(sd, "Error in %s\n", __FUNCTION__);
+  //		return -EINVAL;
+  //	}
+
+  switch (code->index) {
+    case 0:
+      code->code = MEDIA_BUS_FMT_RGB888_1X24;
+      break;
+    case 1:
+      code->code = MEDIA_BUS_FMT_UYVY8_1X16;
+      break;
+
+    default:
+      return -EINVAL;
+  }
+
+  v4l2_info(sd, "Mbus code found succsefully (%d: %d)", code->index,
+            code->code);
+
+  return 0;
+}
+
+static int tc358743_enum_frame_size(struct v4l2_subdev *sd,
+                                    struct v4l2_subdev_state *sd_state,
+                                    struct v4l2_subdev_frame_size_enum *fse) {
+  const struct camera_common_frmfmt *frmfmt = tc358743_frmfmt;
+  int num_frmfmt = ARRAY_SIZE(tc358743_frmfmt);
+
+  v4l2_info(sd, "%s()\n", __func__);
+  v4l2_info(sd, "fse->code %d, index %d\n", fse->code, fse->index);
+  v4l2_info(sd, "----------------------------------------\n");
+
+  // fse->min_width  = fse->max_width  = 1280;
+  // fse->min_height = fse->max_height = 720;
+
+  v4l2_info(sd,
+            "Trying to find frmfmt that matches fse->code, code: %d (UYVY: %d, "
+            "ARGB32: %d, MEDIA_BUS_FMT_UYVY8_1X16: %d, "
+            "MEDIA_BUS_FMT_RGB888_1X24: %d)\n",
+            fse->code, V4L2_PIX_FMT_UYVY, V4L2_PIX_FMT_ABGR32,
+            MEDIA_BUS_FMT_UYVY8_1X16, MEDIA_BUS_FMT_RGB888_1X24);
+
+  if (fse->code != MEDIA_BUS_FMT_UYVY8_1X16 &&
+      fse->code != V4L2_PIX_FMT_ABGR32 &&
+      fse->code != MEDIA_BUS_FMT_UYVY8_1X16) {
+    v4l2_err(sd, "Error in %s fse->code, code: %d, UYVY: %d, ARGB32: %d\n",
+             __FUNCTION__, fse->code, V4L2_PIX_FMT_UYVY, V4L2_PIX_FMT_ABGR32);
+    return -EINVAL;
+  }
+
+  v4l2_info(sd, "Code ok");
+
+  if (fse->index >= num_frmfmt) {
+    v4l2_err(sd, "Error in %s, %d outside of num_frmfmt (%d)", __FUNCTION__,
+             fse->index, num_frmfmt);
+    return -EINVAL;
+  }
+
+  v4l2_info(sd, "Index ok");
+
+  fse->min_width = fse->max_width = frmfmt[fse->index].size.width;
+  fse->min_height = fse->max_height = frmfmt[fse->index].size.height;
+  v4l2_info(sd, "!!!!!!!!! %s() complete successfully, width: %d, height: %d\n",
+            __func__, fse->min_width, fse->min_height);
+  return 0;
+}
+
+static int tc358743_enum_frame_interval(
+    struct v4l2_subdev *sd, struct v4l2_subdev_state *sd_state,
+    struct v4l2_subdev_frame_interval_enum *fie) {
+  const struct camera_common_frmfmt *frmfmt = tc358743_frmfmt;
+  int num_frmfmt = ARRAY_SIZE(tc358743_frmfmt);
+  int i;
+
+  v4l2_info(sd, "%s()\n", __func__);
+  v4l2_info(sd, "----------------------------------------\n");
+
+  v4l2_info(sd,
+            "Trying to find frame interfval that matches fie->code, code: %d "
+            "(UYVY: %d, ARGB32: %d, MEDIA_BUS_FMT_UYVY8_1X16: %d)\n",
+            fie->code, V4L2_PIX_FMT_UYVY, V4L2_PIX_FMT_ABGR32,
+            MEDIA_BUS_FMT_UYVY8_1X16);
+
+  if (fie->code != V4L2_PIX_FMT_UYVY && fie->code != V4L2_PIX_FMT_ABGR32 &&
+      fie->code != MEDIA_BUS_FMT_UYVY8_1X16) {
+    v4l2_err(sd, "Unexpected code (%d), UYUV: %d, ABGR32: %d\n", fie->code,
+             V4L2_PIX_FMT_UYVY, V4L2_PIX_FMT_ABGR32);
+    return -EINVAL;
+  }
+
+  v4l2_info(sd, "Code ok");
+
+  for (i = 0; i < num_frmfmt; i++) {
+    if (frmfmt[i].size.width == fie->width &&
+        frmfmt[i].size.height == fie->height) {
+      v4l2_info(sd, "Matched width %d and %d, height %d and %d",
+                frmfmt[i].size.width, fie->width, frmfmt[i].size.height,
+                fie->height);
+      break;
+    }
+  }
+
+  v4l2_info(sd, "w/h ok or end (i=%d, num=%d)", i, num_frmfmt);
+
+  if (i >= num_frmfmt) {
+    v4l2_err(sd, "Error in %s, num frmfmt\n", __FUNCTION__);
+    return -EINVAL;
+  }
+
+  v4l2_info(sd, "i ok");
+
+  if (fie->index >= frmfmt[i].num_framerates) {
+    v4l2_err(sd, "Error in %s num framerates (%d outside %d)\n", __FUNCTION__,
+             fie->index, frmfmt[i].num_framerates);
+    return -EINVAL;
+  }
+
+  v4l2_info(sd, "index ok");
+
+  fie->interval.numerator = 1;
+  fie->interval.denominator = frmfmt[i].framerates[fie->index];
+                                             
+  v4l2_info(sd, "!!!!!!!!!! %s() completed successfully, interval: 1/%d\n",
+            __func__, fie->interval.denominator);
+  return 0;
+}
+
+static int tc358743_s_power(struct v4l2_subdev *sd, int on) {
+  v4l2_info(sd, "function %s\n", __func__);
+
+  return 0;
+}
+
+static const struct v4l2_subdev_core_ops tc358743_core_ops = {
+    .s_power = tc358743_s_power,
+    .log_status = tc358743_log_status,
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+    .g_register = tc358743_g_register,
+    .s_register = tc358743_s_register,
+#endif
+    .interrupt_service_routine = tc358743_isr,
+    .subscribe_event = tc358743_subscribe_event,
+    .unsubscribe_event = v4l2_event_subdev_unsubscribe,
+};
+
+static const struct v4l2_subdev_video_ops tc358743_video_ops = {
+    .g_input_status = tc358743_g_input_status,
+    .s_dv_timings = tc358743_s_dv_timings,
+    .g_dv_timings = tc358743_g_dv_timings,
+    .s_stream = tc358743_s_stream,
+    // .mbus_fmt = tc358743_mbus_fmt,
+    //.g_mbus_config = tc358743_g_mbus_config,
+    .query_dv_timings = tc358743_query_dv_timings,
+};
+
+static const struct v4l2_subdev_pad_ops tc358743_pad_ops = {
+    .set_fmt = tc358743_set_fmt,
+    .get_fmt = tc358743_get_fmt,
+    .get_edid = tc358743_g_edid,
+    .set_edid = tc358743_s_edid,
+    .dv_timings_cap = tc358743_dv_timings_cap,
+    .get_mbus_config = tc358743_g_mbus_config,
+
+    .enum_dv_timings = tc358743_enum_dv_timings,
+    .enum_mbus_code = tc358743_enum_mbus_code,
+    .enum_frame_size = tc358743_enum_frame_size,
+    .enum_frame_interval = tc358743_enum_frame_interval,
+};
+
+static const struct v4l2_subdev_ops tc358743_ops = {
+    .core = &tc358743_core_ops,
+    .video = &tc358743_video_ops,
+    .pad = &tc358743_pad_ops,
+};
+/* --------------- CUSTOM CTRLS --------------- */
+
+static const struct v4l2_ctrl_config tc358743_ctrl_audio_sampling_rate = {
+    .id = TC358743_CID_AUDIO_SAMPLING_RATE,
+    .name = "Audio sampling rate",
+    .type = V4L2_CTRL_TYPE_INTEGER,
+    .min = 0,
+    .max = 768000,
+    .step = 1,
+    .def = 0,
+    .flags = V4L2_CTRL_FLAG_READ_ONLY,
+};
+
+static const struct v4l2_ctrl_config tc358743_ctrl_audio_present = {
+    .id = TC358743_CID_AUDIO_PRESENT,
+    .name = "Audio present",
+    .type = V4L2_CTRL_TYPE_BOOLEAN,
+    .min = 0,
+    .max = 1,
+    .step = 1,
+    .def = 0,
+    .flags = V4L2_CTRL_FLAG_READ_ONLY,
+};
+
+static bool tc358743_parse_dt(struct tc358743_platform_data *pdata,
+                              struct i2c_client *client) {
+  struct device_node *node = client->dev.of_node;
+  const u32 *property;
+  pr_info("%s\n", __FUNCTION__);
+  pr_info("Device Tree Parameters:\n");
+
+  pdata->reset_gpio = of_get_named_gpio(node, "reset-gpios", 0);
+  if (pdata->reset_gpio == 0) return false;
+  pr_info("reset_gpio = %d\n", pdata->reset_gpio);
+
+  property = of_get_property(node, "refclk_hz", NULL);
+  if (property == NULL) return false;
+  pdata->refclk_hz = be32_to_cpup(property);
+  pr_info("refclk_hz = %d\n", be32_to_cpup(property));
+
+  return true;
+}
+
+#ifdef CONFIG_OF
+static void tc358743_gpio_reset(struct tc358743_state *state) {
+  usleep_range(5000, 10000);
+  // TODO: Re-implement the reset GPIO!
+  gpiod_set_value(state->reset_gpio, 0);
+  // gpio_set_value((int)state->reset_gpio, 1);
+  usleep_range(1000, 2000);
+  // gpio_set_value((int)state->reset_gpio, 0);
+  gpiod_set_value(state->reset_gpio, 1);
+  msleep(20);
+}
+
+static int tc358743_probe_of(struct tc358743_state *state) {
+  struct device *dev = &state->i2c_client->dev;
+//  struct v4l2_of_endpoint *endpoint;
+  struct v4l2_fwnode_endpoint endpoint = { .bus_type = 0 };
+
+  struct device_node *ep;
+  u32 bps_pr_lane;
+  int ret = -EINVAL;
+  pr_info("%s\n", __FUNCTION__);
+
+  if ((state->pdata.refclk_hz != 26000000) &&
+      (state->pdata.refclk_hz != 27000000) &&
+      (state->pdata.refclk_hz != 42000000)) {
+    pr_info("refclk_hz error \n");
+    return ret;
+  }
+
+  ep = of_graph_get_next_endpoint(dev->of_node, NULL);
+  if (!ep) {
+    dev_err(dev, "missing endpoint node\n");
+    return -EINVAL;
+  }
+
+/*  endpoint = v4l2_of_alloc_parse_endpoint(ep);
+  if (IS_ERR(endpoint)) {
+    dev_err(dev, "failed to parse endpoint\n");
+    return PTR_ERR(endpoint);
+  }*/
+
+  ret = v4l2_fwnode_endpoint_alloc_parse(of_fwnode_handle(ep), &endpoint);
+  if (ret) {
+      dev_err(dev, "failed to parse endpoint\n");
+      goto put_node;
+  }
+
+
+//  if (endpoint->bus_type != V4L2_MBUS_CSI2 ||
+
+  if (endpoint.bus_type != V4L2_MBUS_CSI2_DPHY ||
+      endpoint.bus.mipi_csi2.num_data_lanes == 0 ||
+      endpoint.nr_of_link_frequencies == 0) {
+    dev_err(dev, "missing CSI-2 properties in endpoint\n");
+    goto free_endpoint;
+  }
+
+  pr_info("tc358743 endpoint.bus.mipi_csi2.flags %d\n",
+          endpoint.bus.mipi_csi2.flags);
+  pr_info("tc358743 endpoint.bus.mipi_csi2.clock_lane %d\n",
+          endpoint.bus.mipi_csi2.clock_lane);
+  pr_info("tc358743 endpoint.bus.mipi_csi2.num_data_lanes %d\n",
+          endpoint.bus.mipi_csi2.num_data_lanes);
+  pr_info("tc358743 endpoint.bus.mipi_csi2.data_lanes [%d-%d-%d-%d]\n",
+          endpoint.bus.mipi_csi2.data_lanes[0],
+          endpoint.bus.mipi_csi2.data_lanes[1],
+          endpoint.bus.mipi_csi2.data_lanes[2],
+          endpoint.bus.mipi_csi2.data_lanes[3]);
+  pr_info("tc358743 endpoint.nr_of_link_frequencies %d\n",
+          endpoint.nr_of_link_frequencies);
+
+  state->pdata.ddc5v_delay = DDC5V_DELAY_100_MS;
+  state->pdata.hdmi_detection_delay = HDMI_MODE_DELAY_100_MS;
+  state->pdata.enable_hdcp = false;
+  /* A FIFO level of 16 should be enough for 2-lane 720p60 at 594 MHz. */
+  state->pdata.fifo_level = 16;
+  /*
+   * The PLL input clock is obtained by dividing refclk by pll_prd.
+   * It must be between 6 MHz and 40 MHz, lower frequency is better.
+   */
+  switch (state->pdata.refclk_hz) {
+      //~ case 26322581:
+      //~ state->pdata.refclk_hz = 26322581;
+    case 26000000:
+    case 27000000:
+    //~ case 40800000: /* Tegra */
+    case 42000000:
+      state->pdata.pll_prd = state->pdata.refclk_hz / 6000000;
+      break;
+    default:
+      dev_err(dev,"Unsupported refclk rate: %u Hz\n", state->pdata.refclk_hz);
+      goto disable_clk;
+  }
+dev_err(dev, "HERE #1\n");
+  /*
+   * The CSI bps per lane must be between 62.5 Mbps and 1 Gbps.
+   * The default is 594 Mbps for 4-lane 1080p60 or 2-lane 720p60.
+   */
+  bps_pr_lane = 2 * endpoint.link_frequencies[0];
+  // if (bps_pr_lane < 62500000U || bps_pr_lane > 1000000000U) {
+  if (bps_pr_lane < 62500000U || bps_pr_lane > 1188000000U) {
+    dev_err(dev, "unsupported bps per lane: %u bps\n", bps_pr_lane);
+    goto disable_clk;
+  }
+dev_err(dev, "HERE #2\n");
+  /* The CSI speed per lane is refclk / pll_prd * pll_fbd */
+  state->pdata.pll_fbd =
+      bps_pr_lane / state->pdata.refclk_hz * state->pdata.pll_prd;
+
+  /*
+   * FIXME: These timings are from REF_02 for 594 Mbps per lane (297 MHz
+   * link frequency). In principle it should be possible to calculate
+   * them based on link frequency and resolution.
+   */
+  if (bps_pr_lane != 594000000U)
+    dev_warn(dev, "untested bps per lane: %u bps\n", bps_pr_lane);
+  pr_info("tc358743 state->pdata.pll_prd=%d\r\n", state->pdata.pll_prd);
+  pr_info("tc358743 state->pdata.pll_fbd=%d\r\n", state->pdata.pll_fbd);
+dev_err(dev, "HERE #3\n");
+  // freq = refclk / prd * fbd, default = 594 MHz
+//  state->pdata.lineinitcnt = 0xe80;
+//  state->pdata.lptxtimecnt = 0x003;
+//  /* tclk-preparecnt: 3, tclk-zerocnt: 20 */
+//  state->pdata.tclk_headercnt = 0x1403;
+//  state->pdata.tclk_trailcnt = 0x00;
+//  /* ths-preparecnt: 3, ths-zerocnt: 1 */
+//  state->pdata.ths_headercnt = 0x0103;
+//  state->pdata.twakeup = 0x4882;
+//  state->pdata.tclk_postcnt = 0x008;
+//  state->pdata.ths_trailcnt = 0x2;
+//  state->pdata.hstxvregcnt = 2;
+
+  state->pdata.lineinitcnt = 0x1d01;//
+  state->pdata.lptxtimecnt = 0x008;//
+      /* tclk-preparecnt: 6, tclk-zerocnt: 45 */
+  state->pdata.tclk_headercnt = 0x2D06;//0x0218
+  state->pdata.tclk_trailcnt = 0x09;//
+      /* ths-preparecnt: 7, ths-zerocnt: 17 */
+  state->pdata.ths_headercnt = 0xd06;//0x0220
+  state->pdata.twakeup = 0x4883;//
+  state->pdata.tclk_postcnt = 0x010;//
+  state->pdata.ths_trailcnt = 0xA;//
+  state->pdata.hstxvregcnt = 5;//5
+  state->reset_gpio = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_LOW);
+  if (IS_ERR(state->reset_gpio)) {
+      dev_err(dev, "failed to get reset gpio\n");
+      ret = PTR_ERR(state->reset_gpio);
+      goto disable_clk;
+  }
+  if(state->reset_gpio) {
+    pr_info("Calling reset GPIO but NOT IMPLEMENTED!");
+    tc358743_gpio_reset(state);
+  }
+  ret = 0;
+  goto free_endpoint;
+
+disable_clk:
+  // clk_disable_unprepare(refclk);
+free_endpoint:
+ // v4l2_of_free_endpoint(endpoint);
+  v4l2_fwnode_endpoint_free(&endpoint);
+put_node:
+    of_node_put(ep);
+
+  return ret;
+}
+#else
+static inline int tc358743_probe_of(struct tc358743_state *state) {
+  return -ENODEV;
+}
+#endif
+
+static int tc358743_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh) {
+  return 0;
+}
+
+static const struct v4l2_subdev_internal_ops tc358743_subdev_internal_ops = {
+    .open = tc358743_open,
+};
+
+static const struct media_entity_operations tc358743_media_ops = {
+    .link_validate = v4l2_subdev_link_validate,
+};
+
+static const struct regmap_config sensor_regmap_config = {
+    .reg_bits = 16,
+    .val_bits = 8,
+    .cache_type = REGCACHE_RBTREE,
+};
+
+static int tc358743_probe(struct i2c_client *client,
+                          const struct i2c_device_id *id) {
+  // static struct v4l2_dv_timings default_timing = V4L2_DV_BT_CEA_1280X720P30;
+  static struct v4l2_dv_timings default_timing = V4L2_DV_BT_CEA_1920X1080P50;
+  struct v4l2_subdev_edid sd_edid = {
+      .blocks = 2,
+      .edid = edid,
+  };
+  struct tc358743_state *state;
+  struct tc358743_platform_data *pdata = client->dev.platform_data;
+  struct v4l2_subdev *sd;
+  int err;
+  u16 chip_id_val;
+
+  pr_info("%s\n", __FUNCTION__);
+
+  if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {
+    pr_err("i2c check functionality failed addres %02X name %s", client->addr,
+           client->adapter->name);
+    return -EIO;
+  }
+
+  v4l2_info(sd, "chip found @0x%x (%s)\n", client->addr, client->adapter->name);
+
+  state = devm_kzalloc(&client->dev, sizeof(struct tc358743_state), GFP_KERNEL);
+  if (!state) {
+    pr_err("devm_kzalloc failed");
+    return -ENOMEM;
+  }
+  v4l2_info(sd, "dev of node %s\n", client->dev.of_node->full_name);
+  if (client->dev.of_node) {
+    if (!tc358743_parse_dt(&state->pdata, client)) {
+      pr_err("Couldn't parse device tree\n");
+      return -ENODEV;
+    }
+  }
+
+  state->i2c_client = client;
+
+  /* platform data */
+  if (pdata) {
+    state->pdata = *pdata;
+    pdata->endpoint.bus.mipi_csi2.flags = V4L2_MBUS_CSI2_CONTINUOUS_CLOCK;
+  } else {
+    err = tc358743_probe_of(state);
+    if (err == -ENODEV) {
+      v4l_err(client, "No platform data! err = %d\n", err);
+      return -ENODEV;
+    }
+  }
+
+  sd = &state->sd;
+  v4l2_i2c_subdev_init(sd, client, &tc358743_ops);
+  v4l2_info(sd, "Subdev init done\n");
+  sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE | V4L2_SUBDEV_FL_HAS_EVENTS;
+
+  /* i2c access */
+  chip_id_val = i2c_rd16(sd, CHIPID);
+  v4l2_info(sd, "Chip ID val: %d\n", chip_id_val);
+
+  if ((chip_id_val & MASK_CHIPID) != 0 || chip_id_val == 99) {
+    v4l2_info(sd, "tc358743: ERROR: not a TC358743 on address0x%x\n",
+              client->addr);
+    return -ENODEV;
+  }
+
+  /* control handlers */
+  v4l2_ctrl_handler_init(&state->hdl, 3);
+  v4l2_info(sd, "ctrl handler initied\n");
+
+  /* private controls */
+  state->detect_tx_5v_ctrl = v4l2_ctrl_new_std(
+      &state->hdl, NULL, V4L2_CID_DV_RX_POWER_PRESENT, 0, 1, 0, 0);
+
+  /* custom controls */
+  state->audio_sampling_rate_ctrl = v4l2_ctrl_new_custom(
+      &state->hdl, &tc358743_ctrl_audio_sampling_rate, NULL);
+
+  state->audio_present_ctrl =
+      v4l2_ctrl_new_custom(&state->hdl, &tc358743_ctrl_audio_present, NULL);
+
+  v4l2_info(sd, "A bunch of new cutoms done\n");
+
+  sd->ctrl_handler = &state->hdl;
+  if (state->hdl.error) {
+    err = state->hdl.error;
+    goto err_hdl;
+  }
+
+  if (tc358743_update_controls(sd)) {
+    err = -ENODEV;
+    goto err_hdl;
+  }
+
+  v4l2_info(sd, "Controls updated\n");
+
+  /* work queues */
+  state->work_queues = create_singlethread_workqueue(client->name);
+  if (!state->work_queues) {
+    v4l2_err(sd, "Could not create work queue\n");
+    err = -ENOMEM;
+    goto err_hdl;
+  }
+  v4l2_info(sd, "Work queue created\n");
+  // sd->entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
+  sd->entity.ops = &tc358743_media_ops;
+  state->pad.flags = MEDIA_PAD_FL_SOURCE;
+  v4l2_info(sd, "About to call tegra_media_entity_init\n");
+  err = tegra_media_entity_init(&sd->entity, 1, &state->pad, true, true);
+  if (err < 0) goto err_hdl;
+  v4l2_info(sd, "tegra_media_entity_init complete\n");
+
+#ifdef TC358743_VOUT_RGB
+  state->mbus_fmt_code = MEDIA_BUS_FMT_RGB888_1X24;
+#else
+  state->mbus_fmt_code = MEDIA_BUS_FMT_UYVY8_1X16;
+#endif
+
+  v4l2_info(sd, "Set mbus_fmt_code in probe to: %d\n", state->mbus_fmt_code);
+
+  sd->dev = &client->dev;
+  v4l2_info(sd, "About to register subdev\n");
+
+v4l2_info(sd, "HERE #4\n");
+
+  err = v4l2_async_register_subdev(sd);
+
+v4l2_info(sd, "HERE #5\n");
+
+  v4l2_info(sd, "Register subdev: %d\n", err);
+
+  if (err < 0) goto err_hdl;
+
+  mutex_init(&state->confctl_mutex);
+
+v4l2_info(sd, "HERE #6\n");
+
+  INIT_DELAYED_WORK(&state->delayed_work_enable_hotplug,
+                    tc358743_delayed_work_enable_hotplug);
+  INIT_DELAYED_WORK(&state->delayed_work_enable_interrupt,
+                    tc358743_delayed_work_enable_interrupt);
+  INIT_WORK(&state->process_isr, tc358743_process_isr);
+  mutex_init(&state->isr_lock);
+
+  v4l2_info(sd, "before tc358743_initial_setup\r\n");
+  tc358743_initial_setup(sd);
+  v4l2_info(sd, "after tc358743_initial_setup\r\n");
+
+  tc358743_set_csi_color_space(sd);
+  v4l2_info(sd, "before tc358743_s_dv_timings\r\n");
+  tc358743_s_dv_timings(sd, &default_timing);
+
+  v4l2_info(sd, "before tc358743_init_interrupts, irq: %d\r\n",
+            state->i2c_client->irq);
+  tc358743_init_interrupts(sd);
+  v4l2_info(sd, "after tc358743_init_interrupts, irq: %d\r\n",
+            state->i2c_client->irq);
+  if (state->i2c_client->irq) {
+    v4l2_info(sd, "IQR request\r\n");
+    err = devm_request_threaded_irq(
+        &client->dev, state->i2c_client->irq, NULL, tc358743_irq_handler,
+        IRQF_TRIGGER_RISING | IRQF_ONESHOT, "tc358743", state);
+    v4l2_err(sd, "err, %d\n", err);
+    if (err) goto err_work_queues;
+  }
+  queue_delayed_work(state->work_queues, &state->delayed_work_enable_interrupt,
+                     msecs_to_jiffies(DELAY_ENABLE_INTERRUPT_MS));
+
+  tc358743_enable_interrupts(sd, tx_5v_power_present(sd));
+  i2c_wr16(sd, INTMASK, ~(MASK_HDMI_MSK | MASK_CSI_MSK) & 0xffff);
+
+  err = v4l2_ctrl_handler_setup(sd->ctrl_handler);
+
+  if (err) goto err_work_queues;
+
+  v4l2_info(sd, "%s found @0x%x (%s)\n", client->name, client->addr,
+            client->adapter->name);
+  tc358743_s_edid(sd, &sd_edid);
+  tc358743_g_edid(sd, &sd_edid);
+
+  tc358743_log_status(sd);
+  v4l2_info(sd, "Probe complete\n");
+  return 0;
+
+err_work_queues:
+  cancel_delayed_work(&state->delayed_work_enable_hotplug);
+  destroy_workqueue(state->work_queues);
+  mutex_destroy(&state->confctl_mutex);
+err_hdl:
+  media_entity_cleanup(&sd->entity);
+  v4l2_ctrl_handler_free(&state->hdl);
+  return err;
+}
+
+static int tc358743_remove(struct i2c_client *client) {
+  struct v4l2_subdev *sd = i2c_get_clientdata(client);
+  struct tc358743_state *state = to_state(sd);
+
+  cancel_delayed_work(&state->delayed_work_enable_hotplug);
+  destroy_workqueue(state->work_queues);
+  v4l2_async_unregister_subdev(sd);
+  v4l2_device_unregister_subdev(sd);
+  mutex_destroy(&state->confctl_mutex);
+  media_entity_cleanup(&sd->entity);
+  v4l2_ctrl_handler_free(&state->hdl);
+
+  return 0;
+}
+
+static struct i2c_device_id tc358743_id[] = {{"tc358743", 0}, {}};
+
+MODULE_DEVICE_TABLE(i2c, tc358743_id);
+
+#ifdef CONFIG_OF
+static const struct of_device_id tc358743_of_table[] = {
+    {.compatible = "toshiba,tc358743"}, {}};
+MODULE_DEVICE_TABLE(of, tc358743_of_table);
+#endif
+
+static struct i2c_driver tc358743_driver = {
+    .driver =
+        {
+            .of_match_table = of_match_ptr(tc358743_of_table),
+            .name = "tc358743",
+            .owner = THIS_MODULE,
+        },
+    .probe = tc358743_probe,
+    .remove = tc358743_remove,
+    .id_table = tc358743_id,
+};
+
+module_i2c_driver(tc358743_driver);
diff --git a/drivers/media/platform/tegra/camera/fusa-capture/capture-vi.c b/drivers/media/platform/tegra/camera/fusa-capture/capture-vi.c
new file mode 100644
index 0000000..2ff0609
--- /dev/null
+++ b/drivers/media/platform/tegra/camera/fusa-capture/capture-vi.c
@@ -0,0 +1,1774 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/* SPDX-FileCopyrightText: Copyright (c) 2017-2024 NVIDIA CORPORATION & AFFILIATES.
+ * All rights reserved.
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+/**
+ * @file drivers/media/platform/tegra/camera/fusa-capture/capture-vi.c
+ *
+ * @brief VI channel operations for the T234 Camera RTCPU platform.
+ */
+
+#include <linux/completion.h>
+#include <linux/nospec.h>
+#include <linux/nvhost.h>
+#include <linux/of_platform.h>
+#include <linux/printk.h>
+#include <linux/vmalloc.h>
+#include <linux/tegra-capture-ivc.h>
+#include <linux/tegra-camera-rtcpu.h>
+
+#include <asm/arch_timer.h>
+#include <uapi/linux/nvhost_events.h>
+#include <camera/nvcamera_log.h>
+#include "soc/tegra/camrtc-capture.h"
+#include "soc/tegra/camrtc-capture-messages.h"
+#include <media/fusa-capture/capture-vi-channel.h>
+#include <media/fusa-capture/capture-common.h>
+
+#include <media/fusa-capture/capture-vi.h>
+#include <media/vi.h>
+#include <media/mc_common.h>
+#include <media/tegra_camera_platform.h>
+#include "camera/vi/vi5_fops.h"
+
+/**
+ * @brief Invalid VI channel ID; the channel is not initialized.
+ */
+#define CAPTURE_CHANNEL_INVALID_ID	U16_C(0xFFFF)
+
+/**
+ * @brief Invalid VI channel mask; no channels are allocated.
+ */
+#define CAPTURE_CHANNEL_INVALID_MASK	U64_C(0x0)
+
+/**
+ * @brief Invalid NVCSI stream ID; the stream is not initialized.
+ */
+#define NVCSI_STREAM_INVALID_ID		U32_C(0xFFFF)
+
+/**
+ * @brief INVALID NVCSI TPG virtual channel ID; the TPG stream is not enabled.
+ */
+#define NVCSI_STREAM_INVALID_TPG_VC_ID	U32_C(0xFFFF)
+
+/**
+ * @brief The default number of VI channels to be used if not specified in
+ * the device tree.
+ */
+#define DEFAULT_VI_CHANNELS	U32_C(64)
+
+/**
+ * @brief Maximum number of VI devices supported.
+ */
+#define MAX_VI_UNITS	U32_C(0x2)
+
+/**
+ * @brief Invalid VI unit ID, to initialize vi-mapping table before parsing DT.
+ */
+#define INVALID_VI_UNIT_ID  U32_C(0xFFFF)
+
+/**
+ * @brief Maximum number of NVCSI streams supported.
+ */
+#define MAX_NVCSI_STREAM_IDS  U32_C(0x6)
+
+/**
+ * @brief Maximum number of virtual channel supported per stream.
+ */
+#define MAX_VIRTUAL_CHANNEL_PER_STREAM  U32_C(16)
+
+/**
+ * @brief A 2-D array for storing all possible tegra_vi_channel struct pointers.
+ */
+static struct tegra_vi_channel *channels[MAX_NVCSI_STREAM_IDS][MAX_VIRTUAL_CHANNEL_PER_STREAM];
+/**
+ * @brief Names of VI-unit and CSI-stream mapping elements in device-tree node
+ */
+static const char * const vi_mapping_elements[] = {
+	"csi-stream-id",
+	"vi-unit-id"
+};
+
+/**
+ * @brief The Capture-VI standalone driver context.
+ */
+struct tegra_capture_vi_data {
+	struct vi vi_common; /**< VI device context */
+	uint32_t num_vi_devices; /**< Number of available VI devices */
+	struct platform_device *vi_pdevices[MAX_VI_UNITS];
+		/**< VI nvhost client platform device for each VI instance */
+	uint32_t max_vi_channels;
+		/**< Maximum number of VI capture channel devices */
+	uint32_t num_csi_vi_maps;
+		/**< Number of NVCSI to VI mapping elements in the table */
+	uint32_t vi_instance_table[MAX_NVCSI_STREAM_IDS];
+		/**< NVCSI stream-id & VI instance mapping, read from the DT */
+};
+
+/**
+ * @brief Initialize a VI syncpoint and get its GoS backing.
+ *
+ * @param[in]	chan	VI channel context
+ * @param[in]	name	Syncpoint name
+ * @param[in]	enable	Whether to initialize or just clear @a sp
+ * @param[out]	sp	Syncpoint handle
+ *
+ * @returns	0 (success), neg. errno (failure)
+ */
+static int vi_capture_setup_syncpt(
+	struct tegra_vi_channel *chan,
+	const char *name,
+	bool enable,
+	struct syncpoint_info *sp)
+{
+	struct platform_device *pdev = chan->ndev;
+	uint32_t gos_index, gos_offset;
+	int err;
+
+	memset(sp, 0, sizeof(*sp));
+	sp->gos_index = GOS_INDEX_INVALID;
+
+	if (!enable)
+		return 0;
+
+	err = chan->ops->alloc_syncpt(pdev, name, &sp->id);
+	if (err)
+		return err;
+
+	err = nvhost_syncpt_read_ext_check(pdev, sp->id, &sp->threshold);
+	if (err)
+		goto cleanup;
+
+	err = chan->ops->get_syncpt_gos_backing(pdev, sp->id, &sp->shim_addr,
+				&gos_index, &gos_offset);
+	if (err)
+		goto cleanup;
+
+	sp->gos_index = gos_index;
+	sp->gos_offset = gos_offset;
+
+	return 0;
+
+cleanup:
+	chan->ops->release_syncpt(pdev, sp->id);
+	memset(sp, 0, sizeof(*sp));
+
+	return err;
+}
+
+/**
+ * @brief Release a VI syncpoint and clear its handle.
+ *
+ * @param[in]	chan	VI channel context
+ * @param[out]	sp	Syncpoint handle
+ */
+static void vi_capture_release_syncpt(
+	struct tegra_vi_channel *chan,
+	struct syncpoint_info *sp)
+{
+	if (sp->id)
+		chan->ops->release_syncpt(chan->ndev, sp->id);
+
+	memset(sp, 0, sizeof(*sp));
+}
+
+/**
+ * @brief Release the VI channel progress, embedded data and line timer
+ * syncpoints.
+ *
+ * @param[in]	chan	VI channel context
+ */
+static void vi_capture_release_syncpts(
+	struct tegra_vi_channel *chan)
+{
+	struct vi_capture *capture = chan->capture_data;
+
+	vi_capture_release_syncpt(chan, &capture->progress_sp);
+	vi_capture_release_syncpt(chan, &capture->embdata_sp);
+	vi_capture_release_syncpt(chan, &capture->linetimer_sp);
+}
+
+/**
+ * @brief Set up the VI channel progress, embedded data and line timer
+ * syncpoints.
+ *
+ * @param[in]	chan	VI channel context
+ * @param[in]	flags	Bitmask for channel flags, see
+ *			@ref CAPTURE_CHANNEL_FLAGS
+ *
+ * @returns	0 (success), neg. errno (failure)
+ */
+static int vi_capture_setup_syncpts(
+	struct tegra_vi_channel *chan,
+	uint32_t flags)
+{
+	struct vi_capture *capture = chan->capture_data;
+	int err = 0;
+
+	chan->ops->get_gos_table(chan->ndev,
+				&capture->num_gos_tables,
+				&capture->gos_tables);
+
+	err = vi_capture_setup_syncpt(chan, "progress", true,
+			&capture->progress_sp);
+	if (err < 0)
+		goto fail;
+
+	err = vi_capture_setup_syncpt(chan, "embdata",
+				(flags & CAPTURE_CHANNEL_FLAG_EMBDATA) != 0,
+				&capture->embdata_sp);
+	if (err < 0)
+		goto fail;
+
+	err = vi_capture_setup_syncpt(chan, "linetimer",
+				(flags & CAPTURE_CHANNEL_FLAG_LINETIMER) != 0,
+				&capture->linetimer_sp);
+	if (err < 0)
+		goto fail;
+
+	return 0;
+
+fail:
+	vi_capture_release_syncpts(chan);
+	return err;
+}
+
+/**
+ * @brief Read the value of a VI channel syncpoint.
+ *
+ * @param[in]	chan	VI channel context
+ * @param[in]	sp	Syncpoint handle
+ * @param[out]	val	Syncpoint value
+ *
+ * @returns	0 (success), neg. errno (failure)
+ */
+static int vi_capture_read_syncpt(
+	struct tegra_vi_channel *chan,
+	struct syncpoint_info *sp,
+	uint32_t *val)
+{
+	int err;
+
+	if (sp->id) {
+		err = nvhost_syncpt_read_ext_check(chan->ndev,
+						sp->id, val);
+		if (err < 0) {
+			dev_err(chan->dev,
+				"%s: get syncpt %i val failed\n", __func__,
+				sp->id);
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
+/**
+ * @brief VI channel callback function for @em capture IVC messages.
+ *
+ * @param[in]	ivc_resp	IVC @ref CAPTURE_MSG from RCE
+ * @param[in]	pcontext	VI channel capture context
+ */
+static void vi_capture_ivc_status_callback(
+	const void *ivc_resp,
+	const void *pcontext)
+{
+	struct CAPTURE_MSG *status_msg = (struct CAPTURE_MSG *)ivc_resp;
+	struct vi_capture *capture = (struct vi_capture *)pcontext;
+	struct tegra_vi_channel *chan = capture->vi_channel;
+	uint32_t buffer_index;
+
+	if (unlikely(capture == NULL)) {
+		dev_err(chan->dev, "%s: invalid context", __func__);
+		return;
+	}
+
+	if (unlikely(status_msg == NULL)) {
+		dev_err(chan->dev, "%s: invalid response", __func__);
+		return;
+	}
+
+	switch (status_msg->header.msg_id) {
+	case CAPTURE_STATUS_IND:
+		buffer_index = status_msg->capture_status_ind.buffer_index;
+		if (capture->is_mem_pinned)
+			vi_capture_request_unpin(chan, buffer_index);
+		dma_sync_single_range_for_cpu(capture->rtcpu_dev,
+			capture->requests.iova,
+			buffer_index * capture->request_size,
+			capture->request_size, DMA_FROM_DEVICE);
+
+		if (capture->is_progress_status_notifier_set) {
+			capture_common_set_progress_status(
+					&capture->progress_status_notifier,
+					buffer_index,
+					capture->progress_status_buffer_depth,
+					PROGRESS_STATUS_DONE);
+		} else {
+			/*
+			 * Only fire completions if not using
+			 * the new progress status buffer mechanism
+			 */
+			complete(&capture->capture_resp);
+		}
+		dev_dbg(chan->dev, "%s: status chan_id %u msg_id %u\n",
+				__func__, status_msg->header.channel_id,
+				status_msg->header.msg_id);
+		break;
+	default:
+		dev_err(chan->dev,
+			"%s: unknown capture resp", __func__);
+		break;
+	}
+}
+
+/**
+ * @brief Send a @em capture-control IVC message to RCE on a VI channel, and
+ * block w/ timeout, waiting for the RCE response.
+ *
+ * @param[in]	chan	VI channel context
+ * @param[in]	msg	IVC message payload
+ * @param[in]	size	Size of @a msg [byte]
+ * @param[in]	resp_id	IVC message identifier, see @CAPTURE_MSG_IDS
+ *
+ * @returns	0 (success), neg. errno (failure)
+ */
+static int vi_capture_ivc_send_control(
+	struct tegra_vi_channel *chan,
+	const struct CAPTURE_CONTROL_MSG *msg,
+	size_t size,
+	uint32_t resp_id)
+{
+	struct vi_capture *capture = chan->capture_data;
+	struct CAPTURE_MSG_HEADER resp_header = msg->header;
+	uint32_t timeout = HZ;
+	int err = 0;
+
+	dev_dbg(chan->dev, "%s: sending chan_id %u msg_id %u\n",
+			__func__, resp_header.channel_id, resp_header.msg_id);
+	resp_header.msg_id = resp_id;
+	/* Send capture control IVC message */
+	mutex_lock(&capture->control_msg_lock);
+	err = tegra_capture_ivc_control_submit(msg, size);
+	if (err < 0) {
+		dev_err(chan->dev, "IVC control submit failed\n");
+		goto fail;
+	}
+
+	timeout = wait_for_completion_timeout(
+			&capture->control_resp, timeout);
+	if (timeout <= 0) {
+		dev_err(chan->dev,
+			"capture control message timed out\n");
+		err = -ETIMEDOUT;
+		goto fail;
+	}
+
+	if (memcmp(&resp_header, &capture->control_resp_msg.header,
+			sizeof(resp_header)) != 0) {
+		dev_err(chan->dev,
+			"unexpected response from camera processor\n");
+		err = -EINVAL;
+		goto fail;
+	}
+
+	mutex_unlock(&capture->control_msg_lock);
+	dev_dbg(chan->dev, "%s: response chan_id %u msg_id %u\n",
+			__func__, capture->control_resp_msg.header.channel_id,
+			capture->control_resp_msg.header.msg_id);
+	return 0;
+
+fail:
+	mutex_unlock(&capture->control_msg_lock);
+	return err;
+}
+
+/**
+ * @brief VI channel callback function for @em capture-control IVC messages,
+ * this unblocks the channel's @em capture-control completion.
+ *
+ * @param[in]	ivc_resp	IVC @ref CAPTURE_CONTROL_MSG from RCE
+ * @param[in]	pcontext	VI channel capture context
+ */
+static void vi_capture_ivc_control_callback(
+	const void *ivc_resp,
+	const void *pcontext)
+{
+	const struct CAPTURE_CONTROL_MSG *control_msg = ivc_resp;
+	struct vi_capture *capture = (struct vi_capture *)pcontext;
+	struct tegra_vi_channel *chan = capture->vi_channel;
+
+	if (unlikely(capture == NULL)) {
+		dev_err(chan->dev, "%s: invalid context", __func__);
+		return;
+	}
+
+	if (unlikely(control_msg == NULL)) {
+		dev_err(chan->dev, "%s: invalid response", __func__);
+		return;
+	}
+
+	switch (control_msg->header.msg_id) {
+	case CAPTURE_CHANNEL_SETUP_RESP:
+	case CAPTURE_CHANNEL_RESET_RESP:
+	case CAPTURE_CHANNEL_RELEASE_RESP:
+	case CAPTURE_COMPAND_CONFIG_RESP:
+	case CAPTURE_PDAF_CONFIG_RESP:
+	case CAPTURE_SYNCGEN_ENABLE_RESP:
+	case CAPTURE_SYNCGEN_DISABLE_RESP:
+	case CAPTURE_PHY_STREAM_OPEN_RESP:
+	case CAPTURE_PHY_STREAM_CLOSE_RESP:
+	case CAPTURE_PHY_STREAM_DUMPREGS_RESP:
+	case CAPTURE_CSI_STREAM_SET_CONFIG_RESP:
+	case CAPTURE_CSI_STREAM_SET_PARAM_RESP:
+	case CAPTURE_CSI_STREAM_TPG_SET_CONFIG_RESP:
+	case CAPTURE_CSI_STREAM_TPG_START_RESP:
+	case CAPTURE_CSI_STREAM_TPG_START_RATE_RESP:
+	case CAPTURE_CSI_STREAM_TPG_APPLY_GAIN_RESP:
+	case CAPTURE_CSI_STREAM_TPG_STOP_RESP:
+	case CAPTURE_CHANNEL_EI_RESP:
+	case CAPTURE_HSM_CHANSEL_ERROR_MASK_RESP:
+		memcpy(&capture->control_resp_msg, control_msg,
+				sizeof(*control_msg));
+		complete(&capture->control_resp);
+		break;
+	default:
+		dev_err(chan->dev,
+			"%s: unknown capture control resp 0x%x", __func__,
+			control_msg->header.msg_id);
+		break;
+	}
+}
+
+int vi_capture_init(
+	struct tegra_vi_channel *chan,
+	bool is_mem_pinned)
+{
+	struct vi_capture *capture;
+	struct device_node *dn;
+	struct platform_device *rtc_pdev;
+	struct device *dev;
+
+	dev = &chan->vi_capture_pdev->dev;
+
+	dev_dbg(dev, "%s++\n", __func__);
+	dn = of_find_node_by_path("tegra-camera-rtcpu");
+	if (of_device_is_available(dn) == 0) {
+		dev_err(dev, "failed to find rtcpu device node\n");
+		return -ENODEV;
+	}
+	rtc_pdev = of_find_device_by_node(dn);
+	if (rtc_pdev == NULL) {
+		dev_err(dev, "failed to find rtcpu platform\n");
+		return -ENODEV;
+	}
+
+	capture = kzalloc(sizeof(*capture), GFP_KERNEL);
+	if (unlikely(capture == NULL)) {
+		dev_err(dev, "failed to allocate capture channel\n");
+		return -ENOMEM;
+	}
+
+	capture->rtcpu_dev = &rtc_pdev->dev;
+
+	init_completion(&capture->control_resp);
+	init_completion(&capture->capture_resp);
+
+	mutex_init(&capture->reset_lock);
+	mutex_init(&capture->control_msg_lock);
+	mutex_init(&capture->unpins_list_lock);
+
+	capture->vi_channel = chan;
+	chan->capture_data = capture;
+	chan->rtcpu_dev = capture->rtcpu_dev;
+
+	capture->is_mem_pinned = is_mem_pinned;
+	capture->channel_id = CAPTURE_CHANNEL_INVALID_ID;
+
+	capture->stream_id = NVCSI_STREAM_INVALID_ID;
+	capture->csi_port = NVCSI_PORT_UNSPECIFIED;
+	capture->virtual_channel_id = NVCSI_STREAM_INVALID_TPG_VC_ID;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(vi_capture_init);
+
+void vi_capture_shutdown(
+	struct tegra_vi_channel *chan)
+{
+	struct vi_capture *capture = chan->capture_data;
+
+	dev_dbg(chan->dev, "%s--\n", __func__);
+	if (capture == NULL)
+		return;
+
+	if (capture->channel_id != CAPTURE_CHANNEL_INVALID_ID)
+		vi_capture_reset(chan,
+			CAPTURE_CHANNEL_RESET_FLAG_IMMEDIATE);
+
+	if (capture->stream_id != NVCSI_STREAM_INVALID_ID)
+		csi_stream_release(chan);
+
+	if (capture->channel_id != CAPTURE_CHANNEL_INVALID_ID)	{
+		int i;
+
+		vi_capture_release(chan,
+			CAPTURE_CHANNEL_RESET_FLAG_IMMEDIATE);
+
+		if (capture->is_mem_pinned) {
+			for (i = 0; i < capture->queue_depth; i++)
+				vi_capture_request_unpin(chan, i);
+		}
+		capture_common_unpin_memory(&capture->requests);
+		if (capture->buf_ctx != NULL) {
+			destroy_buffer_table(capture->buf_ctx);
+			capture->buf_ctx = NULL;
+		}
+
+		vfree(capture->unpins_list);
+		capture->unpins_list = NULL;
+	}
+	kfree(capture);
+	chan->capture_data = NULL;
+}
+EXPORT_SYMBOL_GPL(vi_capture_shutdown);
+
+void vi_get_nvhost_device(
+	struct tegra_vi_channel *chan,
+	struct vi_capture_setup *setup)
+{
+	uint32_t vi_inst = 0;
+
+	struct tegra_capture_vi_data *info =
+		platform_get_drvdata(chan->vi_capture_pdev);
+
+	vi_inst = info->vi_instance_table[setup->csi_stream_id];
+
+	if (vi_inst >= MAX_VI_UNITS) {
+		dev_err(&chan->vi_capture_pdev->dev, "Invalid VI device Id\n");
+		chan->dev = NULL;
+		chan->ndev = NULL;
+		return;
+	}
+	vi_inst = array_index_nospec(vi_inst, MAX_VI_UNITS);
+
+	chan->dev = &info->vi_pdevices[vi_inst]->dev;
+	chan->ndev = info->vi_pdevices[vi_inst];
+}
+EXPORT_SYMBOL_GPL(vi_get_nvhost_device);
+
+struct device *vi_csi_stream_to_nvhost_device(
+	struct platform_device *pdev,
+	uint32_t csi_stream_id)
+{
+	struct tegra_capture_vi_data *info = platform_get_drvdata(pdev);
+	uint32_t vi_inst_id = 0;
+
+	if (csi_stream_id >= MAX_NVCSI_STREAM_IDS) {
+		dev_err(&pdev->dev, "Invalid NVCSI stream Id\n");
+		return NULL;
+	}
+
+	vi_inst_id = info->vi_instance_table[csi_stream_id];
+	return &info->vi_pdevices[vi_inst_id]->dev;
+}
+EXPORT_SYMBOL(vi_csi_stream_to_nvhost_device);
+
+int vi_capture_setup(
+	struct tegra_vi_channel *chan,
+	struct vi_capture_setup *setup)
+{
+	struct vi_capture *capture = chan->capture_data;
+	struct tegra_capture_vi_data *info;
+	uint32_t transaction;
+	struct CAPTURE_CONTROL_MSG control_desc;
+	struct CAPTURE_CONTROL_MSG *resp_msg = &capture->control_resp_msg;
+	struct capture_channel_config *config =
+		&control_desc.channel_setup_req.channel_config;
+	int err = 0;
+#ifdef HAVE_VI_GOS_TABLES
+	int i;
+#endif
+
+	uint32_t vi_inst = 0;
+	struct device *dev;
+
+	dev = &chan->vi_capture_pdev->dev;
+
+	if (setup->csi_stream_id >= MAX_NVCSI_STREAM_IDS ||
+		setup->virtual_channel_id >= MAX_VIRTUAL_CHANNEL_PER_STREAM) {
+		dev_err(dev, "Invalid stream id or virtual channel id\n");
+		return -EINVAL;
+	}
+
+	if (chan->vi_capture_pdev == NULL) {
+		dev_err(dev,
+			"%s: channel capture device is NULL", __func__);
+		return -EINVAL;
+	}
+
+	info = platform_get_drvdata(chan->vi_capture_pdev);
+	vi_inst = info->vi_instance_table[setup->csi_stream_id];
+
+	/* V4L2 directly calls this function. So need to make sure the
+	 * correct VI5 instance is associated with the VI capture channel.
+	 */
+	if (chan->dev == NULL) {
+		vi_get_nvhost_device(chan, setup);
+		if (chan->dev == NULL) {
+			dev_err(&chan->vi_capture_pdev->dev,
+				"%s: channel device is NULL", __func__);
+			return -EINVAL;
+		}
+	}
+
+	nv_camera_log(chan->ndev,
+		__arch_counter_get_cntvct(),
+		NVHOST_CAMERA_VI_CAPTURE_SETUP);
+
+	if (setup->mem == 0 && setup->iova == 0) {
+		dev_err(chan->dev,
+			"%s: request buffer is NULL\n", __func__);
+		return -EINVAL;
+	}
+
+	if (capture == NULL) {
+		dev_err(chan->dev,
+			 "%s: vi capture uninitialized\n", __func__);
+		return -ENODEV;
+	}
+
+	if (capture->channel_id != CAPTURE_CHANNEL_INVALID_ID) {
+		dev_err(chan->dev,
+			"%s: already setup, release first\n", __func__);
+		return -EEXIST;
+	}
+
+	dev_dbg(chan->dev, "chan flags %u\n", setup->channel_flags);
+	dev_dbg(chan->dev, "chan mask %llx\n", setup->vi_channel_mask);
+	dev_dbg(chan->dev, "queue depth %u\n", setup->queue_depth);
+	dev_dbg(chan->dev, "request size %u\n", setup->request_size);
+	dev_dbg(chan->dev, "csi_stream_id %u\n", setup->csi_stream_id);
+	dev_dbg(chan->dev, "vi unit id %u\n", vi_inst);
+	dev_dbg(chan->dev, "vi2 chan mask %llx\n", setup->vi2_channel_mask);
+
+	if (WARN_ON(vi_inst == VI_UNIT_VI &&
+		setup->vi_channel_mask == CAPTURE_CHANNEL_INVALID_MASK) ||
+		WARN_ON(vi_inst == VI_UNIT_VI2 &&
+		setup->vi2_channel_mask == CAPTURE_CHANNEL_INVALID_MASK) ||
+		WARN_ON(setup->channel_flags == 0) ||
+		WARN_ON(setup->queue_depth == 0) ||
+		WARN_ON(setup->request_size == 0) ||
+		WARN_ON(setup->csi_stream_id == NVCSI_STREAM_INVALID_ID)) {
+
+		dev_err(chan->dev, "%s: invalid setup parameters\n", __func__);
+		return -EINVAL;
+	}
+
+	capture->queue_depth = setup->queue_depth;
+	capture->request_size = setup->request_size;
+	capture->request_buf_size = setup->request_size * setup->queue_depth;
+
+	capture->stream_id = setup->csi_stream_id;
+	capture->csi_port = setup->csi_port;
+	capture->virtual_channel_id = setup->virtual_channel_id;
+
+	err = vi_capture_setup_syncpts(chan, setup->channel_flags);
+	if (err < 0) {
+		dev_err(chan->dev, "failed to setup syncpts\n");
+		goto syncpt_fail;
+	}
+
+	err = tegra_capture_ivc_register_control_cb(
+			&vi_capture_ivc_control_callback,
+			&transaction, capture);
+	if (err < 0) {
+		dev_err(chan->dev, "failed to register control callback\n");
+		goto control_cb_fail;
+	}
+
+	memset(&control_desc, 0, sizeof(control_desc));
+	control_desc.header.msg_id = CAPTURE_CHANNEL_SETUP_REQ;
+	control_desc.header.transaction = transaction;
+
+	/* Allocate memoryinfo ringbuffer */
+	capture->requests_memoryinfo = dma_alloc_coherent(capture->rtcpu_dev,
+		setup->queue_depth * sizeof(*capture->requests_memoryinfo),
+		&capture->requests_memoryinfo_iova, GFP_KERNEL);
+
+	if (!capture->requests_memoryinfo) {
+		dev_err(chan->dev,
+			"%s: memoryinfo ringbuffer alloc failed\n", __func__);
+		goto memoryinfo_alloc_fail;
+	}
+
+	WARN_ON(capture->unpins_list != NULL);
+
+	capture->unpins_list =
+		vzalloc(setup->queue_depth * sizeof(*capture->unpins_list));
+
+	if (!capture->unpins_list) {
+		dev_err(chan->dev,
+			"%s: channel_unpins alloc failed\n", __func__);
+		goto unpin_alloc_fail;
+	}
+
+	config->requests_memoryinfo = capture->requests_memoryinfo_iova;
+	config->request_memoryinfo_size =
+			sizeof(struct capture_descriptor_memoryinfo);
+
+	config->channel_flags = setup->channel_flags;
+	config->vi_channel_mask = setup->vi_channel_mask;
+	config->vi2_channel_mask = setup->vi2_channel_mask;
+	config->slvsec_stream_main = setup->slvsec_stream_main;
+	config->slvsec_stream_sub = setup->slvsec_stream_sub;
+
+	config->vi_unit_id = vi_inst;
+
+	config->csi_stream.stream_id = setup->csi_stream_id;
+	config->csi_stream.csi_port = setup->csi_port;
+	config->csi_stream.virtual_channel = setup->virtual_channel_id;
+
+	config->queue_depth = setup->queue_depth;
+	config->request_size = setup->request_size;
+	config->requests = setup->iova;
+
+	config->error_mask_correctable = setup->error_mask_correctable;
+	config->error_mask_uncorrectable = setup->error_mask_uncorrectable;
+	config->stop_on_error_notify_bits = setup->stop_on_error_notify_bits;
+
+#ifdef HAVE_VI_GOS_TABLES
+	dev_dbg(chan->dev, "%u GoS tables configured.\n",
+		capture->num_gos_tables);
+	for (i = 0; i < capture->num_gos_tables; i++) {
+		config->vi_gos_tables[i] = (iova_t)capture->gos_tables[i];
+		dev_dbg(chan->dev, "gos[%d] = 0x%08llx\n",
+			i, (u64)capture->gos_tables[i]);
+	}
+	config->num_vi_gos_tables = capture->num_gos_tables;
+#endif
+
+	config->progress_sp = capture->progress_sp;
+	config->embdata_sp = capture->embdata_sp;
+	config->linetimer_sp = capture->linetimer_sp;
+
+	err = vi_capture_ivc_send_control(chan, &control_desc,
+			sizeof(control_desc), CAPTURE_CHANNEL_SETUP_RESP);
+	if (err < 0)
+		goto submit_fail;
+
+	if (resp_msg->channel_setup_resp.result != CAPTURE_OK) {
+		dev_err(chan->dev, "%s: control failed, errno %d", __func__,
+			resp_msg->channel_setup_resp.result);
+		err = -EINVAL;
+		goto resp_fail;
+	}
+
+	capture->channel_id = resp_msg->channel_setup_resp.channel_id;
+
+	if (vi_inst == VI_UNIT_VI)
+		capture->vi_channel_mask =
+				resp_msg->channel_setup_resp.vi_channel_mask;
+	else if (vi_inst == VI_UNIT_VI2)
+		capture->vi2_channel_mask =
+				resp_msg->channel_setup_resp.vi_channel_mask;
+	else {
+		dev_err(chan->dev, "failed response for vi:%u\n", vi_inst);
+		err = -EINVAL;
+		goto resp_fail;
+	}
+
+
+	err = tegra_capture_ivc_notify_chan_id(capture->channel_id,
+			transaction);
+	if (err < 0) {
+		dev_err(chan->dev, "failed to update control callback\n");
+		goto cb_fail;
+	}
+
+	err = tegra_capture_ivc_register_capture_cb(
+			&vi_capture_ivc_status_callback,
+			capture->channel_id, capture);
+	if (err < 0) {
+		dev_err(chan->dev, "failed to register capture callback\n");
+		goto cb_fail;
+	}
+
+	channels[setup->csi_stream_id][setup->virtual_channel_id] = chan;
+
+	return 0;
+
+cb_fail:
+resp_fail:
+submit_fail:
+	vfree(capture->unpins_list);
+	capture->unpins_list = NULL;
+unpin_alloc_fail:
+	/* Release memoryinfo ringbuffer */
+	dma_free_coherent(capture->rtcpu_dev,
+		capture->queue_depth *
+		sizeof(struct capture_descriptor_memoryinfo),
+		capture->requests_memoryinfo,
+		capture->requests_memoryinfo_iova);
+	capture->requests_memoryinfo = NULL;
+memoryinfo_alloc_fail:
+	tegra_capture_ivc_unregister_control_cb(transaction);
+control_cb_fail:
+	vi_capture_release_syncpts(chan);
+syncpt_fail:
+	return err;
+}
+EXPORT_SYMBOL_GPL(vi_capture_setup);
+
+struct tegra_vi_channel *get_tegra_vi_channel(
+	unsigned int stream_id,
+	unsigned int virtual_channel_id)
+{
+	if (stream_id >= MAX_NVCSI_STREAM_IDS || virtual_channel_id >= MAX_VIRTUAL_CHANNEL_PER_STREAM)
+		return NULL;
+
+	return channels[stream_id][virtual_channel_id];
+}
+
+void vi_capture_abort(struct tegra_vi_channel *chan) 
+{
+	struct vi_capture *capture = chan->capture_data;
+	int i;
+	
+	for (i = 0; i < capture->queue_depth; i++)
+		complete(&capture->capture_resp);
+}
+
+int vi_capture_reset(
+	struct tegra_vi_channel *chan,
+	uint32_t reset_flags)
+{
+	struct vi_capture *capture = chan->capture_data;
+	struct CAPTURE_CONTROL_MSG control_desc;
+#ifdef CAPTURE_RESET_BARRIER_IND
+	struct CAPTURE_MSG capture_desc;
+#endif
+	struct CAPTURE_CONTROL_MSG *resp_msg = &capture->control_resp_msg;
+	int err = 0;
+
+	nv_camera_log(chan->ndev,
+		__arch_counter_get_cntvct(),
+		NVHOST_CAMERA_VI_CAPTURE_RESET);
+
+	if (capture == NULL) {
+		dev_err(chan->dev,
+			 "%s: vi capture uninitialized\n", __func__);
+		return -ENODEV;
+	}
+
+	if (capture->channel_id == CAPTURE_CHANNEL_INVALID_ID) {
+		dev_err(chan->dev,
+			"%s: setup channel first\n", __func__);
+		return -ENODEV;
+	}
+
+	mutex_lock(&capture->reset_lock);
+
+#ifdef CAPTURE_RESET_BARRIER_IND
+	memset(&capture_desc, 0, sizeof(capture_desc));
+	capture_desc.header.msg_id = CAPTURE_RESET_BARRIER_IND;
+	capture_desc.header.channel_id = capture->channel_id;
+	err = tegra_capture_ivc_capture_submit(&capture_desc,
+			sizeof(capture_desc));
+	if (err < 0) {
+		dev_err(chan->dev, "%s:IVC capture submit failed\n", __func__);
+		goto submit_fail;
+	}
+#endif
+
+	memset(&control_desc, 0, sizeof(control_desc));
+	control_desc.header.msg_id = CAPTURE_CHANNEL_RESET_REQ;
+	control_desc.header.channel_id = capture->channel_id;
+	control_desc.channel_reset_req.reset_flags = reset_flags;
+
+	err = vi_capture_ivc_send_control(chan, &control_desc,
+			sizeof(control_desc), CAPTURE_CHANNEL_RESET_RESP);
+	if (err < 0)
+		goto submit_fail;
+
+#ifdef CAPTURE_RESET_BARRIER_IND
+	if (resp_msg->channel_reset_resp.result == CAPTURE_ERROR_TIMEOUT) {
+		dev_dbg(chan->dev, "%s:reset timeout\n", __func__);
+		err = -EAGAIN;
+		goto submit_fail;
+	}
+#endif
+
+	if (resp_msg->channel_reset_resp.result != CAPTURE_OK) {
+		dev_err(chan->dev, "%s: control failed, errno %d", __func__,
+			resp_msg->channel_reset_resp.result);
+		err = -EINVAL;
+	}
+
+submit_fail:
+	mutex_unlock(&capture->reset_lock);
+	return err;
+}
+EXPORT_SYMBOL_GPL(vi_capture_reset);
+
+int vi_capture_release(
+	struct tegra_vi_channel *chan,
+	uint32_t reset_flags)
+{
+	struct vi_capture *capture = chan->capture_data;
+	struct CAPTURE_CONTROL_MSG control_desc;
+	struct CAPTURE_CONTROL_MSG *resp_msg = &capture->control_resp_msg;
+	int err = 0;
+	int ret = 0;
+	int i = 0;
+
+	nv_camera_log(chan->ndev,
+		__arch_counter_get_cntvct(),
+		NVHOST_CAMERA_VI_CAPTURE_RELEASE);
+
+	if (capture == NULL) {
+		dev_err(chan->dev,
+			 "%s: vi capture uninitialized\n", __func__);
+		return -ENODEV;
+	}
+
+	if (capture->channel_id == CAPTURE_CHANNEL_INVALID_ID) {
+		dev_err(chan->dev,
+			"%s: setup channel first\n", __func__);
+		return -ENODEV;
+
+	}
+
+	memset(&control_desc, 0, sizeof(control_desc));
+	control_desc.header.msg_id = CAPTURE_CHANNEL_RELEASE_REQ;
+	control_desc.header.channel_id = capture->channel_id;
+	control_desc.channel_release_req.reset_flags = reset_flags;
+
+	err = vi_capture_ivc_send_control(chan, &control_desc,
+			sizeof(control_desc), CAPTURE_CHANNEL_RELEASE_RESP);
+	if (err < 0) {
+		dev_err(chan->dev,
+				"%s: release channel IVC failed\n", __func__);
+		WARN_ON("RTCPU is in a bad state. Reboot to recover");
+
+		tegra_camrtc_reboot(chan->rtcpu_dev);
+
+		err = -EIO;
+	} else if (resp_msg->channel_release_resp.result != CAPTURE_OK) {
+		dev_err(chan->dev, "%s: control failed, errno %d", __func__,
+			resp_msg->channel_release_resp.result);
+		err = -EIO;
+	}
+
+	if (capture->requests_memoryinfo) {
+		/* Release memoryinfo ringbuffer */
+		dma_free_coherent(capture->rtcpu_dev,
+			capture->queue_depth * sizeof(struct capture_descriptor_memoryinfo),
+			capture->requests_memoryinfo, capture->requests_memoryinfo_iova);
+		capture->requests_memoryinfo = NULL;
+	}
+
+	ret = tegra_capture_ivc_unregister_capture_cb(capture->channel_id);
+	if (ret < 0 && err == 0) {
+		dev_err(chan->dev,
+			"failed to unregister capture callback\n");
+		err = ret;
+	}
+
+	ret = tegra_capture_ivc_unregister_control_cb(capture->channel_id);
+	if (ret < 0 && err == 0) {
+		dev_err(chan->dev,
+			"failed to unregister control callback\n");
+		err = ret;
+	}
+
+	for (i = 0; i < capture->queue_depth; i++)
+		complete(&capture->capture_resp);
+
+	vi_capture_release_syncpts(chan);
+
+	if (capture->stream_id < MAX_NVCSI_STREAM_IDS &&
+	    capture->virtual_channel_id < MAX_VIRTUAL_CHANNEL_PER_STREAM) {
+		channels[capture->stream_id][capture->virtual_channel_id] = NULL;
+	}
+
+	capture->channel_id = CAPTURE_CHANNEL_INVALID_ID;
+	capture->stream_id = NVCSI_STREAM_INVALID_ID;
+	capture->csi_port = NVCSI_PORT_UNSPECIFIED;
+	capture->virtual_channel_id = NVCSI_STREAM_INVALID_TPG_VC_ID;
+
+	if (capture->is_progress_status_notifier_set)
+		capture_common_release_progress_status_notifier(
+			&capture->progress_status_notifier);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(vi_capture_release);
+
+static int vi_capture_control_send_message(
+	struct tegra_vi_channel *chan,
+	const struct CAPTURE_CONTROL_MSG *msg_cpy,
+	size_t size)
+{
+	int err = 0;
+	struct vi_capture *capture = chan->capture_data;
+	struct CAPTURE_MSG_HEADER *header;
+	uint32_t resp_id;
+
+	header = (struct CAPTURE_MSG_HEADER *)msg_cpy;
+	header->channel_id = capture->channel_id;
+
+	switch (header->msg_id) {
+	case CAPTURE_COMPAND_CONFIG_REQ:
+		resp_id = CAPTURE_COMPAND_CONFIG_RESP;
+		break;
+	case CAPTURE_PDAF_CONFIG_REQ:
+		resp_id = CAPTURE_PDAF_CONFIG_RESP;
+		break;
+	case CAPTURE_SYNCGEN_ENABLE_REQ:
+		resp_id = CAPTURE_SYNCGEN_ENABLE_RESP;
+		break;
+	case CAPTURE_SYNCGEN_DISABLE_REQ:
+		resp_id = CAPTURE_SYNCGEN_DISABLE_RESP;
+		break;
+	case CAPTURE_PHY_STREAM_OPEN_REQ:
+		if (chan->is_stream_opened) {
+			dev_dbg(chan->dev,
+				"%s: NVCSI stream is already opened for this VI channel",
+				__func__);
+			return 0;
+		}
+		resp_id = CAPTURE_PHY_STREAM_OPEN_RESP;
+		capture->stream_id = msg_cpy->phy_stream_open_req.stream_id;
+		capture->csi_port = msg_cpy->phy_stream_open_req.csi_port;
+		break;
+	case CAPTURE_PHY_STREAM_CLOSE_REQ:
+		if (!chan->is_stream_opened) {
+			dev_dbg(chan->dev,
+				"%s: NVCSI stream is already closed for this VI channel",
+				__func__);
+			return 0;
+		}
+		resp_id = CAPTURE_PHY_STREAM_CLOSE_RESP;
+		break;
+	case CAPTURE_PHY_STREAM_DUMPREGS_REQ:
+		resp_id = CAPTURE_PHY_STREAM_DUMPREGS_RESP;
+		break;
+	case CAPTURE_CSI_STREAM_SET_CONFIG_REQ:
+		resp_id = CAPTURE_CSI_STREAM_SET_CONFIG_RESP;
+		break;
+	case CAPTURE_CSI_STREAM_SET_PARAM_REQ:
+		resp_id = CAPTURE_CSI_STREAM_SET_PARAM_RESP;
+		break;
+	case CAPTURE_CSI_STREAM_TPG_SET_CONFIG_REQ:
+		resp_id = CAPTURE_CSI_STREAM_TPG_SET_CONFIG_RESP;
+		break;
+	case CAPTURE_CSI_STREAM_TPG_START_REQ:
+		resp_id = CAPTURE_CSI_STREAM_TPG_START_RESP;
+		capture->virtual_channel_id =
+			msg_cpy->csi_stream_tpg_start_req.virtual_channel_id;
+		break;
+	case CAPTURE_CSI_STREAM_TPG_START_RATE_REQ:
+		resp_id = CAPTURE_CSI_STREAM_TPG_START_RATE_RESP;
+		capture->virtual_channel_id = msg_cpy->
+			csi_stream_tpg_start_rate_req.virtual_channel_id;
+		break;
+	case CAPTURE_CSI_STREAM_TPG_APPLY_GAIN_REQ:
+		resp_id = CAPTURE_CSI_STREAM_TPG_APPLY_GAIN_RESP;
+		break;
+	case CAPTURE_CSI_STREAM_TPG_STOP_REQ:
+		resp_id = CAPTURE_CSI_STREAM_TPG_STOP_RESP;
+		break;
+	case CAPTURE_CHANNEL_EI_REQ:
+		resp_id = CAPTURE_CHANNEL_EI_RESP;
+		break;
+	case CAPTURE_HSM_CHANSEL_ERROR_MASK_REQ:
+		resp_id = CAPTURE_HSM_CHANSEL_ERROR_MASK_RESP;
+		break;
+	default:
+		dev_err(chan->dev, "%s: unknown capture control req 0x%x",
+			__func__, header->msg_id);
+		return -EINVAL;
+	}
+
+	err = vi_capture_ivc_send_control(chan, msg_cpy, size, resp_id);
+	if (err < 0) {
+		dev_err(chan->dev, "%s: failed to send IVC control message", __func__);
+		return err;
+	}
+
+	if (header->msg_id == CAPTURE_PHY_STREAM_OPEN_REQ)
+		chan->is_stream_opened = true;
+	else if (header->msg_id == CAPTURE_PHY_STREAM_CLOSE_REQ)
+		chan->is_stream_opened = false;
+
+	return err;
+}
+
+/**
+ * @brief Disable the VI channel's NVCSI TPG stream in RCE.
+ *
+ * @param[in]	chan	VI channel context
+ *
+ * @returns	0 (success), neg. errno (failure)
+ */
+static int csi_stream_tpg_disable(
+	struct tegra_vi_channel *chan)
+{
+	struct vi_capture *capture = chan->capture_data;
+	struct CAPTURE_CONTROL_MSG control_desc;
+	struct CAPTURE_CONTROL_MSG *resp_msg = &capture->control_resp_msg;
+	int err = 0;
+
+	memset(&control_desc, 0, sizeof(control_desc));
+	control_desc.header.msg_id = CAPTURE_CSI_STREAM_TPG_STOP_REQ;
+	control_desc.header.channel_id = capture->channel_id;
+	control_desc.csi_stream_tpg_stop_req.stream_id = capture->stream_id;
+	control_desc.csi_stream_tpg_stop_req.virtual_channel_id =
+		capture->virtual_channel_id;
+
+	err = vi_capture_ivc_send_control(chan, &control_desc,
+		sizeof(control_desc), CAPTURE_CSI_STREAM_TPG_STOP_RESP);
+	if ((err < 0) ||
+			(resp_msg->csi_stream_tpg_stop_resp.result
+				!= CAPTURE_OK))
+		return err;
+
+	return 0;
+}
+
+/**
+ * @brief Disable the VI channel's NVCSI stream in RCE.
+ *
+ * @param[in]	chan	VI channel context
+ *
+ * @returns	0 (success), neg. errno (failure)
+ */
+static int csi_stream_close(
+	struct tegra_vi_channel *chan)
+{
+	struct vi_capture *capture = chan->capture_data;
+	struct CAPTURE_CONTROL_MSG control_desc;
+	struct CAPTURE_CONTROL_MSG *resp_msg = &capture->control_resp_msg;
+	int err = 0;
+
+	memset(&control_desc, 0, sizeof(control_desc));
+	control_desc.header.msg_id = CAPTURE_PHY_STREAM_CLOSE_REQ;
+	control_desc.header.channel_id = capture->channel_id;
+	control_desc.phy_stream_close_req.phy_type = NVPHY_TYPE_CSI;
+	control_desc.phy_stream_close_req.stream_id = capture->stream_id;
+	control_desc.phy_stream_close_req.csi_port = capture->csi_port;
+
+	err = vi_capture_control_send_message(chan, &control_desc,
+		sizeof(control_desc));
+	if ((err < 0) ||
+			(resp_msg->phy_stream_close_resp.result != CAPTURE_OK))
+		return err;
+
+	return 0;
+}
+
+int csi_stream_release(
+	struct tegra_vi_channel *chan)
+{
+	struct vi_capture *capture = chan->capture_data;
+	int err = 0;
+
+	if (capture->stream_id == NVCSI_STREAM_INVALID_ID)
+		return 0;
+
+	if (capture->virtual_channel_id != NVCSI_STREAM_INVALID_TPG_VC_ID) {
+		err = csi_stream_tpg_disable(chan);
+		if (err < 0) {
+			dev_err(chan->dev,
+				"%s: failed to disable nvcsi tpg on stream %u virtual channel %u\n",
+				__func__, capture->stream_id,
+				capture->virtual_channel_id);
+			return err;
+		}
+	}
+
+	if (chan->is_stream_opened) {
+		err = csi_stream_close(chan);
+		if (err < 0)
+			dev_err(chan->dev,
+				"%s: failed to close nvcsi stream %u\n",
+				__func__, capture->stream_id);
+	}
+
+	return err;
+}
+
+int vi_capture_control_message_from_user(
+	struct tegra_vi_channel *chan,
+	struct vi_capture_control_msg *msg)
+{
+	struct vi_capture *capture;
+	const void __user *msg_ptr;
+	void __user *response;
+	void *msg_cpy;
+	struct CAPTURE_CONTROL_MSG *resp_msg;
+	int err = 0;
+
+	if (chan == NULL) {
+		dev_err(NULL, "%s: NULL VI channel received\n", __func__);
+		return -ENODEV;
+	}
+
+	nv_camera_log(chan->ndev,
+		__arch_counter_get_cntvct(),
+		NVHOST_CAMERA_VI_CAPTURE_SET_CONFIG);
+
+	capture = chan->capture_data;
+
+	if (capture == NULL) {
+		dev_err(chan->dev,
+			 "%s: vi capture uninitialized\n", __func__);
+		return -ENODEV;
+	}
+
+	resp_msg = &capture->control_resp_msg;
+
+	if (msg->ptr == 0ull || msg->response == 0ull || msg->size == 0)
+		return -EINVAL;
+
+	msg_ptr = (const void __user *)(uintptr_t)msg->ptr;
+	response = (void __user *)(uintptr_t)msg->response;
+
+	msg_cpy = kzalloc(msg->size, GFP_KERNEL);
+	if (unlikely(msg_cpy == NULL))
+		return -ENOMEM;
+
+	err = copy_from_user(msg_cpy, msg_ptr, msg->size) ? -EFAULT : 0;
+	if (err < 0)
+		goto fail;
+
+
+	err = vi_capture_control_send_message(chan, msg_cpy, msg->size);
+	if (err < 0)
+		goto fail;
+
+	err = copy_to_user(response, resp_msg,
+		sizeof(*resp_msg)) ? -EFAULT : 0;
+	if (err < 0)
+		goto fail;
+
+fail:
+	kfree(msg_cpy);
+	return err;
+}
+EXPORT_SYMBOL_GPL(vi_capture_control_message_from_user);
+
+int vi_capture_control_message(
+	struct tegra_vi_channel *chan,
+	struct vi_capture_control_msg *msg)
+{
+	struct vi_capture *capture;
+	void *msg_cpy;
+	struct CAPTURE_CONTROL_MSG *resp_msg;
+	int err = 0;
+
+	if (chan == NULL) {
+		dev_err(NULL,"%s: NULL VI channel received\n", __func__);
+		return -ENODEV;
+	}
+
+	nv_camera_log(chan->ndev,
+		__arch_counter_get_cntvct(),
+		NVHOST_CAMERA_VI_CAPTURE_SET_CONFIG);
+
+	capture = chan->capture_data;
+
+	if (capture == NULL) {
+		dev_err(chan->dev,
+			 "%s: vi capture uninitialized\n", __func__);
+		return -ENODEV;
+	}
+
+	resp_msg = &capture->control_resp_msg;
+	if (msg->ptr == 0ull || msg->response == 0ull || msg->size == 0)
+		return -EINVAL;
+
+	msg_cpy = kzalloc(msg->size, GFP_KERNEL);
+	if (unlikely(msg_cpy == NULL))
+		return -ENOMEM;
+
+	memcpy(msg_cpy, (const void *)(uintptr_t)msg->ptr,
+						msg->size);
+
+	err = vi_capture_control_send_message(chan, msg_cpy, msg->size);
+	if (err < 0)
+		goto fail;
+
+	memcpy((void *)(uintptr_t)msg->response, resp_msg,
+						sizeof(*resp_msg));
+
+fail:
+	kfree(msg_cpy);
+	return err;
+}
+
+int vi_capture_get_info(
+	struct tegra_vi_channel *chan,
+	struct vi_capture_info *info)
+{
+	struct vi_capture *capture = chan->capture_data;
+	int err;
+
+	nv_camera_log(chan->ndev,
+		__arch_counter_get_cntvct(),
+		NVHOST_CAMERA_VI_CAPTURE_GET_INFO);
+
+	if (capture == NULL) {
+		dev_err(chan->dev,
+			 "%s: vi capture uninitialized\n", __func__);
+		return -ENODEV;
+	}
+
+	if (capture->channel_id == CAPTURE_CHANNEL_INVALID_ID) {
+		dev_err(chan->dev,
+			"%s: setup channel first\n", __func__);
+		return -ENODEV;
+	}
+
+	if (info == NULL)
+		return -EINVAL;
+
+	info->syncpts.progress_syncpt = capture->progress_sp.id;
+	info->syncpts.emb_data_syncpt = capture->embdata_sp.id;
+	info->syncpts.line_timer_syncpt = capture->linetimer_sp.id;
+
+	err = vi_capture_read_syncpt(chan, &capture->progress_sp,
+			&info->syncpts.progress_syncpt_val);
+	if (err < 0)
+		return err;
+	err = vi_capture_read_syncpt(chan, &capture->embdata_sp,
+			&info->syncpts.emb_data_syncpt_val);
+	if (err < 0)
+		return err;
+	err = vi_capture_read_syncpt(chan, &capture->linetimer_sp,
+			&info->syncpts.line_timer_syncpt_val);
+	if (err < 0)
+		return err;
+
+	info->hw_channel_id = capture->channel_id;
+	info->vi_channel_mask = capture->vi_channel_mask;
+	info->vi2_channel_mask = capture->vi2_channel_mask;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(vi_capture_get_info);
+
+int vi_capture_request(
+	struct tegra_vi_channel *chan,
+	struct vi_capture_req *req)
+{
+	struct vi_capture *capture = chan->capture_data;
+	struct CAPTURE_MSG capture_desc;
+	int err = 0;
+
+	nv_camera_log(chan->ndev,
+		__arch_counter_get_cntvct(),
+		NVHOST_CAMERA_VI_CAPTURE_REQUEST);
+
+	if (capture == NULL) {
+		dev_err(chan->dev,
+			"%s: vi capture uninitialized\n", __func__);
+		return -ENODEV;
+	}
+
+	if (capture->channel_id == CAPTURE_CHANNEL_INVALID_ID) {
+		dev_err(chan->dev,
+			"%s: setup channel first\n", __func__);
+		return -ENODEV;
+	}
+
+	if (req == NULL) {
+		dev_err(chan->dev,
+			"%s: Invalid req\n", __func__);
+		return -EINVAL;
+	}
+
+	mutex_lock(&capture->reset_lock);
+
+	memset(&capture_desc, 0, sizeof(capture_desc));
+	capture_desc.header.msg_id = CAPTURE_REQUEST_REQ;
+	capture_desc.header.channel_id = capture->channel_id;
+	capture_desc.capture_request_req.buffer_index = req->buffer_index;
+
+	nv_camera_log_vi_submit(
+			chan->ndev,
+			capture->progress_sp.id,
+			capture->progress_sp.threshold,
+			capture_desc.header.channel_id,
+			__arch_counter_get_cntvct());
+
+	dev_dbg(chan->dev, "%s: sending chan_id %u msg_id %u buf:%u\n",
+			__func__, capture_desc.header.channel_id,
+			capture_desc.header.msg_id, req->buffer_index);
+	err = tegra_capture_ivc_capture_submit(&capture_desc,
+			sizeof(capture_desc));
+	if (err < 0) {
+		mutex_unlock(&capture->reset_lock);
+		dev_err(chan->dev, "IVC capture submit failed\n");
+		return err;
+	}
+
+	mutex_unlock(&capture->reset_lock);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(vi_capture_request);
+
+int vi_capture_status(
+	struct tegra_vi_channel *chan,
+	int32_t timeout_ms)
+{
+	struct vi_capture *capture = chan->capture_data;
+	int ret = 0;
+
+	nv_camera_log(chan->ndev,
+		__arch_counter_get_cntvct(),
+		NVHOST_CAMERA_VI_CAPTURE_STATUS);
+
+	if (capture == NULL) {
+		dev_err(chan->dev,
+			 "%s: vi capture uninitialized\n", __func__);
+		return -ENODEV;
+	}
+
+	if (capture->channel_id == CAPTURE_CHANNEL_INVALID_ID) {
+		dev_err(chan->dev,
+			"%s: setup channel first\n", __func__);
+		return -ENODEV;
+	}
+
+	dev_dbg(chan->dev, "%s: waiting for status, timeout:%d ms\n",
+		__func__, timeout_ms);
+
+	/* negative timeout means wait forever */
+	if (timeout_ms < 0) {
+		ret = wait_for_completion_interruptible(&capture->capture_resp);
+		if (ret == -ERESTARTSYS) {
+			dev_dbg(chan->dev,
+				"capture status interrupted\n");
+			return -ETIMEDOUT;
+		}
+	} else {
+		ret = wait_for_completion_timeout(
+				&capture->capture_resp,
+				msecs_to_jiffies(timeout_ms));
+		if (ret == 0) {
+			dev_dbg(chan->dev,
+				"capture status timed out\n");
+			return -ETIMEDOUT;
+		}
+	}
+
+	if (ret < 0) {
+		dev_err(chan->dev,
+			"wait for capture status failed\n");
+		return ret;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(vi_capture_status);
+
+int vi_capture_set_progress_status_notifier(
+	struct tegra_vi_channel *chan,
+	struct vi_capture_progress_status_req *req)
+{
+	int err = 0;
+	struct vi_capture *capture = chan->capture_data;
+
+	nv_camera_log(chan->ndev,
+		__arch_counter_get_cntvct(),
+		NVHOST_CAMERA_VI_CAPTURE_SET_PROGRESS_STATUS);
+
+	if (req->mem == 0 ||
+		req->buffer_depth == 0) {
+		dev_err(chan->dev,
+				"%s: request buffer is invalid\n", __func__);
+		return -EINVAL;
+	}
+
+	if (capture == NULL) {
+		dev_err(chan->dev,
+				"%s: vi capture uninitialized\n", __func__);
+		return -ENODEV;
+	}
+
+	if (req->buffer_depth < capture->queue_depth) {
+		dev_err(chan->dev,
+			"Progress status buffer is smaller than queue depth");
+		return -EINVAL;
+	}
+
+	/* Setup the progress status buffer */
+	err = capture_common_setup_progress_status_notifier(
+		&capture->progress_status_notifier,
+		req->mem,
+		sizeof(uint32_t) * req->buffer_depth,
+		req->mem_offset);
+
+	if (err < 0) {
+		dev_err(chan->dev, "%s: memory setup failed\n", __func__);
+		return -EFAULT;
+	}
+
+	dev_dbg(chan->dev, "mem offset %u\n", req->mem_offset);
+	dev_dbg(chan->dev, "buffer depth %u\n", req->buffer_depth);
+
+	capture->progress_status_buffer_depth = req->buffer_depth;
+	capture->is_progress_status_notifier_set = true;
+	return err;
+}
+EXPORT_SYMBOL_GPL(vi_capture_set_progress_status_notifier);
+
+static int csi_vi_get_mapping_table(struct platform_device *pdev)
+{
+	uint32_t index = 0;
+	struct device *dev = &pdev->dev;
+	struct tegra_capture_vi_data *info = platform_get_drvdata(pdev);
+
+	int nmap_elems;
+	uint32_t map_table_size;
+	uint32_t *map_table = info->vi_instance_table;
+
+	const struct device_node *np = dev->of_node;
+
+	(void)of_property_read_u32(np,
+			"nvidia,vi-mapping-size", &map_table_size);
+	if (map_table_size > MAX_NVCSI_STREAM_IDS) {
+		dev_err(dev, "invalid mapping table size %u\n", map_table_size);
+		return -EINVAL;
+	}
+	info->num_csi_vi_maps = map_table_size;
+
+	nmap_elems = of_property_count_strings(np, "nvidia,vi-mapping-names");
+	if (nmap_elems != ARRAY_SIZE(vi_mapping_elements))
+		return -EINVAL;
+
+	/* check for order of csi-stream-id and vi-unit-id in DT entry */
+	for (index = 0; index < ARRAY_SIZE(vi_mapping_elements); index++) {
+		int map_elem = of_property_match_string(np,
+			"nvidia,vi-mapping-names", vi_mapping_elements[index]);
+		if (map_elem != index) {
+			dev_err(dev, "invalid mapping order\n");
+			return -EINVAL;
+		}
+	}
+
+	for (index = 0; index < map_table_size; index++)
+		map_table[index] = INVALID_VI_UNIT_ID;
+
+	for (index = 0; index < map_table_size; index++) {
+		uint32_t stream_index = NVCSI_STREAM_INVALID_ID;
+		uint32_t vi_unit_id = INVALID_VI_UNIT_ID;
+
+		(void)of_property_read_u32_index(np,
+			"nvidia,vi-mapping",
+			2 * index,
+			&stream_index);
+
+		/* Check for valid/duplicate csi-stream-id */
+		if (stream_index >= MAX_NVCSI_STREAM_IDS ||
+			map_table[stream_index] != INVALID_VI_UNIT_ID) {
+			dev_err(dev, "%s: mapping invalid csi_stream_id: %u\n",
+					__func__, stream_index);
+			return -EINVAL;
+		}
+
+		(void)of_property_read_u32_index(np,
+			"nvidia,vi-mapping",
+			2 * index + 1,
+			&vi_unit_id);
+
+		/* check for valid vi-unit-id */
+		if (vi_unit_id >= MAX_VI_UNITS) {
+			dev_err(dev, "%s: mapping invalid vi_unit_id: %u\n",
+					__func__, vi_unit_id);
+			return -EINVAL;
+		}
+
+		map_table[stream_index] = vi_unit_id;
+	}
+
+	dev_dbg(dev, "%s: csi-stream to vi-instance mapping table size: %u\n",
+		__func__, info->num_csi_vi_maps);
+
+	for (index = 0; index < ARRAY_SIZE(info->vi_instance_table); index++)
+		dev_dbg(dev, "%s: vi_instance_table[%d] = %d\n",
+			__func__, index, info->vi_instance_table[index]);
+
+	return 0;
+}
+
+static int capture_vi_probe(struct platform_device *pdev)
+{
+	uint32_t ii;
+	int err = 0;
+	struct tegra_capture_vi_data *info;
+	struct device *dev = &pdev->dev;
+
+	dev_dbg(dev, "%s: tegra-camrtc-capture-vi probe\n", __func__);
+
+	info = devm_kzalloc(dev,
+			sizeof(*info), GFP_KERNEL);
+	if (info == NULL)
+		return -ENOMEM;
+
+	info->num_vi_devices = 0;
+
+	(void)of_property_read_u32(dev->of_node, "nvidia,vi-max-channels",
+			&info->max_vi_channels);
+	if (info->max_vi_channels == 0)
+		info->max_vi_channels = DEFAULT_VI_CHANNELS;
+
+	for (ii = 0; ; ii++) {
+		struct device_node *np;
+		struct platform_device *pvidev;
+
+		np = of_parse_phandle(dev->of_node, "nvidia,vi-devices", ii);
+		if (np == NULL)
+			break;
+
+		if (info->num_vi_devices >= ARRAY_SIZE(info->vi_pdevices)) {
+			of_node_put(np);
+			err = -EINVAL;
+			goto cleanup;
+		}
+
+		pvidev = of_find_device_by_node(np);
+		of_node_put(np);
+
+		if (pvidev == NULL) {
+			dev_WARN(dev, "vi node %d has no device\n", ii);
+			err = -ENODEV;
+			goto cleanup;
+		}
+
+		info->vi_pdevices[ii] = pvidev;
+		info->num_vi_devices++;
+	}
+
+	if (info->num_vi_devices < 1)
+		return -EINVAL;
+
+	platform_set_drvdata(pdev, info);
+
+	if (info->num_vi_devices == 1) {
+		dev_dbg(dev, "default 0 vi-unit-id for all csi-stream-ids\n");
+	} else {
+		/* read mapping table from DT for multiple VIs */
+		err = csi_vi_get_mapping_table(pdev);
+		if (err) {
+			dev_err(dev,
+				"%s: reading csi-to-vi mapping failed\n",
+				__func__);
+			goto cleanup;
+		}
+	}
+
+	err = vi_channel_drv_register(pdev, info->max_vi_channels);
+	if (err) {
+		vi_channel_drv_exit();
+		goto cleanup;
+	}
+
+	info->vi_common.mc_vi.vi = &info->vi_common;
+	info->vi_common.mc_vi.fops = &vi5_fops;
+	err = tegra_capture_vi_media_controller_init(
+			&info->vi_common.mc_vi, pdev);
+	if (err) {
+		dev_warn(&pdev->dev, "media controller init failed\n");
+		err = 0;
+	}
+
+	memset(channels, 0 , sizeof(channels));
+
+	return 0;
+
+cleanup:
+	for (ii = 0; ii < info->num_vi_devices; ii++)
+		put_device(&info->vi_pdevices[ii]->dev);
+
+	dev_err(dev, "%s: tegra-camrtc-capture-vi probe failed\n", __func__);
+	return err;
+}
+
+static int capture_vi_remove(struct platform_device *pdev)
+{
+	struct tegra_capture_vi_data *info;
+	uint32_t ii;
+	struct device *dev = &pdev->dev;
+
+	dev_dbg(dev, "%s:tegra-camrtc-capture-vi remove\n", __func__);
+
+	info = platform_get_drvdata(pdev);
+
+	for (ii = 0; ii < info->num_vi_devices; ii++)
+		put_device(&info->vi_pdevices[ii]->dev);
+
+	vi_channel_drv_unregister(&pdev->dev);
+	tegra_vi_media_controller_cleanup(&info->vi_common.mc_vi);
+	vi_channel_drv_exit();
+
+	return 0;
+}
+
+static const struct of_device_id capture_vi_of_match[] = {
+	{ .compatible = "nvidia,tegra-camrtc-capture-vi" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, capture_vi_of_match);
+
+static struct platform_driver capture_vi_driver = {
+	.probe = capture_vi_probe,
+	.remove = capture_vi_remove,
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "tegra-camrtc-capture-vi",
+		.of_match_table = capture_vi_of_match
+	}
+};
+
+static int __init capture_vi_init(void)
+{
+	int err;
+	err = vi_channel_drv_init();
+	if (err)
+		return err;
+
+	err = platform_driver_register(&capture_vi_driver);
+	if (err) {
+		vi_channel_drv_exit();
+		return err;
+	}
+
+	return 0;
+}
+static void __exit capture_vi_exit(void)
+{
+	vi_channel_drv_exit();
+	platform_driver_unregister(&capture_vi_driver);
+}
+
+module_init(capture_vi_init);
+module_exit(capture_vi_exit);
+
+MODULE_IMPORT_NS(DMA_BUF);
+MODULE_DESCRIPTION("tegra fusa-capture driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/platform/tegra/camera/vi/channel.c b/drivers/media/platform/tegra/camera/vi/channel.c
new file mode 100644
index 0000000..969703e
--- /dev/null
+++ b/drivers/media/platform/tegra/camera/vi/channel.c
@@ -0,0 +1,2837 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// SPDX-FileCopyrightText: Copyright (c) 2015-2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
+/*
+ * NVIDIA Tegra Video Input Device
+ */
+
+#include <nvidia/conftest.h>
+
+#include <linux/atomic.h>
+#include <linux/bitmap.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/nvhost.h>
+#include <linux/lcm.h>
+#include <linux/list.h>
+#include <linux/nospec.h>
+#include <linux/of.h>
+#include <linux/of_graph.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/semaphore.h>
+#include <linux/arm64-barrier.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-dev.h>
+#include <media/v4l2-fh.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-subdev.h>
+#include <media/videobuf2-core.h>
+#include <media/videobuf2-dma-contig.h>
+#include <media/tegra-v4l2-camera.h>
+#include <media/camera_common.h>
+#include <media/tegracam_utils.h>
+#include <media/tegra_camera_platform.h>
+#include <media/v4l2-dv-timings.h>
+#include <media/vi.h>
+
+#include <linux/clk/tegra.h>
+#define CREATE_TRACE_POINTS
+#include <trace/events/camera_common.h>
+
+#include "mipical/mipi_cal.h"
+
+#include <uapi/linux/nvhost_nvcsi_ioctl.h>
+#include "nvcsi/nvcsi.h"
+#include "nvcsi/deskew.h"
+
+#define TPG_CSI_GROUP_ID	10
+#define HDMI_IN_RATE 550000000
+/* number of lanes per brick */
+#define NUM_LANES_PER_BRICK	4
+
+static s64 queue_init_ts;
+
+static bool tegra_channel_verify_focuser(struct tegra_channel *chan)
+{
+	char *focuser;
+
+	/*
+	 * WAR - to avoid power on/off during open/close for sensor
+	 * nodes but not focuser nodes.
+	 * add an array when more focusers are available, this logic is
+	 * not needed once the focuser is bound to sensor channel
+	 */
+	focuser = strnstr(chan->video->name, "lc898212", sizeof(chan->video->name));
+
+	return (focuser != NULL);
+}
+
+static void gang_buffer_offsets(struct tegra_channel *chan)
+{
+	int i;
+	u32 offset = 0;
+
+	for (i = 0; i < chan->total_ports; i++) {
+		switch (chan->gang_mode) {
+		case CAMERA_NO_GANG_MODE:
+		case CAMERA_GANG_L_R:
+		case CAMERA_GANG_R_L:
+			offset = chan->gang_bytesperline;
+			break;
+		case CAMERA_GANG_T_B:
+		case CAMERA_GANG_B_T:
+			offset = chan->gang_sizeimage;
+			break;
+		default:
+			offset = 0;
+		}
+		offset = ((offset + TEGRA_SURFACE_ALIGNMENT - 1) &
+					~(TEGRA_SURFACE_ALIGNMENT - 1));
+		chan->buffer_offset[i] = i * offset;
+	}
+	spec_bar();
+}
+
+static u32 gang_mode_width(enum camera_gang_mode gang_mode,
+					unsigned int width)
+{
+	if ((gang_mode == CAMERA_GANG_L_R) ||
+		(gang_mode == CAMERA_GANG_R_L))
+		return width >> 1;
+	else
+		return width;
+}
+
+static u32 gang_mode_height(enum camera_gang_mode gang_mode,
+					unsigned int height)
+{
+	if ((gang_mode == CAMERA_GANG_T_B) ||
+		(gang_mode == CAMERA_GANG_B_T))
+		return height >> 1;
+	else
+		return height;
+}
+
+static void update_gang_mode_params(struct tegra_channel *chan)
+{
+	chan->gang_width = gang_mode_width(chan->gang_mode,
+						chan->format.width);
+	chan->gang_height = gang_mode_height(chan->gang_mode,
+						chan->format.height);
+	chan->gang_bytesperline = ((chan->gang_width *
+					chan->fmtinfo->bpp.numerator) /
+					chan->fmtinfo->bpp.denominator);
+	chan->gang_sizeimage = chan->gang_bytesperline *
+					chan->format.height;
+	gang_buffer_offsets(chan);
+}
+
+static void update_gang_mode(struct tegra_channel *chan)
+{
+	int width = chan->format.width;
+	int height = chan->format.height;
+
+	/*
+	 * At present only 720p, 1080p and 4k resolutions
+	 * are supported and only 4K requires gang mode
+	 * Update this code with CID for future extensions
+	 * Also, validate width and height of images based
+	 * on gang mode and surface stride alignment
+	 */
+	if ((width > 1920) && (height > 1080)) {
+		chan->gang_mode = CAMERA_GANG_L_R;
+		chan->valid_ports = chan->total_ports;
+	} else {
+		chan->gang_mode = CAMERA_NO_GANG_MODE;
+		chan->valid_ports = 1;
+	}
+
+	update_gang_mode_params(chan);
+}
+
+static u32 get_aligned_buffer_size(struct tegra_channel *chan,
+		u32 bytesperline, u32 height)
+{
+	u32 height_aligned;
+	u32 temp_size, size;
+
+	height_aligned = roundup(height, chan->height_align);
+	temp_size = bytesperline * height_aligned;
+	size = roundup(temp_size, chan->size_align);
+
+	return size;
+}
+
+static void tegra_channel_fmt_align(struct tegra_channel *chan,
+				const struct tegra_video_format *vfmt,
+				u32 *width, u32 *height, u32 *bytesperline)
+{
+	unsigned int min_bpl;
+	unsigned int max_bpl;
+	unsigned int align, fmt_align;
+	unsigned int temp_bpl;
+	unsigned int bpl;
+	unsigned int numerator, denominator;
+	const struct tegra_frac *bpp = &vfmt->bpp;
+
+	/* Init, if un-init */
+	if (!*width || !*height) {
+		*width = chan->format.width;
+		*height = chan->format.height;
+	}
+
+	denominator = (!bpp->denominator) ? 1 : bpp->denominator;
+	numerator = (!bpp->numerator) ? 1 : bpp->numerator;
+	/* The transfer alignment requirements are expressed in bytes. Compute
+	 * the minimum and maximum values, clamp the requested width and convert
+	 * it back to pixels.
+	 * use denominator for base width alignment when >1.
+	 * use bytesperline to adjust width for applicaton related requriements.
+	 */
+	fmt_align = (denominator == 1) ? numerator : 1;
+	align = lcm(chan->width_align, fmt_align);
+	align = align > 0 ? align : 1;
+	bpl = tegra_core_bytes_per_line(*width, align, vfmt);
+
+	/* Align stride */
+	if (chan->vi->fops->vi_stride_align)
+		chan->vi->fops->vi_stride_align(&bpl);
+
+	if (!*bytesperline)
+		*bytesperline = bpl;
+
+	/* Don't clamp the width based on bpl as stride and width can be
+	 * different. Aligned width also may force a sensor mode change other
+	 * than the requested one
+	 */
+	*height = clamp(*height, TEGRA_MIN_HEIGHT, TEGRA_MAX_HEIGHT);
+
+	/* Clamp the requested bytes per line value. If the maximum bytes per
+	 * line value is zero, the module doesn't support user configurable line
+	 * sizes. Override the requested value with the minimum in that case.
+	 */
+	min_bpl = bpl;
+	max_bpl = rounddown(TEGRA_MAX_WIDTH, chan->stride_align);
+	temp_bpl = roundup(*bytesperline, chan->stride_align);
+
+	*bytesperline = clamp(temp_bpl, min_bpl, max_bpl);
+}
+
+/* Check if sensor mode is interlaced and the type of interlaced mode */
+
+static void tegra_channel_set_interlace_mode(struct tegra_channel *chan)
+{
+	struct v4l2_subdev *sd = NULL;
+	struct camera_common_data *s_data = NULL;
+	struct device_node *node = NULL;
+	struct sensor_mode_properties *s_mode = NULL;
+
+	if (chan->subdev_on_csi) {
+		sd = chan->subdev_on_csi;
+		s_data = to_camera_common_data(sd->dev);
+		node = sd->dev->of_node;
+	}
+
+	if (s_data != NULL && node != NULL) {
+		int idx = s_data->mode_prop_idx;
+
+		if (idx < s_data->sensor_props.num_modes) {
+			s_mode = &s_data->sensor_props.sensor_modes[idx];
+			chan->is_interlaced =
+				s_mode->control_properties.is_interlaced;
+			if (chan->is_interlaced) {
+				if (s_mode->control_properties.interlace_type)
+					chan->interlace_type = Interleaved;
+				else
+					chan->interlace_type = Top_Bottom;
+			}
+		}
+	}
+}
+
+static void tegra_channel_update_format(struct tegra_channel *chan,
+		u32 width, u32 height, u32 fourcc,
+		const struct tegra_frac *bpp,
+		u32 preferred_stride)
+{
+	u32 denominator = (!bpp->denominator) ? 1 : bpp->denominator;
+	u32 numerator = (!bpp->numerator) ? 1 : bpp->numerator;
+	u32 bytesperline = (width * numerator / denominator);
+
+	/* Align stride */
+	if (chan->vi->fops->vi_stride_align)
+		chan->vi->fops->vi_stride_align(&bytesperline);
+
+	chan->format.width = width;
+	chan->format.height = height;
+	chan->format.pixelformat = fourcc;
+	chan->format.bytesperline = preferred_stride ?: bytesperline;
+	chan->buffer_offset[0] = 0;
+	chan->interlace_bplfactor = 1;
+
+	dev_dbg(&chan->video->dev,
+			"%s: Resolution= %dx%d bytesperline=%d\n",
+			__func__, width, height, chan->format.bytesperline);
+
+	tegra_channel_fmt_align(chan, chan->fmtinfo,
+				&chan->format.width,
+				&chan->format.height,
+				&chan->format.bytesperline);
+
+	/* Calculate the sizeimage per plane */
+	chan->format.sizeimage = get_aligned_buffer_size(chan,
+			chan->format.bytesperline, chan->format.height);
+
+	tegra_channel_set_interlace_mode(chan);
+	/* Double the size of allocated buffer for interlaced sensor modes */
+	if (chan->is_interlaced)
+		chan->format.sizeimage *= 2;
+
+	if (fourcc == V4L2_PIX_FMT_NV16)
+		chan->format.sizeimage *= 2;
+}
+
+static void tegra_channel_fmts_bitmap_init(struct tegra_channel *chan)
+{
+	int ret, pixel_format_index = 0, init_code = 0;
+	struct v4l2_subdev *subdev = chan->subdev_on_csi;
+	struct v4l2_subdev_format fmt = {
+		.pad = 0,
+		.which = V4L2_SUBDEV_FORMAT_ACTIVE,
+	};
+	struct v4l2_subdev_mbus_code_enum code = {
+		.which = V4L2_SUBDEV_FORMAT_ACTIVE,
+	};
+
+	struct v4l2_subdev_pad_config pad_cfg;
+	struct v4l2_subdev_state cfg = {.pads = &pad_cfg};
+	bitmap_zero(chan->fmts_bitmap, MAX_FORMAT_NUM);
+
+	/*
+	 * Initialize all the formats available from
+	 * the sub-device and extract the corresponding
+	 * index from the pre-defined video formats and initialize
+	 * the channel default format with the active code
+	 * Index zero as the only sub-device is sensor
+	 */
+	while (1) {
+		ret = v4l2_subdev_call(subdev, pad, enum_mbus_code,
+				       &cfg, &code);
+		if (ret < 0)
+			/* no more formats */
+			break;
+
+		pixel_format_index =
+			tegra_core_get_idx_by_code(chan, code.code, 0);
+		while (pixel_format_index >= 0) {
+			bitmap_set(chan->fmts_bitmap, pixel_format_index, 1);
+			/* Set init_code to the first matched format */
+			if (!init_code)
+				init_code = code.code;
+			/* Look for other formats with the same mbus code */
+			pixel_format_index = tegra_core_get_idx_by_code(chan,
+				code.code, pixel_format_index + 1);
+		}
+
+		code.index++;
+	}
+
+	if (!init_code) {
+		pixel_format_index =
+			tegra_core_get_idx_by_code(chan, TEGRA_VF_DEF, 0);
+		if (pixel_format_index >= 0) {
+			bitmap_set(chan->fmts_bitmap, pixel_format_index, 1);
+			init_code = TEGRA_VF_DEF;
+		}
+	}
+		/* Get the format based on active code of the sub-device */
+	ret = v4l2_subdev_call(subdev, pad, get_fmt, &cfg, &fmt);
+	if (ret)
+		return;
+
+	/* Initiate the channel format to the first matched format */
+	chan->fmtinfo =
+		tegra_core_get_format_by_code(chan, fmt.format.code, 0);
+	if (!chan->fmtinfo)
+		return;
+
+	v4l2_fill_pix_format(&chan->format, &fmt.format);
+	tegra_channel_update_format(chan, chan->format.width,
+				chan->format.height,
+				chan->fmtinfo->fourcc,
+				&chan->fmtinfo->bpp,
+				chan->preferred_stride);
+
+	if (chan->total_ports > 1)
+		update_gang_mode(chan);
+}
+
+/*
+ * -----------------------------------------------------------------------------
+ * Tegra channel frame setup and capture operations
+ * -----------------------------------------------------------------------------
+ */
+/*
+ * Update the timestamp of the buffer
+ */
+void set_timestamp(struct tegra_channel_buffer *buf,
+			const struct timespec64 *ts)
+{
+	buf->buf.vb2_buf.timestamp = (u64)timespec64_to_ns(ts);
+}
+EXPORT_SYMBOL(set_timestamp);
+
+void release_buffer(struct tegra_channel *chan,
+			struct tegra_channel_buffer *buf)
+{
+	struct vb2_v4l2_buffer *vbuf = &buf->buf;
+	s64 frame_arrived_ts = 0;
+
+	/* release one frame */
+	vbuf->sequence = chan->sequence++;
+	vbuf->field = V4L2_FIELD_NONE;
+	vb2_set_plane_payload(&vbuf->vb2_buf,
+		0, chan->format.sizeimage);
+
+	/*
+	 * WAR to force buffer state if capture state is not good
+	 * WAR - After sync point timeout or error frame capture
+	 * the second buffer is intermittently frame of zeros
+	 * with no error status or padding.
+	 */
+	if (chan->capture_state != CAPTURE_GOOD || vbuf->sequence < 2)
+		buf->state = VB2_BUF_STATE_ERROR;
+
+	if (chan->sequence == 1) {
+		/*
+		 * Evaluate the initial capture latency between videobuf2 queue
+		 * and first captured frame release to user-space.
+		 */
+		frame_arrived_ts = ktime_to_ms(ktime_get());
+		dev_dbg(&chan->video->dev,
+			"%s: capture init latency is %lld ms\n",
+			__func__, (frame_arrived_ts - queue_init_ts));
+	}
+
+	dev_dbg(&chan->video->dev,
+		"%s: release buf[%p] frame[%d] to user-space\n",
+		__func__, buf, chan->sequence);
+	vb2_buffer_done(&vbuf->vb2_buf, buf->state);
+}
+EXPORT_SYMBOL(release_buffer);
+
+/*
+ * `buf` has been successfully setup to receive a frame and is
+ * "in flight" through the VI hardware. We are currently waiting
+ * on it to be filled. Moves the pointer into the `release` list
+ * for the release thread to wait on.
+ */
+void enqueue_inflight(struct tegra_channel *chan,
+			struct tegra_channel_buffer *buf)
+{
+	/* Put buffer into the release queue */
+	spin_lock(&chan->release_lock);
+	list_add_tail(&buf->queue, &chan->release);
+	spin_unlock(&chan->release_lock);
+
+	/* Wake up kthread for release */
+	wake_up_interruptible(&chan->release_wait);
+}
+EXPORT_SYMBOL(enqueue_inflight);
+
+struct tegra_channel_buffer *dequeue_inflight(struct tegra_channel *chan)
+{
+	struct tegra_channel_buffer *buf = NULL;
+
+	spin_lock(&chan->release_lock);
+	if (list_empty(&chan->release)) {
+		spin_unlock(&chan->release_lock);
+		return NULL;
+	}
+
+	buf = list_entry(chan->release.next,
+			 struct tegra_channel_buffer, queue);
+
+	if (buf)
+		list_del_init(&buf->queue);
+
+	spin_unlock(&chan->release_lock);
+	return buf;
+}
+EXPORT_SYMBOL(dequeue_inflight);
+
+void tegra_channel_init_ring_buffer(struct tegra_channel *chan)
+{
+	chan->released_bufs = 0;
+	chan->num_buffers = 0;
+	chan->save_index = 0;
+	chan->free_index = 0;
+	chan->bfirst_fstart = false;
+	chan->capture_descr_index = 0;
+	chan->capture_descr_sequence = 0;
+	chan->queue_error = false;
+}
+EXPORT_SYMBOL(tegra_channel_init_ring_buffer);
+
+void free_ring_buffers(struct tegra_channel *chan, int frames)
+{
+	struct vb2_v4l2_buffer *vbuf;
+	s64 frame_arrived_ts = 0;
+
+	spin_lock(&chan->buffer_lock);
+
+	if (frames == 0)
+		frames = chan->num_buffers;
+
+	while (frames > 0) {
+		vbuf = chan->buffers[chan->free_index];
+
+		/* Skip updating the buffer sequence with channel sequence
+		 * for interlaced captures and this instead will be updated
+		 * with frame id received from CSI with capture complete
+		 */
+		if (!chan->is_interlaced)
+			vbuf->sequence = chan->sequence++;
+		else
+			chan->sequence++;
+		/* release one frame */
+		vbuf->field = V4L2_FIELD_NONE;
+		vb2_set_plane_payload(&vbuf->vb2_buf,
+			0, chan->format.sizeimage);
+
+		/*
+		 * WAR to force buffer state if capture state is not good
+		 * WAR - After sync point timeout or error frame capture
+		 * the second buffer is intermittently frame of zeros
+		 * with no error status or padding.
+		 */
+		/* This will drop the first two frames. Disable for now. */
+		if (chan->capture_state != CAPTURE_GOOD ||
+			chan->released_bufs < 2)
+			chan->buffer_state[chan->free_index] =
+						VB2_BUF_STATE_ERROR;
+
+		if (chan->sequence == 1) {
+			/*
+			 * Evaluate the initial capture latency
+			 * between videobuf2 queue and first captured
+			 * frame release to user-space.
+			 */
+			frame_arrived_ts = ktime_to_ms(ktime_get());
+			dev_dbg(&chan->video->dev,
+				"%s: capture init latency is %lld ms\n",
+				__func__, (frame_arrived_ts - queue_init_ts));
+		}
+		vb2_buffer_done(&vbuf->vb2_buf,
+			chan->buffer_state[chan->free_index++]);
+
+		if (chan->free_index >= chan->capture_queue_depth)
+			chan->free_index = 0;
+		chan->num_buffers--;
+		chan->released_bufs++;
+		frames--;
+	}
+	spin_unlock(&chan->buffer_lock);
+}
+EXPORT_SYMBOL(free_ring_buffers);
+
+static void add_buffer_to_ring(struct tegra_channel *chan,
+				struct vb2_v4l2_buffer *vb)
+{
+	/* save the buffer to the ring first */
+	/* Mark buffer state as error before start */
+	spin_lock(&chan->buffer_lock);
+	chan->buffer_state[chan->save_index] = VB2_BUF_STATE_ERROR;
+	chan->buffers[chan->save_index++] = vb;
+	if (chan->save_index >= chan->capture_queue_depth)
+		chan->save_index = 0;
+	chan->num_buffers++;
+	spin_unlock(&chan->buffer_lock);
+}
+
+static void update_state_to_buffer(struct tegra_channel *chan, int state)
+{
+	int save_index = (chan->save_index - PREVIOUS_BUFFER_DEC_INDEX);
+
+	/* save index decrements by 2 as 3 bufs are added in ring buffer */
+	if (save_index < 0)
+		save_index += chan->capture_queue_depth;
+	/* update state for the previous buffer */
+	chan->buffer_state[save_index] = state;
+
+	/* for timeout/error case update the current buffer state as well */
+	if (chan->capture_state != CAPTURE_GOOD)
+		chan->buffer_state[chan->save_index] = state;
+}
+
+void tegra_channel_ring_buffer(struct tegra_channel *chan,
+					struct vb2_v4l2_buffer *vb,
+					struct timespec64 *ts, int state)
+{
+	if (!chan->bfirst_fstart)
+		chan->bfirst_fstart = true;
+	else
+		update_state_to_buffer(chan, state);
+
+	/* Capture state is not GOOD, release all buffers and re-init state */
+	if (chan->capture_state != CAPTURE_GOOD) {
+		free_ring_buffers(chan, chan->num_buffers);
+		tegra_channel_init_ring_buffer(chan);
+		return;
+	} else {
+		/* TODO: granular time code information */
+		vb->timecode.seconds = ts->tv_sec;
+	}
+
+	/* release buffer N at N+2 frame start event */
+	if (chan->num_buffers >= (chan->capture_queue_depth - 1))
+		free_ring_buffers(chan, 1);
+}
+EXPORT_SYMBOL(tegra_channel_ring_buffer);
+
+void tegra_channel_ec_close(struct tegra_mc_vi *vi)
+{
+	struct tegra_channel *chan;
+
+	/* clear all channles sync point fifo context */
+	list_for_each_entry(chan, &vi->vi_chans, list) {
+		memset(&chan->syncpoint_fifo[0],
+			0, sizeof(chan->syncpoint_fifo));
+	}
+}
+EXPORT_SYMBOL(tegra_channel_ec_close);
+
+struct tegra_channel_buffer *dequeue_buffer(struct tegra_channel *chan,
+	bool requeue)
+{
+	struct tegra_channel_buffer *buf = NULL;
+
+	spin_lock(&chan->start_lock);
+	if (list_empty(&chan->capture))
+		goto done;
+
+	buf = list_entry(chan->capture.next,
+			 struct tegra_channel_buffer, queue);
+	list_del_init(&buf->queue);
+
+	if (requeue) {
+		/* add dequeued buffer to the ring buffer */
+		add_buffer_to_ring(chan, &buf->buf);
+	}
+done:
+	spin_unlock(&chan->start_lock);
+	return buf;
+}
+EXPORT_SYMBOL(dequeue_buffer);
+
+struct tegra_channel_buffer *dequeue_dequeue_buffer(struct tegra_channel *chan)
+{
+	struct tegra_channel_buffer *buf = NULL;
+
+	spin_lock(&chan->dequeue_lock);
+
+	if (list_empty(&chan->dequeue))
+		goto done;
+
+	buf = list_entry(chan->dequeue.next, struct tegra_channel_buffer,
+		queue);
+	list_del_init(&buf->queue);
+
+done:
+	spin_unlock(&chan->dequeue_lock);
+	return buf;
+}
+EXPORT_SYMBOL(dequeue_dequeue_buffer);
+
+int tegra_channel_error_recover(struct tegra_channel *chan, bool queue_error)
+{
+	struct tegra_mc_vi *vi = chan->vi;
+	int err = 0;
+
+	if (!(vi->fops && vi->fops->vi_error_recover)) {
+		err = -EIO;
+		goto done;
+	}
+
+	dev_warn(vi->dev, "err_rec: attempting to reset the capture channel\n");
+
+	err = vi->fops->vi_error_recover(chan, queue_error);
+	if (!err)
+		dev_warn(vi->dev,
+			"err_rec: successfully reset the capture channel\n");
+
+done:
+	return err;
+}
+EXPORT_SYMBOL(tegra_channel_error_recover);
+
+static struct device *tegra_channel_get_vi_unit(struct tegra_channel *chan)
+{
+	struct tegra_mc_vi *vi = chan->vi;
+	struct device *vi_unit_dev;
+
+	if (vi->fops->vi_unit_get_device_handle)
+		vi->fops->vi_unit_get_device_handle(vi->ndev, chan->port[0],
+			&vi_unit_dev);
+	else
+		vi_unit_dev = vi->dev;
+
+	return vi_unit_dev;
+}
+
+/*
+ * -----------------------------------------------------------------------------
+ * videobuf2 queue operations
+ * -----------------------------------------------------------------------------
+ */
+static int
+tegra_channel_queue_setup(struct vb2_queue *vq,
+		     unsigned int *nbuffers, unsigned int *nplanes,
+		     unsigned int sizes[], struct device *alloc_devs[])
+{
+	struct tegra_channel *chan = vb2_get_drv_priv(vq);
+	struct tegra_mc_vi *vi = chan->vi;
+	int ret = 0;
+
+
+	/* In some cases, if nplanes is valid
+	 * and the requested image size is less than the
+	 * actual image size, we need to return EINVAL.
+	 * Previously, we were just updating sizes[0] irrespective
+	 * of the requested image size. Although this did not harm the
+	 * flow, according to "v4l2-compliance", we need to check if
+	 * the requested size is invalid.
+	 */
+	if (*nplanes) {
+		if (sizes[0] < chan->format.sizeimage) {
+			pr_err("%s: sizes[0] = %d chan->format.sizeimage = %d ...\n"
+					,__func__,sizes[0],chan->format.sizeimage);
+			return -EINVAL;
+		}
+	} else {
+		sizes[0] = chan->format.sizeimage;
+	}
+
+	*nplanes = 1;
+	alloc_devs[0] = tegra_channel_get_vi_unit(chan);
+
+	if (vi->fops && vi->fops->vi_setup_queue)
+		return vi->fops->vi_setup_queue(chan, nbuffers);
+	return ret;
+}
+
+int tegra_channel_alloc_buffer_queue(struct tegra_channel *chan,
+	unsigned int num_buffers)
+{
+	struct device *vi_unit_dev = tegra_channel_get_vi_unit(chan);
+
+	chan->buffer_state = devm_krealloc(vi_unit_dev, chan->buffer_state,
+		(num_buffers * sizeof(*chan->buffer_state)),
+		GFP_KERNEL | __GFP_ZERO);
+	if (!chan->buffer_state)
+		goto alloc_error;
+
+	chan->buffers = devm_krealloc(vi_unit_dev, chan->buffers,
+		(num_buffers * sizeof(*chan->buffers)),
+		GFP_KERNEL | __GFP_ZERO);
+	if (!chan->buffers)
+		goto alloc_error;
+
+	chan->capture_queue_depth = num_buffers;
+
+	return 0;
+
+alloc_error:
+	dev_err(chan->vi->dev,
+		"error: could not allocate memory for %u size buffer queue\n",
+		num_buffers);
+
+	tegra_channel_dealloc_buffer_queue(chan);
+
+	return -ENOMEM;
+}
+EXPORT_SYMBOL(tegra_channel_alloc_buffer_queue);
+
+void tegra_channel_dealloc_buffer_queue(struct tegra_channel *chan)
+{
+	struct device *vi_unit_dev = tegra_channel_get_vi_unit(chan);
+
+	if (chan->buffer_state)
+		devm_kfree(vi_unit_dev, chan->buffer_state);
+	if (chan->buffers)
+		devm_kfree(vi_unit_dev, chan->buffers);
+}
+
+static int tegra_channel_buffer_prepare(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	struct tegra_channel *chan = vb2_get_drv_priv(vb->vb2_queue);
+	struct tegra_channel_buffer *buf = to_tegra_channel_buffer(vbuf);
+
+	buf->chan = chan;
+	vb2_set_plane_payload(&vbuf->vb2_buf, 0, chan->format.sizeimage);
+#if IS_ENABLED(CONFIG_VIDEOBUF2_DMA_CONTIG)
+	buf->addr = vb2_dma_contig_plane_dma_addr(vb, 0);
+#endif
+
+	return 0;
+}
+
+static void tegra_channel_buffer_queue(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	struct tegra_channel *chan = vb2_get_drv_priv(vb->vb2_queue);
+	struct tegra_channel_buffer *buf = to_tegra_channel_buffer(vbuf);
+
+	/* for bypass mode - do nothing */
+	if (chan->bypass)
+		return;
+
+	if (!queue_init_ts) {
+		/*
+		 * Record videobuf2 queue initial timestamp.
+		 * Note: latency is accurate when streaming is already turned ON
+		 */
+		queue_init_ts = ktime_to_ms(ktime_get());
+	}
+
+	/* Put buffer into the capture queue */
+	spin_lock(&chan->start_lock);
+	list_add_tail(&buf->queue, &chan->capture);
+	spin_unlock(&chan->start_lock);
+
+	/* Wake up kthread for capture */
+	wake_up_interruptible(&chan->start_wait);
+}
+
+
+static void tegra_channel_queued_buf_done_single_thread(
+		struct tegra_channel *chan,
+		enum vb2_buffer_state state)
+{
+	struct tegra_channel_buffer *buf, *nbuf;
+
+	/* delete capture list */
+	spin_lock(&chan->start_lock);
+	list_for_each_entry_safe(buf, nbuf, &chan->capture, queue) {
+		vb2_buffer_done(&buf->buf.vb2_buf, state);
+		list_del(&buf->queue);
+	}
+	spin_unlock(&chan->start_lock);
+
+	/* delete dequeue list */
+	spin_lock(&chan->dequeue_lock);
+	list_for_each_entry_safe(buf, nbuf, &chan->dequeue, queue) {
+		vb2_buffer_done(&buf->buf.vb2_buf, state);
+		list_del(&buf->queue);
+	}
+	spin_unlock(&chan->dequeue_lock);
+}
+
+static void tegra_channel_queued_buf_done_multi_thread(
+		struct tegra_channel *chan,
+		enum vb2_buffer_state state)
+{
+	struct tegra_channel_buffer *buf, *nbuf;
+	spinlock_t *lock = &chan->start_lock;
+	spinlock_t *release_lock = &chan->release_lock;
+	struct list_head *q = &chan->capture;
+	struct list_head *rel_q = &chan->release;
+
+	spin_lock(lock);
+	list_for_each_entry_safe(buf, nbuf, q, queue) {
+		vb2_buffer_done(&buf->buf.vb2_buf, state);
+		list_del(&buf->queue);
+	}
+	spin_unlock(lock);
+
+	/* delete release list */
+	spin_lock(release_lock);
+	list_for_each_entry_safe(buf, nbuf, rel_q, queue) {
+		vb2_buffer_done(&buf->buf.vb2_buf, state);
+		list_del(&buf->queue);
+	}
+	spin_unlock(release_lock);
+}
+
+/* Return all queued buffers back to videobuf2 */
+void tegra_channel_queued_buf_done(struct tegra_channel *chan,
+	enum vb2_buffer_state state, bool multi_queue)
+{
+	if (multi_queue)
+		tegra_channel_queued_buf_done_multi_thread(chan, state);
+	else
+		tegra_channel_queued_buf_done_single_thread(chan, state);
+}
+EXPORT_SYMBOL(tegra_channel_queued_buf_done);
+
+/*
+ * -----------------------------------------------------------------------------
+ * subdevice set/unset operations
+ * -----------------------------------------------------------------------------
+ */
+int tegra_channel_write_blobs(struct tegra_channel *chan)
+{
+	struct v4l2_subdev *sd = NULL;
+	struct camera_common_data *s_data = NULL;
+
+	/* for TPG, do nothing */
+	if (chan->pg_mode)
+		return 0;
+
+	sd = chan->subdev_on_csi;
+	if (!sd)
+		return -EINVAL;
+
+	s_data = to_camera_common_data(sd->dev);
+	if (!s_data)
+		return 0;
+
+	if (!is_tvcf_supported(s_data->version))
+		return 0;
+
+	return tegracam_write_blobs(s_data->tegracam_ctrl_hdl);
+}
+EXPORT_SYMBOL(tegra_channel_write_blobs);
+
+int tegra_channel_set_stream(struct tegra_channel *chan, bool on)
+{
+	int num_sd;
+	int ret = 0;
+	int err = 0;
+	int max_deskew_attempts = 5;
+	int deskew_attempts = 0;
+	struct v4l2_subdev *sd;
+
+	if (atomic_read(&chan->is_streaming) == on)
+		return 0;
+	trace_tegra_channel_set_stream("enable", on);
+
+	if (on) {
+		tegra_camera_update_clknbw(chan, true);
+		/* Enable CSI before sensor. Reason is as follows:
+		 * CSI is able to catch the very first clk transition.
+		 */
+		while (deskew_attempts < max_deskew_attempts) {
+			for (num_sd = 0; num_sd < chan->num_subdevs; num_sd++) {
+				sd = chan->subdev[num_sd];
+
+				trace_tegra_channel_set_stream(sd->name, on);
+				err = v4l2_subdev_call(sd, video, s_stream, on);
+				if (!ret && err < 0 && err != -ENOIOCTLCMD)
+					ret = err;
+			}
+			if (!chan->bypass && !chan->pg_mode &&
+					chan->deskew_ctx->deskew_lanes) {
+				err = nvcsi_deskew_apply_check(
+							chan->deskew_ctx);
+				++deskew_attempts;
+				if (err && deskew_attempts <
+							max_deskew_attempts) {
+					for (num_sd = 0;
+						num_sd < chan->num_subdevs;
+								num_sd++) {
+						sd = chan->subdev[num_sd];
+						trace_tegra_channel_set_stream(
+							sd->name, false);
+						err = v4l2_subdev_call(sd,
+							video,
+							s_stream, false);
+					}
+				} else
+					break;
+			} else
+				break;
+		}
+	} else {
+		for (num_sd = chan->num_subdevs - 1; num_sd >= 0; num_sd--) {
+			sd = chan->subdev[num_sd];
+
+			trace_tegra_channel_set_stream(sd->name, on);
+			err = v4l2_subdev_call(sd, video, s_stream, on);
+			if (!ret && err < 0 && err != -ENOIOCTLCMD)
+				ret = err;
+		}
+		spec_bar();
+
+		tegra_camera_update_clknbw(chan, false);
+	}
+
+	if (ret == 0)
+		atomic_set(&chan->is_streaming, on);
+	return ret;
+}
+EXPORT_SYMBOL(tegra_channel_set_stream);
+
+int tegra_channel_set_power(struct tegra_channel *chan, bool on)
+{
+	int num_sd;
+	int ret = 0;
+	int err = 0;
+	struct v4l2_subdev *sd;
+
+	/* First power on and last power off will turn on/off the subdevices */
+	if (on) {
+		if (atomic_add_return(1, &chan->power_on_refcnt) != 1)
+			return 0;
+	} else {
+		if (!atomic_dec_and_test(&chan->power_on_refcnt))
+			return 0;
+	}
+
+	/* Power on CSI at the last to complete calibration of mipi lanes */
+	for (num_sd = chan->num_subdevs - 1; num_sd >= 0; num_sd--) {
+		sd = chan->subdev[num_sd];
+
+		trace_tegra_channel_set_power(sd->name, on);
+		err = v4l2_subdev_call(sd, core, s_power, on);
+		if (!ret && err < 0 && err != -ENOIOCTLCMD)
+			ret = err;
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL(tegra_channel_set_power);
+
+static int tegra_channel_start_streaming(struct vb2_queue *vq, u32 count)
+{
+	struct tegra_channel *chan = vb2_get_drv_priv(vq);
+	struct tegra_mc_vi *vi = chan->vi;
+
+	if (vi->fops) {
+		int ret = 0;
+
+		/* power on hw at the start of streaming */
+		ret = vi->fops->vi_power_on(chan);
+		if (ret < 0)
+			return ret;
+
+		return vi->fops->vi_start_streaming(vq, count);
+	}
+	return 0;
+}
+
+static void tegra_channel_stop_streaming(struct vb2_queue *vq)
+{
+	struct tegra_channel *chan = vb2_get_drv_priv(vq);
+	struct tegra_mc_vi *vi = chan->vi;
+
+	if (vi->fops) {
+		vi->fops->vi_stop_streaming(vq);
+		vi->fops->vi_power_off(chan);
+	}
+
+	/* Clean-up recorded videobuf2 queue initial timestamp */
+	queue_init_ts = 0;
+}
+
+static const struct vb2_ops tegra_channel_queue_qops = {
+	.queue_setup = tegra_channel_queue_setup,
+	.buf_prepare = tegra_channel_buffer_prepare,
+	.buf_queue = tegra_channel_buffer_queue,
+	.wait_prepare = vb2_ops_wait_prepare,
+	.wait_finish = vb2_ops_wait_finish,
+	.start_streaming = tegra_channel_start_streaming,
+	.stop_streaming = tegra_channel_stop_streaming,
+};
+
+/* -----------------------------------------------------------------------------
+ * V4L2 ioctls
+ */
+
+static int
+tegra_channel_querycap(struct file *file, void *fh, struct v4l2_capability *cap)
+{
+	struct tegra_channel *chan = video_drvdata(file);
+	ssize_t len;
+	int ret = 0;
+
+	cap->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;
+	cap->device_caps |= V4L2_CAP_EXT_PIX_FORMAT;
+	cap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;
+
+	len = strscpy(cap->driver, "tegra-video", sizeof(cap->driver));
+	if (len < 0)
+		return -ENAMETOOLONG;
+
+	len = strscpy(cap->card, chan->video->name, sizeof(cap->card));
+	if (len < 0)
+		return -ENAMETOOLONG;
+
+	ret = snprintf(cap->bus_info, sizeof(cap->bus_info), "platform:%s:%u",
+		 dev_name(chan->vi->dev), chan->port[0]);
+	if (ret < 0)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int
+tegra_channel_enum_framesizes(struct file *file, void *fh,
+			      struct v4l2_frmsizeenum *sizes)
+{
+	struct tegra_channel *chan = video_drvdata(file);
+	struct v4l2_subdev *sd = chan->subdev_on_csi;
+	struct v4l2_subdev_frame_size_enum fse;
+	struct v4l2_subdev_pad_config pad_cfg;
+	struct v4l2_subdev_state cfg = {.pads = &pad_cfg};
+	int ret = 0;
+
+	/* Convert v4l2 pixel format (fourcc) into media bus format code */
+	fse.code = tegra_core_get_code_by_fourcc(chan, sizes->pixel_format, 0);
+	if (fse.code < 0)
+		return -EINVAL;
+	fse.index = sizes->index;
+	fse.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+	fse.pad = 0;
+
+	ret = v4l2_subdev_call(sd, pad, enum_frame_size, &cfg, &fse);
+
+	if (!ret) {
+		sizes->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+		sizes->discrete.width = fse.max_width;
+		sizes->discrete.height = fse.max_height;
+	}
+
+	return ret;
+}
+
+static int
+tegra_channel_enum_frameintervals(struct file *file, void *fh,
+			      struct v4l2_frmivalenum *intervals)
+{
+	struct tegra_channel *chan = video_drvdata(file);
+	struct v4l2_subdev *sd = chan->subdev_on_csi;
+	struct v4l2_subdev_frame_interval_enum fie;
+	struct v4l2_subdev_pad_config pad_cfg;
+	struct v4l2_subdev_state cfg = {.pads = &pad_cfg};
+	int ret = 0;
+
+	/* Convert v4l2 pixel format (fourcc) into media bus format code */
+	fie.code = tegra_core_get_code_by_fourcc(
+		chan, intervals->pixel_format, 0);
+	if (fie.code < 0)
+		return -EINVAL;
+	fie.index = intervals->index;
+	fie.width = intervals->width;
+	fie.height = intervals->height;
+	fie.pad  = 0;
+	fie.which = V4L2_SUBDEV_FORMAT_TRY;
+
+	ret = v4l2_subdev_call(sd, pad, enum_frame_interval, &cfg, &fie);
+
+	if (!ret) {
+		intervals->type = V4L2_FRMIVAL_TYPE_DISCRETE;
+		intervals->discrete.numerator = fie.interval.numerator;
+		intervals->discrete.denominator = fie.interval.denominator;
+	}
+
+	return ret;
+}
+
+static int
+tegra_channel_enum_format(struct file *file, void *fh, struct v4l2_fmtdesc *f)
+{
+	struct tegra_channel *chan = video_drvdata(file);
+	unsigned int index = 0, i;
+	unsigned long *fmts_bitmap = chan->fmts_bitmap;
+
+	if (f->index >= bitmap_weight(fmts_bitmap, MAX_FORMAT_NUM))
+		return -EINVAL;
+
+	for (i = 0; i < f->index + 1; i++, index++)
+		index = find_next_bit(fmts_bitmap, MAX_FORMAT_NUM, index);
+
+	index -= 1;
+	f->pixelformat = tegra_core_get_fourcc_by_idx(chan, index);
+
+	if (f->pixelformat == V4L2_PIX_FMT_AVT_G4C2) {
+		const struct tegra_video_format *format = tegra_core_get_format_by_fourcc(chan, V4L2_PIX_FMT_AVT_G4C2);
+		memcpy(&f->description[0], &format->description[0], 32);
+	}
+
+	
+
+	return 0;
+}
+
+static int
+tegra_channel_g_edid(struct file *file, void *fh, struct v4l2_edid *edid)
+{
+	struct tegra_channel *chan = video_drvdata(file);
+	struct v4l2_subdev *sd = chan->subdev_on_csi;
+
+	if (!v4l2_subdev_has_op(sd, pad, get_edid))
+		return -ENOTTY;
+
+	return v4l2_subdev_call(sd, pad, get_edid, edid);
+}
+
+static int
+tegra_channel_s_edid(struct file *file, void *fh, struct v4l2_edid *edid)
+{
+	struct tegra_channel *chan = video_drvdata(file);
+	struct v4l2_subdev *sd = chan->subdev_on_csi;
+
+	if (!v4l2_subdev_has_op(sd, pad, set_edid))
+		return -ENOTTY;
+
+	return v4l2_subdev_call(sd, pad, set_edid, edid);
+}
+
+static int
+tegra_channel_g_dv_timings(struct file *file, void *fh,
+		struct v4l2_dv_timings *timings)
+{
+	struct tegra_channel *chan = video_drvdata(file);
+
+#if defined(NV_V4L2_SUBDEV_PAD_OPS_STRUCT_HAS_DV_TIMINGS) /* Linux v6.10 */
+	if (!v4l2_subdev_has_op(chan->subdev_on_csi, pad, g_dv_timings))
+		return -ENOTTY;
+
+	return v4l2_device_call_until_err(chan->video->v4l2_dev,
+			chan->grp_id, pad, g_dv_timings, 0, timings);
+#else
+	if (!v4l2_subdev_has_op(chan->subdev_on_csi, video, g_dv_timings))
+		return -ENOTTY;
+
+	return v4l2_device_call_until_err(chan->video->v4l2_dev,
+			chan->grp_id, video, g_dv_timings, timings);
+#endif
+}
+
+static int
+tegra_channel_s_dv_timings(struct file *file, void *fh,
+		struct v4l2_dv_timings *timings)
+{
+	struct tegra_channel *chan = video_drvdata(file);
+	struct v4l2_bt_timings *bt = &timings->bt;
+	struct v4l2_dv_timings curr_timings;
+	int ret;
+
+#if defined(NV_V4L2_SUBDEV_PAD_OPS_STRUCT_HAS_DV_TIMINGS) /* Linux v6.10 */
+	if (!v4l2_subdev_has_op(chan->subdev_on_csi, pad, s_dv_timings))
+#else
+	if (!v4l2_subdev_has_op(chan->subdev_on_csi, video, s_dv_timings))
+#endif
+		return -ENOTTY;
+
+	ret = tegra_channel_g_dv_timings(file, fh, &curr_timings);
+	if (ret)
+		return ret;
+
+	if (tegra_v4l2_match_dv_timings(timings, &curr_timings, 0, false))
+		return 0;
+
+	if (vb2_is_busy(&chan->queue))
+		return -EBUSY;
+
+#if defined(NV_V4L2_SUBDEV_PAD_OPS_STRUCT_HAS_DV_TIMINGS) /* Linux v6.10 */
+	ret = v4l2_device_call_until_err(chan->video->v4l2_dev,
+			chan->grp_id, pad, s_dv_timings, 0, timings);
+#else
+	ret = v4l2_device_call_until_err(chan->video->v4l2_dev,
+			chan->grp_id, video, s_dv_timings, timings);
+#endif
+	if (!ret)
+		tegra_channel_update_format(chan, bt->width, bt->height,
+			chan->fmtinfo->fourcc, &chan->fmtinfo->bpp,
+			chan->preferred_stride);
+
+	if (chan->total_ports > 1)
+		update_gang_mode(chan);
+
+	return ret;
+}
+
+static int
+tegra_channel_query_dv_timings(struct file *file, void *fh,
+		struct v4l2_dv_timings *timings)
+{
+	struct tegra_channel *chan = video_drvdata(file);
+
+#if defined(NV_V4L2_SUBDEV_PAD_OPS_STRUCT_HAS_DV_TIMINGS) /* Linux v6.10 */
+	if (!v4l2_subdev_has_op(chan->subdev_on_csi, pad, query_dv_timings))
+		return -ENOTTY;
+
+	return v4l2_device_call_until_err(chan->video->v4l2_dev,
+			chan->grp_id, pad, query_dv_timings, 0, timings);
+#else
+	if (!v4l2_subdev_has_op(chan->subdev_on_csi, video, query_dv_timings))
+		return -ENOTTY;
+
+	return v4l2_device_call_until_err(chan->video->v4l2_dev,
+			chan->grp_id, video, query_dv_timings, timings);
+#endif
+}
+
+static int
+tegra_channel_enum_dv_timings(struct file *file, void *fh,
+		struct v4l2_enum_dv_timings *timings)
+{
+	struct tegra_channel *chan = video_drvdata(file);
+	struct v4l2_subdev *sd = chan->subdev_on_csi;
+
+	if (!v4l2_subdev_has_op(sd, pad, enum_dv_timings))
+		return -ENOTTY;
+
+	return v4l2_subdev_call(sd, pad, enum_dv_timings, timings);
+}
+
+static int
+tegra_channel_dv_timings_cap(struct file *file, void *fh,
+		struct v4l2_dv_timings_cap *cap)
+{
+	struct tegra_channel *chan = video_drvdata(file);
+	struct v4l2_subdev *sd = chan->subdev_on_csi;
+
+	if (!v4l2_subdev_has_op(sd, pad, dv_timings_cap))
+		return -ENOTTY;
+
+	return v4l2_subdev_call(sd, pad, dv_timings_cap, cap);
+}
+
+int tegra_channel_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct tegra_channel *chan = container_of(ctrl->handler,
+				struct tegra_channel, ctrl_handler);
+	int err = 0;
+
+	switch (ctrl->id) {
+	case TEGRA_CAMERA_CID_GAIN_TPG:
+		{
+			if (chan->vi->csi != NULL &&
+				chan->vi->csi->tpg_gain_ctrl) {
+				struct v4l2_subdev *sd = chan->subdev_on_csi;
+
+				err = tegra_csi_tpg_set_gain(sd, &(ctrl->val));
+			}
+		}
+		break;
+	case TEGRA_CAMERA_CID_VI_BYPASS_MODE:
+		/* Prevent changing the bypass mode while the device is still streaming */
+		if (vb2_is_busy(&chan->queue))
+			return -EBUSY;
+
+		if (switch_ctrl_qmenu[ctrl->val] == SWITCH_ON)
+			chan->bypass = true;
+		else if (chan->vi->bypass) {
+			dev_dbg(&chan->video->dev,
+				"can't disable bypass mode\n");
+			dev_dbg(&chan->video->dev,
+				"because the VI/CSI is in bypass mode\n");
+			chan->bypass = true;
+		} else
+			chan->bypass = false;
+		break;
+	case TEGRA_CAMERA_CID_OVERRIDE_ENABLE:
+		{
+			struct v4l2_subdev *sd = chan->subdev_on_csi;
+			struct camera_common_data *s_data =
+				to_camera_common_data(sd->dev);
+
+			if (!s_data)
+				break;
+			if (switch_ctrl_qmenu[ctrl->val] == SWITCH_ON) {
+				s_data->override_enable = true;
+				dev_dbg(&chan->video->dev,
+					"enable override control\n");
+			} else {
+				s_data->override_enable = false;
+				dev_dbg(&chan->video->dev,
+					"disable override control\n");
+			}
+		}
+		break;
+	case TEGRA_CAMERA_CID_VI_HEIGHT_ALIGN:
+		chan->height_align = ctrl->val;
+		tegra_channel_update_format(chan, chan->format.width,
+				chan->format.height,
+				chan->format.pixelformat,
+				&chan->fmtinfo->bpp, 0);
+		break;
+	case TEGRA_CAMERA_CID_VI_SIZE_ALIGN:
+		chan->size_align = size_align_ctrl_qmenu[ctrl->val];
+		tegra_channel_update_format(chan, chan->format.width,
+				chan->format.height,
+				chan->format.pixelformat,
+				&chan->fmtinfo->bpp, 0);
+		break;
+	case TEGRA_CAMERA_CID_LOW_LATENCY:
+		chan->low_latency = ctrl->val;
+		break;
+	case TEGRA_CAMERA_CID_VI_PREFERRED_STRIDE:
+		chan->preferred_stride = ctrl->val;
+		tegra_channel_update_format(chan, chan->format.width,
+				chan->format.height,
+				chan->format.pixelformat,
+				&chan->fmtinfo->bpp,
+				chan->preferred_stride);
+		break;
+	default:
+		dev_err(&chan->video->dev, "%s: Invalid ctrl %u\n",
+			__func__, ctrl->id);
+		err = -EINVAL;
+	}
+
+	return err;
+}
+
+static const struct v4l2_ctrl_ops channel_ctrl_ops = {
+	.s_ctrl	= tegra_channel_s_ctrl,
+};
+
+static const struct v4l2_ctrl_config common_custom_ctrls[] = {
+	{
+		.ops = &channel_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_GAIN_TPG,
+		.name = "TPG Gain Ctrl",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 1,
+		.max = 64,
+		.step = 1,
+		.def = 1,
+	},
+	{
+		.ops = &channel_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_GAIN_TPG_EMB_DATA_CFG,
+		.name = "TPG embedded data config",
+		.type = V4L2_CTRL_TYPE_BOOLEAN,
+		.flags = V4L2_CTRL_FLAG_READ_ONLY,
+		.min = 0,
+		.max = 1,
+		.step = 1,
+		.def = 0,
+	},
+	{
+		.ops = &channel_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_VI_BYPASS_MODE,
+		.name = "Bypass Mode",
+		.type = V4L2_CTRL_TYPE_INTEGER_MENU,
+		.def = 0,
+		.min = 0,
+		.max = ARRAY_SIZE(switch_ctrl_qmenu) - 1,
+		.menu_skip_mask = 0,
+		.qmenu_int = switch_ctrl_qmenu,
+	},
+	{
+		.ops = &channel_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_OVERRIDE_ENABLE,
+		.name = "Override Enable",
+		.type = V4L2_CTRL_TYPE_INTEGER_MENU,
+		.def = 0,
+		.min = 0,
+		.max = ARRAY_SIZE(switch_ctrl_qmenu) - 1,
+		.menu_skip_mask = 0,
+		.qmenu_int = switch_ctrl_qmenu,
+	},
+	{
+		.ops = &channel_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_VI_HEIGHT_ALIGN,
+		.name = "Height Align",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 1,
+		.max = 16,
+		.step = 1,
+		.def = 1,
+	},
+	{
+		.ops = &channel_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_VI_SIZE_ALIGN,
+		.name = "Size Align",
+		.type = V4L2_CTRL_TYPE_INTEGER_MENU,
+		.def = TEGRA_SIZE_ALIGNMENT,
+		.min = 0,
+		.max = ARRAY_SIZE(size_align_ctrl_qmenu) - 1,
+		.menu_skip_mask = 0,
+		.qmenu_int = size_align_ctrl_qmenu,
+	},
+	{
+		.ops = &channel_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_SENSOR_MODES,
+		.name = "Sensor Modes",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.flags = V4L2_CTRL_FLAG_READ_ONLY,
+		.min = 0,
+		.max = MAX_NUM_SENSOR_MODES,
+		.def = MAX_NUM_SENSOR_MODES,
+		.step = 1,
+	},
+	{
+		.ops = &channel_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_SENSOR_SIGNAL_PROPERTIES,
+		.name = "Sensor Signal Properties",
+		.type = V4L2_CTRL_TYPE_U32,
+		.flags = V4L2_CTRL_FLAG_HAS_PAYLOAD |
+			 V4L2_CTRL_FLAG_READ_ONLY,
+		.min = 0,
+		.max = 0xFFFFFFFF,
+		.step = 1,
+		.def = 0,
+		.dims = { MAX_NUM_SENSOR_MODES,
+			  SENSOR_SIGNAL_PROPERTIES_CID_SIZE },
+	},
+	{
+		.ops = &channel_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_SENSOR_IMAGE_PROPERTIES,
+		.name = "Sensor Image Properties",
+		.type = V4L2_CTRL_TYPE_U32,
+		.flags = V4L2_CTRL_FLAG_HAS_PAYLOAD |
+			 V4L2_CTRL_FLAG_READ_ONLY,
+		.min = 0,
+		.max = 0xFFFFFFFF,
+		.step = 1,
+		.def = 0,
+		.dims = { MAX_NUM_SENSOR_MODES,
+			  SENSOR_IMAGE_PROPERTIES_CID_SIZE },
+	},
+	{
+		.ops = &channel_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_SENSOR_CONTROL_PROPERTIES,
+		.name = "Sensor Control Properties",
+		.type = V4L2_CTRL_TYPE_U32,
+		.flags = V4L2_CTRL_FLAG_HAS_PAYLOAD |
+			 V4L2_CTRL_FLAG_READ_ONLY,
+		.min = 0,
+		.max = 0xFFFFFFFF,
+		.step = 1,
+		.def = 0,
+		.dims = { MAX_NUM_SENSOR_MODES,
+			  SENSOR_CONTROL_PROPERTIES_CID_SIZE },
+	},
+	{
+		.ops = &channel_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_SENSOR_DV_TIMINGS,
+		.name = "Sensor DV Timings",
+		.type = V4L2_CTRL_TYPE_U32,
+		.flags = V4L2_CTRL_FLAG_HAS_PAYLOAD |
+			 V4L2_CTRL_FLAG_READ_ONLY,
+		.min = 0,
+		.max = 0xFFFFFFFF,
+		.step = 1,
+		.def = 0,
+		.dims = { MAX_NUM_SENSOR_MODES,
+			  SENSOR_DV_TIMINGS_CID_SIZE },
+	},
+	{
+		.ops = &channel_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_LOW_LATENCY,
+		.name = "Low Latency Mode",
+		.type = V4L2_CTRL_TYPE_BOOLEAN,
+		.def = 0,
+		.min = 0,
+		.max = 1,
+		.step = 1,
+	},
+	{
+		.ops = &channel_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_VI_PREFERRED_STRIDE,
+		.name = "Preferred Stride",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 0,
+		.max = 65535,
+		.step = 1,
+		.def = 0,
+	},
+};
+
+#define GET_TEGRA_CAMERA_CTRL(id, c)					\
+do {									\
+	c = v4l2_ctrl_find(&chan->ctrl_handler, TEGRA_CAMERA_CID_##id);	\
+	if (!c) {							\
+		dev_err(chan->vi->dev, "%s: could not find ctrl %s\n",	\
+			__func__, "##id");				\
+		return -EINVAL;						\
+	}								\
+} while (0)
+
+static int tegra_channel_sensorprops_setup(struct tegra_channel *chan)
+{
+	const struct v4l2_subdev *sd = chan->subdev_on_csi;
+	const struct camera_common_data *s_data =
+			to_camera_common_data(sd->dev);
+	const struct sensor_mode_properties *modes;
+	struct v4l2_ctrl *ctrl_modes;
+	struct v4l2_ctrl *ctrl_signalprops;
+	struct v4l2_ctrl *ctrl_imageprops;
+	struct v4l2_ctrl *ctrl_controlprops;
+	struct v4l2_ctrl *ctrl_dvtimings;
+	u32 i;
+
+	if (!s_data)
+		return 0;
+
+	GET_TEGRA_CAMERA_CTRL(SENSOR_MODES, ctrl_modes);
+	GET_TEGRA_CAMERA_CTRL(SENSOR_SIGNAL_PROPERTIES, ctrl_signalprops);
+	GET_TEGRA_CAMERA_CTRL(SENSOR_IMAGE_PROPERTIES, ctrl_imageprops);
+	GET_TEGRA_CAMERA_CTRL(SENSOR_CONTROL_PROPERTIES, ctrl_controlprops);
+	GET_TEGRA_CAMERA_CTRL(SENSOR_DV_TIMINGS, ctrl_dvtimings);
+
+	ctrl_modes->val = s_data->sensor_props.num_modes;
+	ctrl_modes->cur.val = s_data->sensor_props.num_modes;
+
+	/* Update the control sizes
+	 *
+	 * Note that the structs have size elems * sizeof(u32)
+	 * So to get the number of structs (elems * sizeof(u32)) / num_modes
+	 */
+	ctrl_signalprops->elems = s_data->sensor_props.num_modes *
+					SENSOR_SIGNAL_PROPERTIES_CID_SIZE;
+
+	ctrl_imageprops->elems = s_data->sensor_props.num_modes *
+					SENSOR_IMAGE_PROPERTIES_CID_SIZE;
+
+	ctrl_controlprops->elems = s_data->sensor_props.num_modes *
+					SENSOR_CONTROL_PROPERTIES_CID_SIZE;
+
+	ctrl_dvtimings->elems = s_data->sensor_props.num_modes *
+					SENSOR_DV_TIMINGS_CID_SIZE;
+
+	modes = s_data->sensor_props.sensor_modes;
+	for (i = 0; i < s_data->sensor_props.num_modes; i++) {
+		void *ptr = NULL;
+		u32 size;
+
+		size = sizeof(struct sensor_signal_properties);
+		ptr = ctrl_signalprops->p_new.p + (i * size);
+		memcpy(ptr, &modes[i].signal_properties, size);
+
+		size = sizeof(struct sensor_image_properties);
+		ptr = ctrl_imageprops->p_new.p + (i * size);
+		memcpy(ptr, &modes[i].image_properties, size);
+
+		size = sizeof(struct sensor_control_properties);
+		ptr = ctrl_controlprops->p_new.p + (i * size);
+		memcpy(ptr, &modes[i].control_properties, size);
+
+		size = sizeof(struct sensor_dv_timings);
+		ptr = ctrl_dvtimings->p_new.p + (i * size);
+		memcpy(ptr, &modes[i].dv_timings, size);
+	}
+	spec_bar();
+
+	/* Do not copy memory into p_cur block, reuse p_new */
+	ctrl_signalprops->p_cur.p = ctrl_signalprops->p_new.p;
+	ctrl_imageprops->p_cur.p = ctrl_imageprops->p_new.p;
+	ctrl_controlprops->p_cur.p = ctrl_controlprops->p_new.p;
+	ctrl_dvtimings->p_cur.p = ctrl_dvtimings->p_new.p;
+
+	return 0;
+}
+
+static int tegra_channel_setup_controls(struct tegra_channel *chan)
+{
+	int num_sd = 0;
+	struct v4l2_subdev *sd = NULL;
+	struct tegra_mc_vi *vi = chan->vi;
+	struct v4l2_ctrl *ctrl;
+	int i;
+	int ret = 0;
+
+	/* Clear and reinit control handler - Bug 1956853 */
+	v4l2_ctrl_handler_free(&chan->ctrl_handler);
+	v4l2_ctrl_handler_init(&chan->ctrl_handler, MAX_CID_CONTROLS);
+
+	/* Initialize the subdev and controls here at first open */
+	sd = chan->subdev[num_sd];
+	while ((sd = chan->subdev[num_sd++]) &&
+		(num_sd <= chan->num_subdevs)) {
+		/* Add control handler for the subdevice */
+		ret = v4l2_ctrl_add_handler(&chan->ctrl_handler,
+					sd->ctrl_handler, NULL, false);
+		if (ret || chan->ctrl_handler.error)
+			dev_err(chan->vi->dev,
+				"Failed to add sub-device controls\n");
+	}
+
+	/* Add new custom controls */
+	for (i = 0; i < ARRAY_SIZE(common_custom_ctrls); i++) {
+		switch (common_custom_ctrls[i].id) {
+			case TEGRA_CAMERA_CID_OVERRIDE_ENABLE:
+				/* don't create override control for pg mode */
+				if (chan->pg_mode)
+					continue;
+				break;
+			case TEGRA_CAMERA_CID_GAIN_TPG:
+				/* Skip the custom control for sensor and
+				 * for TPG which doesn't support gain control
+				 */
+				if ((vi->csi == NULL) || (chan->pg_mode &&
+					 !vi->csi->tpg_gain_ctrl))
+					continue;
+				break;
+			case TEGRA_CAMERA_CID_GAIN_TPG_EMB_DATA_CFG:
+				/* Skip the custom control for sensor and
+				 * for TPG which doesn't support embedded
+				 * data with TPG config data.
+				 */
+				if ((vi->csi == NULL) || (chan->pg_mode &&
+					!vi->csi->tpg_emb_data_config))
+					continue;
+				break;
+			default:
+				break;
+		}
+		ctrl = v4l2_ctrl_new_custom(&chan->ctrl_handler,
+			&common_custom_ctrls[i], NULL);
+		if (!ctrl) {
+			dev_err(chan->vi->dev,
+				"Failed to add %s ctrl\n",
+				common_custom_ctrls[i].name);
+			return chan->ctrl_handler.error;
+		}
+
+		/* Initialize the sensor arrays to have zero elements
+		 * This should keep accesses to only the modes
+		 * later defined in the DT
+		 */
+		if (ctrl->is_array)
+			ctrl->elems = 0;
+	}
+
+	vi->fops->vi_add_ctrls(chan);
+
+	if (chan->pg_mode) {
+		ret = v4l2_ctrl_add_handler(&chan->ctrl_handler,
+					&chan->vi->ctrl_handler, NULL, false);
+		if (ret || chan->ctrl_handler.error)
+			dev_err(chan->vi->dev,
+				"Failed to add VI controls\n");
+	}
+
+	/* setup the controls */
+	ret = v4l2_ctrl_handler_setup(&chan->ctrl_handler);
+	if (ret < 0)
+		goto error;
+
+	return 0;
+
+error:
+	v4l2_ctrl_handler_free(&chan->ctrl_handler);
+	return ret;
+}
+
+static void tegra_channel_free_sensor_properties(
+		const struct v4l2_subdev *sensor_sd)
+{
+	struct camera_common_data *s_data;
+	struct tegra_csi_device *csi = tegra_get_mc_csi();
+	struct tegra_csi_channel *chan;
+
+	if (sensor_sd == NULL)
+		return;
+
+	s_data = to_camera_common_data(sensor_sd->dev);
+	if (s_data == NULL)
+		return;
+
+	if (s_data->sensor_props.sensor_modes)
+		devm_kfree(s_data->dev, s_data->sensor_props.sensor_modes);
+
+	s_data->sensor_props.sensor_modes = NULL;
+
+	/* remove reference to s_data */
+	list_for_each_entry(chan, &csi->csi_chans, list) {
+		if (chan->sensor_sd == sensor_sd)
+			chan->s_data = NULL;
+	}
+}
+
+static int tegra_channel_connect_sensor(
+	struct tegra_channel *chan, struct v4l2_subdev *sensor_sd)
+{
+	struct device *sensor_dev;
+	struct device_node *sensor_of_node;
+	struct tegra_csi_device *csi_device;
+	struct device_node *ep_node;
+
+	if (!chan)
+		return -EINVAL;
+
+	if (!sensor_sd)
+		return -EINVAL;
+
+	sensor_dev = sensor_sd->dev;
+	if (!sensor_dev)
+		return -EINVAL;
+
+	sensor_of_node = sensor_dev->of_node;
+	if (!sensor_of_node)
+		return -EINVAL;
+
+	csi_device = tegra_get_mc_csi();
+	WARN_ON(!csi_device);
+	if (!csi_device)
+		return -ENODEV;
+
+	for_each_endpoint_of_node(sensor_of_node, ep_node) {
+		struct device_node *csi_chan_of_node;
+		struct tegra_csi_channel *csi_chan;
+
+		csi_chan_of_node =
+			of_graph_get_remote_port_parent(ep_node);
+
+		list_for_each_entry(csi_chan, &csi_device->csi_chans, list) {
+			if (csi_chan->of_node == csi_chan_of_node) {
+				csi_chan->s_data =
+					to_camera_common_data(chan->subdev_on_csi->dev);
+				csi_chan->sensor_sd = chan->subdev_on_csi;
+				break;
+			}
+		}
+
+		of_node_put(csi_chan_of_node);
+
+	}
+
+	return 0;
+}
+
+static int map_to_sensor_type(u32 phy_mode)
+{
+	switch (phy_mode) {
+	case CSI_PHY_MODE_DPHY:
+		return SENSORTYPE_DPHY;
+	case CSI_PHY_MODE_CPHY:
+		return SENSORTYPE_CPHY;
+	case SLVS_EC:
+		return SENSORTYPE_SLVSEC;
+	default:
+		return SENSORTYPE_OTHER;
+	}
+}
+
+static void tegra_channel_get_sensor_peak_vals(struct tegra_channel *chan,
+						u64 *pixelclock, u32 *num_lanes)
+{
+	int i = 0;
+	u64 val = 0;
+
+	struct v4l2_subdev *sd = chan->subdev_on_csi;
+	struct camera_common_data *s_data =
+		to_camera_common_data(sd->dev);
+	struct sensor_mode_properties *sensor_mode;
+
+	if (!s_data)
+		return;
+
+	for (i = 0; i < s_data->sensor_props.num_modes; i++) {
+		sensor_mode = &s_data->sensor_props.sensor_modes[i];
+		if (sensor_mode->signal_properties.serdes_pixel_clock.val != 0ULL)
+			val = sensor_mode->signal_properties.serdes_pixel_clock.val;
+		else
+			val = sensor_mode->signal_properties.pixel_clock.val;
+
+		/* Select the value from the mode with largest pixel rate and lane numbers */
+		if (*pixelclock < val)
+			*pixelclock = val;
+
+		if (*num_lanes < sensor_mode->signal_properties.num_lanes)
+			*num_lanes = sensor_mode->signal_properties.num_lanes;
+	}
+	spec_bar();
+}
+
+
+static u32 tegra_channel_get_num_lanes(struct tegra_channel *chan)
+{
+	u32 num_lanes = 0;
+	struct v4l2_subdev *sd = chan->subdev_on_csi;
+
+	struct camera_common_data *s_data =
+		to_camera_common_data(sd->dev);
+	struct sensor_mode_properties *sensor_mode;
+
+	if (!s_data)
+		return 0;
+
+	sensor_mode = &s_data->sensor_props.sensor_modes[0];
+	num_lanes = sensor_mode->signal_properties.num_lanes;
+
+	return num_lanes;
+}
+
+static u32 tegra_channel_get_sensor_type(struct tegra_channel *chan)
+{
+	u32 phy_mode = 0, sensor_type = 0;
+	struct v4l2_subdev *sd = chan->subdev_on_csi;
+	struct camera_common_data *s_data =
+		to_camera_common_data(sd->dev);
+	struct sensor_mode_properties *sensor_mode;
+
+	if (!s_data)
+		return 0;
+
+	/* Select phy mode based on the first mode */
+	sensor_mode = &s_data->sensor_props.sensor_modes[0];
+	phy_mode = sensor_mode->signal_properties.phy_mode;
+	sensor_type = map_to_sensor_type(phy_mode);
+
+	return sensor_type;
+}
+
+static u64 tegra_channel_get_max_source_rate(void)
+{
+	/* WAR: bug 2095503 */
+	/* TODO very large hard-coded rate based on 4k@60 fps */
+	/* implement proper functionality here. */
+	u64 pixelrate = HDMI_IN_RATE;
+	return pixelrate;
+}
+
+static void tegra_channel_populate_dev_info(struct tegra_camera_dev_info *cdev,
+			struct tegra_channel *chan)
+{
+	u64 pixelclock = 0;
+	u32 max_num_lanes = 0;
+	struct camera_common_data *s_data =
+			to_camera_common_data(chan->subdev_on_csi->dev);
+
+	if (s_data != NULL) {
+		/* camera sensors */
+		cdev->sensor_type = tegra_channel_get_sensor_type(chan);
+		tegra_channel_get_sensor_peak_vals(chan, &pixelclock, &max_num_lanes);
+		/* Multiply by CPHY symbols to pixels factor. */
+		if (cdev->sensor_type == SENSORTYPE_CPHY)
+			pixelclock *= 16/7;
+		cdev->lane_num = tegra_channel_get_num_lanes(chan);
+	} else {
+		if (chan->pg_mode) {
+			/* TPG mode */
+			cdev->sensor_type = SENSORTYPE_VIRTUAL;
+#if defined(NV_V4L2_SUBDEV_PAD_OPS_STRUCT_HAS_DV_TIMINGS) /* Linux v6.10 */
+		} else if (v4l2_subdev_has_op(chan->subdev_on_csi,
+						pad, g_dv_timings)) {
+#else
+		} else if (v4l2_subdev_has_op(chan->subdev_on_csi,
+						video, g_dv_timings)) {
+#endif
+			/* HDMI-IN */
+			cdev->sensor_type = SENSORTYPE_OTHER;
+			pixelclock = tegra_channel_get_max_source_rate();
+		} else {
+			/* Focusers, no pixel clk and ISO BW, just bail out */
+			return;
+		}
+	}
+	/*
+	 * VI clk scaling for gang mode usecase where 2 CSI bricks
+	 * stream through a single VI channel.
+	 */
+	if (max_num_lanes > NUM_LANES_PER_BRICK)
+		cdev->pixel_rate = pixelclock * (max_num_lanes / NUM_LANES_PER_BRICK);
+	else
+		cdev->pixel_rate = pixelclock;
+	cdev->pixel_bit_depth = chan->fmtinfo->width;
+	cdev->bpp = chan->fmtinfo->bpp.numerator;
+	/* BW in kBps */
+	cdev->bw = cdev->pixel_rate * cdev->bpp / 1024;
+	cdev->bw /= 8;
+}
+
+void tegra_channel_remove_subdevices(struct tegra_channel *chan)
+{
+	tegra_channel_free_sensor_properties(chan->subdev_on_csi);
+	video_unregister_device(chan->video);
+	chan->video = NULL;
+	chan->num_subdevs = 0;
+	chan->subdev_on_csi = NULL;
+}
+EXPORT_SYMBOL(tegra_channel_remove_subdevices);
+
+int tegra_channel_init_subdevices(struct tegra_channel *chan)
+{
+	int ret = 0;
+	struct media_entity *entity;
+	struct media_pad *pad;
+	struct v4l2_subdev *sd;
+	int index = 0;
+	u8 num_sd = 0;
+	struct tegra_camera_dev_info camdev_info;
+	int grp_id = chan->pg_mode ? (TPG_CSI_GROUP_ID + chan->port[0] + 1)
+		: chan->port[0] + 1;
+	int len = 0;
+
+	/* set_stream of CSI */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 0, 0)
+	pad = media_entity_remote_pad(&chan->pad);
+#else
+	pad = media_pad_remote_pad_first(&chan->pad);
+#endif
+	if (!pad)
+		return -ENODEV;
+
+	entity = pad->entity;
+	sd = media_entity_to_v4l2_subdev(entity);
+	v4l2_set_subdev_hostdata(sd, chan);
+	chan->subdev[num_sd++] = sd;
+
+	/* verify if the immediate subdevice is slvsec */
+	chan->is_slvsec = (strstr(sd->name, "slvs") != NULL) ? 1 : 0;
+
+	/* Add subdev name to this video dev name with vi-output tag*/
+	len = snprintf(chan->video->name, sizeof(chan->video->name), "%s, %s",
+		"vi-output", sd->name);
+	if (len < 0)
+		return -EINVAL;
+
+	sd->grp_id = grp_id;
+	chan->grp_id = grp_id;
+	index = pad->index - 1;
+	while (index >= 0) {
+		pad = &entity->pads[index];
+		if (!(pad->flags & MEDIA_PAD_FL_SINK))
+			break;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 0, 0)
+		pad = media_entity_remote_pad(pad);
+#else
+		pad = media_pad_remote_pad_first(pad);
+#endif
+		if (pad == NULL || !tegra_is_v4l2_subdev(pad->entity))
+			break;
+
+		if (num_sd >= MAX_SUBDEVICES)
+			break;
+
+		entity = pad->entity;
+		sd = media_entity_to_v4l2_subdev(entity);
+		v4l2_set_subdev_hostdata(sd, chan);
+		sd->grp_id = grp_id;
+		chan->subdev[num_sd++] = sd;
+		/* Add subdev name to this video dev name with vi-output tag*/
+		len = snprintf(chan->video->name, sizeof(chan->video->name), "%s, %s",
+			"vi-output", sd->name);
+		if (len < 0)
+			return -EINVAL;
+
+		index = pad->index - 1;
+	}
+	spec_bar(); /** for num_sd < MAX_SUBDEVICES */
+
+	chan->num_subdevs = num_sd;
+	/*
+	 * Each CSI channel has only one final remote source,
+	 * Mark that subdev as subdev_on_csi
+	 */
+	chan->subdev_on_csi = sd;
+
+	/* initialize the available formats */
+	if (chan->num_subdevs)
+		tegra_channel_fmts_bitmap_init(chan);
+
+	ret = tegra_channel_setup_controls(chan);
+	if (ret < 0) {
+		dev_err(chan->vi->dev, "%s: failed to setup controls\n",
+			__func__);
+		goto fail;
+	}
+
+	memset(&camdev_info, 0, sizeof(camdev_info));
+
+	/*
+	 * If subdev on csi is csi or channel is in pg mode
+	 * then don't look for sensor props
+	 */
+	if (strstr(chan->subdev_on_csi->name, "nvcsi") != NULL ||
+			chan->pg_mode) {
+		tegra_channel_populate_dev_info(&camdev_info, chan);
+		ret = tegra_camera_device_register(&camdev_info, chan);
+		return ret;
+	}
+
+	ret = tegra_channel_sensorprops_setup(chan);
+	if (ret < 0) {
+		dev_err(chan->vi->dev, "%s: failed to setup sensor props\n",
+			__func__);
+		goto fail;
+	}
+
+	/* Add a link for the camera_common_data in the tegra_csi_channel. */
+	ret = tegra_channel_connect_sensor(chan, chan->subdev_on_csi);
+	if (ret < 0) {
+		dev_err(chan->vi->dev,
+			"%s: failed to connect sensor to channel\n", __func__);
+		goto fail;
+	}
+
+	tegra_channel_populate_dev_info(&camdev_info, chan);
+	ret = tegra_camera_device_register(&camdev_info, chan);
+
+	return ret;
+fail:
+	tegra_channel_free_sensor_properties(chan->subdev_on_csi);
+	return ret;
+}
+EXPORT_SYMBOL(tegra_channel_init_subdevices);
+
+struct v4l2_subdev *tegra_channel_find_linked_csi_subdev(
+	struct tegra_channel *chan)
+{
+	struct tegra_csi_device *csi = tegra_get_mc_csi();
+	struct tegra_csi_channel *csi_it;
+	int i = 0;
+
+	list_for_each_entry(csi_it, &csi->csi_chans, list) {
+		for (i = 0; i < chan->num_subdevs; i++)
+			if (chan->subdev[i] == &csi_it->subdev)
+				return chan->subdev[i];
+	}
+
+	return NULL;
+}
+EXPORT_SYMBOL(tegra_channel_find_linked_csi_subdev);
+
+static int
+tegra_channel_get_format(struct file *file, void *fh,
+			struct v4l2_format *format)
+{
+	struct tegra_channel *chan = video_drvdata(file);
+	struct v4l2_pix_format *pix = &format->fmt.pix;
+
+	*pix = chan->format;
+
+	return 0;
+}
+
+static int
+__tegra_channel_try_format(struct tegra_channel *chan,
+			struct v4l2_pix_format *pix)
+{
+	const struct tegra_video_format *vfmt;
+	struct v4l2_subdev_format fmt;
+	struct v4l2_subdev *sd = chan->subdev_on_csi;
+	struct v4l2_subdev_pad_config pad_cfg;
+	struct v4l2_subdev_state cfg = {.pads = &pad_cfg};
+	int ret = 0;
+
+	/* Use the channel format if pixformat is not supported */
+	vfmt = tegra_core_get_format_by_fourcc(chan, pix->pixelformat);
+	if (!vfmt) {
+		pix->pixelformat = chan->format.pixelformat;
+		vfmt = tegra_core_get_format_by_fourcc(chan, pix->pixelformat);
+		if (!vfmt)
+			return -EINVAL;
+	}
+
+	fmt.which = V4L2_SUBDEV_FORMAT_TRY;
+	fmt.pad = 0;
+	v4l2_fill_mbus_format(&fmt.format, pix, vfmt->code);
+
+	ret = v4l2_subdev_call(sd, pad, set_fmt, &cfg, &fmt);
+	if (ret == -ENOIOCTLCMD)
+		return -ENOTTY;
+
+	v4l2_fill_pix_format(pix, &fmt.format);
+
+	tegra_channel_fmt_align(chan, vfmt,
+				&pix->width, &pix->height, &pix->bytesperline);
+	pix->sizeimage = get_aligned_buffer_size(chan,
+			pix->bytesperline, pix->height);
+	if (chan->fmtinfo->fourcc == V4L2_PIX_FMT_NV16)
+		pix->sizeimage *= 2;
+
+	return ret;
+}
+
+static int
+tegra_channel_try_format(struct file *file, void *fh,
+			struct v4l2_format *format)
+{
+	struct tegra_channel *chan = video_drvdata(file);
+
+	return  __tegra_channel_try_format(chan, &format->fmt.pix);
+}
+
+static int
+__tegra_channel_set_format(struct tegra_channel *chan,
+			struct v4l2_pix_format *pix)
+{
+	const struct tegra_video_format *vfmt;
+	struct v4l2_subdev_format fmt;
+	struct v4l2_subdev *sd = chan->subdev_on_csi;
+	struct v4l2_subdev_pad_config pad_cfg;
+	struct v4l2_subdev_state cfg = {.pads = &pad_cfg};
+	int ret = 0;
+
+	vfmt = tegra_core_get_format_by_fourcc(chan, pix->pixelformat);
+	if (!vfmt)
+		return -EINVAL;
+
+	fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+	fmt.pad = 0;
+	v4l2_fill_mbus_format(&fmt.format, pix, vfmt->code);
+
+	ret = v4l2_subdev_call(sd, pad, set_fmt, &cfg, &fmt);
+	if (ret == -ENOIOCTLCMD)
+		return -ENOTTY;
+
+	v4l2_fill_pix_format(pix, &fmt.format);
+	if (!ret) {
+		chan->format = *pix;
+		chan->fmtinfo = vfmt;
+
+		if (chan->preferred_stride)
+			pix->bytesperline = chan->preferred_stride;
+
+		tegra_channel_update_format(chan, pix->width,
+			pix->height, vfmt->fourcc, &vfmt->bpp,
+			pix->bytesperline);
+
+		*pix = chan->format;
+
+		if (chan->total_ports > 1)
+			update_gang_mode(chan);
+	}
+
+	return ret;
+}
+
+static int
+tegra_channel_set_format(struct file *file, void *fh,
+			struct v4l2_format *format)
+{
+	struct tegra_channel *chan = video_drvdata(file);
+	int ret = 0;
+
+	/* get the suppod format by try_fmt */
+	ret = __tegra_channel_try_format(chan, &format->fmt.pix);
+	if (ret)
+		return ret;
+
+	if (vb2_is_busy(&chan->queue))
+		return -EBUSY;
+
+	return __tegra_channel_set_format(chan, &format->fmt.pix);
+}
+
+static int tegra_channel_subscribe_event(struct v4l2_fh *fh,
+				  const struct v4l2_event_subscription *sub)
+{
+	switch (sub->type) {
+	case V4L2_EVENT_SOURCE_CHANGE:
+		return v4l2_event_subscribe(fh, sub, 4, NULL);
+	}
+	return v4l2_ctrl_subscribe_event(fh, sub);
+}
+
+static int
+tegra_channel_enum_input(struct file *file, void *fh, struct v4l2_input *inp)
+{
+	struct tegra_channel *chan = video_drvdata(file);
+	struct v4l2_subdev *sd_on_csi = chan->subdev_on_csi;
+	int ret, len;
+
+	if (inp->index)
+		return -EINVAL;
+
+	ret = v4l2_device_call_until_err(chan->video->v4l2_dev,
+			chan->grp_id, video, g_input_status, &inp->status);
+
+	if (ret == -ENODEV || sd_on_csi == NULL)
+		return -ENODEV;
+
+	inp->type = V4L2_INPUT_TYPE_CAMERA;
+#if defined(NV_V4L2_SUBDEV_PAD_OPS_STRUCT_HAS_DV_TIMINGS) /* Linux v6.10 */
+	if (v4l2_subdev_has_op(sd_on_csi, pad, s_dv_timings)) {
+#else
+	if (v4l2_subdev_has_op(sd_on_csi, video, s_dv_timings)) {
+#endif
+		inp->capabilities = V4L2_IN_CAP_DV_TIMINGS;
+		len = snprintf(inp->name,
+			sizeof(inp->name), "HDMI %u",
+			chan->port[0]);
+		if (len < 0)
+			return -EINVAL;
+	} else {
+		len = snprintf(inp->name,
+			sizeof(inp->name), "Camera %u",
+			chan->port[0]);
+		if (len < 0)
+			return -EINVAL;
+	}
+
+	return ret;
+}
+
+static int tegra_channel_g_input(struct file *file, void *priv, unsigned int *i)
+{
+	*i = 0;
+	return 0;
+}
+
+static int tegra_channel_s_input(struct file *file, void *priv, unsigned int i)
+{
+	if (i > 0)
+		return -EINVAL;
+	return 0;
+}
+
+static int tegra_channel_log_status(struct file *file, void *priv)
+{
+	struct tegra_channel *chan = video_drvdata(file);
+
+	v4l2_device_call_all(chan->video->v4l2_dev,
+		chan->grp_id, core, log_status);
+	return 0;
+}
+
+static long tegra_channel_default_ioctl(struct file *file, void *fh,
+			bool use_prio, unsigned int cmd, void *arg)
+{
+	struct tegra_channel *chan = video_drvdata(file);
+	struct tegra_mc_vi *vi = chan->vi;
+	long ret = -ENOTTY;
+
+	if (vi->fops && vi->fops->vi_default_ioctl)
+		ret = vi->fops->vi_default_ioctl(file, fh, use_prio, cmd, arg);
+
+	return ret;
+}
+
+/* Implemented vidioc_s_parm and vidioc_g_parm ioctl to support multiple frame
+ * rates */
+static int tegra_channel_s_parm(struct file *file, void *fh,
+               struct v4l2_streamparm *a)
+{
+	struct tegra_channel *chan = video_drvdata(file);
+	struct v4l2_subdev *sd = chan->subdev_on_csi;
+
+	return v4l2_s_parm_cap(chan->video, sd, a);
+}
+
+static int tegra_channel_g_parm(struct file *file, void *fh,
+               struct v4l2_streamparm *a)
+{
+	struct tegra_channel *chan = video_drvdata(file);
+	struct v4l2_subdev *sd = chan->subdev_on_csi;
+
+	return v4l2_g_parm_cap(chan->video, sd, a);
+}
+
+static const struct v4l2_ioctl_ops tegra_channel_ioctl_ops = {
+	.vidioc_querycap		= tegra_channel_querycap,
+	.vidioc_enum_framesizes		= tegra_channel_enum_framesizes,
+	.vidioc_enum_frameintervals	= tegra_channel_enum_frameintervals,
+	.vidioc_s_parm                  = tegra_channel_s_parm,
+	.vidioc_g_parm                  = tegra_channel_g_parm,
+	.vidioc_enum_fmt_vid_cap	= tegra_channel_enum_format,
+	.vidioc_g_fmt_vid_cap		= tegra_channel_get_format,
+	.vidioc_s_fmt_vid_cap		= tegra_channel_set_format,
+	.vidioc_try_fmt_vid_cap		= tegra_channel_try_format,
+	.vidioc_reqbufs			= vb2_ioctl_reqbufs,
+	.vidioc_prepare_buf		= vb2_ioctl_prepare_buf,
+	.vidioc_querybuf		= vb2_ioctl_querybuf,
+	.vidioc_qbuf			= vb2_ioctl_qbuf,
+	.vidioc_dqbuf			= vb2_ioctl_dqbuf,
+	.vidioc_create_bufs		= vb2_ioctl_create_bufs,
+	.vidioc_expbuf			= vb2_ioctl_expbuf,
+	.vidioc_streamon		= vb2_ioctl_streamon,
+	.vidioc_streamoff		= vb2_ioctl_streamoff,
+	.vidioc_g_edid			= tegra_channel_g_edid,
+	.vidioc_s_edid			= tegra_channel_s_edid,
+	.vidioc_s_dv_timings		= tegra_channel_s_dv_timings,
+	.vidioc_g_dv_timings		= tegra_channel_g_dv_timings,
+	.vidioc_query_dv_timings	= tegra_channel_query_dv_timings,
+	.vidioc_enum_dv_timings		= tegra_channel_enum_dv_timings,
+	.vidioc_dv_timings_cap		= tegra_channel_dv_timings_cap,
+	.vidioc_subscribe_event		= tegra_channel_subscribe_event,
+	.vidioc_unsubscribe_event	= v4l2_event_unsubscribe,
+	.vidioc_enum_input		= tegra_channel_enum_input,
+	.vidioc_g_input			= tegra_channel_g_input,
+	.vidioc_s_input			= tegra_channel_s_input,
+	.vidioc_log_status		= tegra_channel_log_status,
+	.vidioc_default			= tegra_channel_default_ioctl,
+};
+
+static int tegra_channel_close(struct file *fp);
+static int tegra_channel_open(struct file *fp)
+{
+	int ret;
+	struct video_device *vdev = video_devdata(fp);
+	struct tegra_channel *chan = video_drvdata(fp);
+	struct tegra_mc_vi *vi;
+	struct tegra_csi_device *csi;
+
+	trace_tegra_channel_open(vdev->name);
+	mutex_lock(&chan->video_lock);
+	ret = v4l2_fh_open(fp);
+	if (ret || !v4l2_fh_is_singular_file(fp)) {
+		mutex_unlock(&chan->video_lock);
+		return ret;
+	}
+
+	if (chan->subdev[0] == NULL) {
+		ret = -ENODEV;
+		goto fail;
+	}
+
+	vi = chan->vi;
+	csi = vi->csi;
+
+	chan->fh = (struct v4l2_fh *)fp->private_data;
+
+	if (tegra_channel_verify_focuser(chan)) {
+		ret = tegra_channel_set_power(chan, true);
+		if (ret < 0)
+			return ret;
+	}
+
+
+	mutex_unlock(&chan->video_lock);
+	return 0;
+
+fail:
+	_vb2_fop_release(fp, NULL);
+	mutex_unlock(&chan->video_lock);
+	return ret;
+}
+
+static int tegra_channel_close(struct file *fp)
+{
+	int ret = 0;
+	struct video_device *vdev = video_devdata(fp);
+	struct tegra_channel *chan = video_drvdata(fp);
+	struct tegra_mc_vi *vi = chan->vi;
+	bool is_singular;
+
+	trace_tegra_channel_close(vdev->name);
+	mutex_lock(&chan->video_lock);
+	is_singular = v4l2_fh_is_singular_file(fp);
+	ret = _vb2_fop_release(fp, NULL);
+
+	if (!is_singular) {
+		mutex_unlock(&chan->video_lock);
+		return ret;
+	}
+
+	if (tegra_channel_verify_focuser(chan)) {
+		ret = tegra_channel_set_power(chan, false);
+		if (ret < 0)
+			dev_err(vi->dev, "Failed to power off subdevices\n");
+	}
+
+	mutex_unlock(&chan->video_lock);
+	return ret;
+}
+
+/* -----------------------------------------------------------------------------
+ * V4L2 file operations
+ */
+static const struct v4l2_file_operations tegra_channel_fops = {
+	.owner		= THIS_MODULE,
+	.unlocked_ioctl	= video_ioctl2,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl32 = video_ioctl2,
+#endif
+	.open		= tegra_channel_open,
+	.release	= tegra_channel_close,
+	.read		= vb2_fop_read,
+	.poll		= vb2_fop_poll,
+	.mmap		= vb2_fop_mmap,
+};
+
+int tegra_vi_get_port_info(struct tegra_channel *chan,
+			struct device_node *node, unsigned int index)
+{
+	struct device_node *ep = NULL;
+	struct device_node *ports;
+	struct device_node *port;
+	int value = 0xFFFF;
+	int ret = 0;
+	u32 i = 0;
+
+	ports = of_get_child_by_name(node, "ports");
+	if (ports == NULL)
+		ports = node;
+
+	for_each_child_of_node(ports, port) {
+		if (!port->name || of_node_cmp(port->name, "port"))
+			continue;
+
+		ret = of_property_read_u32(port, "reg", &value);
+		if (ret < 0)
+			continue;
+
+		if (value != index)
+			continue;
+
+		for_each_child_of_node(port, ep) {
+			if (!ep->name || of_node_cmp(ep->name, "endpoint"))
+				continue;
+
+			/* Get virtual channel id */
+			ret = of_property_read_u32(ep, "vc-id", &value);
+
+			/* vc-id is optional, default is 0 */
+			chan->virtual_channel = (ret < 0) ? 0 : value;
+
+			/* Consider max simultaneous sensor streams to be 16 */
+			if (value > 16) {
+				dev_err(chan->vi->dev, "vc id >16!\n");
+				return -EINVAL;
+			}
+
+			/* Get CSI port */
+			ret = of_property_read_u32(ep, "port-index", &value);
+			if (ret < 0)
+				dev_err(chan->vi->dev, "port index error\n");
+			chan->port[0] = value;
+
+			if (value > NVCSI_PORT_H) {
+				dev_err(chan->vi->dev, "port index >%d!\n",
+					NVCSI_PORT_H);
+				return -EINVAL;
+			}
+
+			/* Get number of data lanes for the endpoint */
+			ret = of_property_read_u32(ep, "bus-width", &value);
+			if (ret < 0)
+				dev_err(chan->vi->dev, "num lanes error\n");
+			chan->numlanes = value;
+
+			if (value > 12) {
+				dev_err(chan->vi->dev, "num lanes >12!\n");
+				return -EINVAL;
+			}
+			/*
+			 * for numlanes greater than 4 multiple CSI bricks
+			 * are needed to capture the image, the logic below
+			 * checks for numlanes > 4 and add a new CSI brick
+			 * as a valid port. Loops around the three CSI
+			 * bricks to add as many ports necessary.
+			 */
+			value -= 4;
+			for (i = 1; value > 0 && i < TEGRA_CSI_BLOCKS; i++, value -= 4) {
+				int next_port = chan->port[i-1] + 2;
+
+				next_port = (next_port % (NVCSI_PORT_H + 1));
+				chan->port[i] = next_port;
+			}
+		}
+	}
+
+	return ret;
+}
+
+static int tegra_channel_csi_init(struct tegra_channel *chan)
+{
+	int idx = 0;
+	struct tegra_mc_vi *vi = chan->vi;
+	int ret = 0;
+
+	chan->gang_mode = CAMERA_NO_GANG_MODE;
+	chan->total_ports = 0;
+	memset(&chan->port[0], INVALID_CSI_PORT, TEGRA_CSI_BLOCKS);
+	memset(&chan->syncpoint_fifo[0], 0, sizeof(chan->syncpoint_fifo));
+	if (chan->pg_mode) {
+		/* If VI has 4 existing channels, chan->id will start
+		 * from 4 for the first TPG channel, which uses PORT_A(0).
+		 * To get the correct PORT number, subtract existing number of
+		 * channels from chan->id.
+		 */
+		chan->port[0] = (chan->id - vi->num_channels)
+				% NUM_TPG_INSTANCE;
+		chan->virtual_channel =  (chan->id - vi->num_channels)
+				/ NUM_TPG_INSTANCE;
+
+		WARN_ON(chan->port[0] > vi->csi->num_tpg_channels);
+		chan->numlanes = 2;
+	} else {
+		ret = tegra_vi_get_port_info(chan, vi->dev->of_node, chan->id);
+		if (ret) {
+			dev_err(vi->dev, "%s:Fail to parse port info\n",
+					__func__);
+			return ret;
+		}
+	}
+
+	for (idx = 0; idx < TEGRA_CSI_BLOCKS && csi_port_is_valid(chan->port[idx]); idx++) {
+		chan->total_ports++;
+		/* maximum of 4 lanes are present per CSI block */
+		chan->csibase[idx] = vi->iomem +
+					TEGRA_VI_CSI_BASE(chan->port[idx]);
+	}
+	/* based on gang mode valid ports will be updated - set default to 1 */
+	chan->valid_ports = chan->total_ports ? 1 : 0;
+	return ret;
+}
+
+int tegra_channel_init_video(struct tegra_channel *chan)
+{
+	struct tegra_mc_vi *vi = chan->vi;
+	int ret = 0, len = 0;
+
+	if (chan->video) {
+		dev_err(&chan->video->dev, "video device already allocated\n");
+		return 0;
+	}
+
+	chan->video = video_device_alloc();
+	
+	chan->video->prio = kzalloc(sizeof(*chan->video->prio), GFP_KERNEL);
+	if (!chan->video->prio) {
+		video_device_release(chan->video);
+		dev_err(&chan->video->dev, "failed allocate prio\n");
+		return -ENOMEM;
+	}
+
+	/* Initialize the media entity... */
+	chan->pad.flags = MEDIA_PAD_FL_SINK;
+	ret = tegra_media_entity_init(&chan->video->entity, 1,
+					&chan->pad, false, false);
+	if (ret < 0) {
+		kfree(chan->video->prio);
+		video_device_release(chan->video);
+		dev_err(&chan->video->dev, "failed to init video entity\n");
+		return ret;
+	}
+
+	/* init control handler */
+	ret = v4l2_ctrl_handler_init(&chan->ctrl_handler, MAX_CID_CONTROLS);
+	if (chan->ctrl_handler.error) {
+		dev_err(&chan->video->dev, "failed to init control handler\n");
+		goto ctrl_init_error;
+	}
+
+	/* init video node... */
+	chan->video->fops = &tegra_channel_fops;
+	chan->video->v4l2_dev = &vi->v4l2_dev;
+	chan->video->queue = &chan->queue;
+	len = snprintf(chan->video->name, sizeof(chan->video->name), "%s-%s-%u",
+		dev_name(vi->dev), chan->pg_mode ? "tpg" : "output",
+		chan->pg_mode ? (chan->id - vi->num_channels) : chan->port[0]);
+	if (len < 0) {
+		ret = -EINVAL;
+		goto ctrl_init_error;
+	}
+
+	chan->video->vfl_type = VFL_TYPE_VIDEO;
+	chan->video->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;
+	chan->video->device_caps |= V4L2_CAP_EXT_PIX_FORMAT;
+	chan->video->vfl_dir = VFL_DIR_RX;
+	chan->video->release = video_device_release_empty;
+	chan->video->ioctl_ops = &tegra_channel_ioctl_ops;
+	chan->video->ctrl_handler = &chan->ctrl_handler;
+	chan->video->lock = &chan->video_lock;
+
+	video_set_drvdata(chan->video, chan);
+
+	return ret;
+
+ctrl_init_error:
+	kfree(chan->video->prio);
+	video_device_release(chan->video);
+	media_entity_cleanup(&chan->video->entity);
+	v4l2_ctrl_handler_free(&chan->ctrl_handler);
+	return ret;
+}
+EXPORT_SYMBOL(tegra_channel_init_video);
+
+int tegra_channel_init(struct tegra_channel *chan)
+{
+	int ret;
+	struct tegra_mc_vi *vi = chan->vi;
+	struct device *vi_unit_dev;
+
+	ret = tegra_channel_csi_init(chan);
+	if (ret)
+		return ret;
+
+	/*
+	 * The VI device instance has to be retrieved after CSI channel
+	 * has been initialized. This will make sure the TPG ports are
+	 * setup correctly
+	 */
+	vi_unit_dev = tegra_channel_get_vi_unit(chan);
+	chan->width_align = TEGRA_WIDTH_ALIGNMENT;
+	chan->stride_align = TEGRA_STRIDE_ALIGNMENT;
+	chan->height_align = TEGRA_HEIGHT_ALIGNMENT;
+	chan->size_align = size_align_ctrl_qmenu[TEGRA_SIZE_ALIGNMENT];
+	chan->num_subdevs = 0;
+	mutex_init(&chan->video_lock);
+	chan->capture_descr_index = 0;
+	chan->capture_descr_sequence = 0;
+	INIT_LIST_HEAD(&chan->capture);
+	INIT_LIST_HEAD(&chan->release);
+	INIT_LIST_HEAD(&chan->entities);
+	init_waitqueue_head(&chan->start_wait);
+	init_waitqueue_head(&chan->release_wait);
+	atomic_set(&chan->restart_version, 1);
+	chan->capture_version = 0;
+	spin_lock_init(&chan->start_lock);
+	spin_lock_init(&chan->release_lock);
+	INIT_LIST_HEAD(&chan->dequeue);
+	init_waitqueue_head(&chan->dequeue_wait);
+	spin_lock_init(&chan->dequeue_lock);
+	mutex_init(&chan->stop_kthread_lock);
+	init_rwsem(&chan->reset_lock);
+	atomic_set(&chan->is_streaming, DISABLE);
+	spin_lock_init(&chan->capture_state_lock);
+	spin_lock_init(&chan->buffer_lock);
+
+	/* Init video format */
+	vi->fops->vi_init_video_formats(chan);
+	chan->fmtinfo = tegra_core_get_default_format();
+	tegra_channel_update_format(chan, TEGRA_DEF_WIDTH,
+				TEGRA_DEF_HEIGHT,
+				chan->fmtinfo->fourcc,
+				&chan->fmtinfo->bpp,
+				chan->preferred_stride);
+
+	chan->buffer_offset[0] = 0;
+	/* Init bpl factor to 1, will be overidden based on interlace_type */
+	chan->interlace_bplfactor = 1;
+
+#if IS_ENABLED(CONFIG_VIDEOBUF2_DMA_CONTIG)
+	/* get the buffers queue... */
+	ret = tegra_vb2_dma_init(vi_unit_dev, &chan->alloc_ctx,
+			SZ_64K, &vi->vb2_dma_alloc_refcnt);
+	if (ret < 0)
+		goto vb2_init_error;
+
+#endif
+
+	chan->queue.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	chan->queue.io_modes = VB2_MMAP | VB2_DMABUF | VB2_READ | VB2_USERPTR;
+	chan->queue.lock = &chan->video_lock;
+	chan->queue.drv_priv = chan;
+	chan->queue.buf_struct_size = sizeof(struct tegra_channel_buffer);
+	chan->queue.ops = &tegra_channel_queue_qops;
+#if IS_ENABLED(CONFIG_VIDEOBUF2_DMA_CONTIG)
+	chan->queue.mem_ops = &vb2_dma_contig_memops;
+#endif
+	chan->queue.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC
+				   | V4L2_BUF_FLAG_TSTAMP_SRC_EOF;
+	ret = vb2_queue_init(&chan->queue);
+	if (ret < 0) {
+		dev_err(chan->vi->dev, "failed to initialize VB2 queue\n");
+		goto vb2_queue_error;
+	}
+
+	chan->deskew_ctx = devm_kzalloc(vi->dev,
+			sizeof(struct nvcsi_deskew_context), GFP_KERNEL);
+	if (!chan->deskew_ctx) {
+		ret = -ENOMEM;
+		goto deskew_ctx_err;
+	}
+
+	chan->init_done = true;
+
+	return 0;
+
+deskew_ctx_err:
+	devm_kfree(vi->dev, chan->deskew_ctx);
+vb2_queue_error:
+#if IS_ENABLED(CONFIG_VIDEOBUF2_DMA_CONTIG)
+	tegra_vb2_dma_cleanup(vi_unit_dev, chan->alloc_ctx,
+		&vi->vb2_dma_alloc_refcnt);
+vb2_init_error:
+#endif
+	v4l2_ctrl_handler_free(&chan->ctrl_handler);
+	return ret;
+}
+EXPORT_SYMBOL(tegra_channel_init);
+
+int tegra_channel_cleanup_video(struct tegra_channel *chan)
+{
+	v4l2_ctrl_handler_free(&chan->ctrl_handler);
+	media_entity_cleanup(&chan->video->entity);
+	kfree(chan->video->prio);
+	video_device_release(chan->video);
+	return 0;
+}
+EXPORT_SYMBOL(tegra_channel_cleanup_video);
+
+int tegra_channel_cleanup(struct tegra_channel *chan)
+{
+	struct device *vi_unit_dev = tegra_channel_get_vi_unit(chan);
+
+	/* release embedded data buffer */
+	if (chan->emb_buf_size > 0) {
+		dma_free_coherent(vi_unit_dev,
+			chan->emb_buf_size,
+			chan->emb_buf_addr, chan->emb_buf);
+		chan->emb_buf_size = 0;
+	}
+
+	tegra_channel_dealloc_buffer_queue(chan);
+
+	v4l2_ctrl_handler_free(&chan->ctrl_handler);
+	mutex_lock(&chan->video_lock);
+	vb2_queue_release(&chan->queue);
+#if IS_ENABLED(CONFIG_VIDEOBUF2_DMA_CONTIG)
+	tegra_vb2_dma_cleanup(vi_unit_dev, chan->alloc_ctx,
+		&chan->vi->vb2_dma_alloc_refcnt);
+#endif
+	mutex_unlock(&chan->video_lock);
+
+	tegra_camera_device_unregister(chan);
+
+	return 0;
+}
+EXPORT_SYMBOL(tegra_channel_cleanup);
+
+void tegra_vi_channels_unregister(struct tegra_mc_vi *vi)
+{
+	struct tegra_channel *it;
+
+	list_for_each_entry(it, &vi->vi_chans, list) {
+		if (it->video->cdev != NULL)
+			video_unregister_device(it->video);
+	}
+}
+EXPORT_SYMBOL(tegra_vi_channels_unregister);
+
+int tegra_vi_mfi_work(struct tegra_mc_vi *vi, int channel)
+{
+	if (vi->fops)
+		return vi->fops->vi_mfi_work(vi, channel);
+
+	return 0;
+}
+EXPORT_SYMBOL(tegra_vi_mfi_work);
+
+int tegra_vi_channels_init(struct tegra_mc_vi *vi)
+{
+	int ret = 0;
+	struct tegra_channel *it;
+	int count = 0;
+
+	list_for_each_entry(it, &vi->vi_chans, list) {
+		it->vi = vi;
+		ret = tegra_channel_init(it);
+		if (ret < 0) {
+			dev_err(vi->dev, "channel init failed\n");
+			continue;
+		}
+		count++;
+	}
+
+	if (count == 0) {
+		dev_err(vi->dev, "all channel init failed\n");
+		return ret;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(tegra_vi_channels_init);
+int tegra_vi_channels_cleanup(struct tegra_mc_vi *vi)
+{
+	int ret = 0, err = 0;
+	struct tegra_channel *it;
+
+	list_for_each_entry(it, &vi->vi_chans, list) {
+		if (!it->init_done)
+			continue;
+		err = tegra_channel_cleanup(it);
+		if (err < 0) {
+			ret = err;
+			dev_err(vi->dev, "channel cleanup failed, err %d\n",
+					err);
+		}
+	}
+	return ret;
+}
+EXPORT_SYMBOL(tegra_vi_channels_cleanup);
diff --git a/drivers/media/platform/tegra/camera/vi/vi5_fops.c b/drivers/media/platform/tegra/camera/vi/vi5_fops.c
new file mode 100644
index 0000000..33c3dc9
--- /dev/null
+++ b/drivers/media/platform/tegra/camera/vi/vi5_fops.c
@@ -0,0 +1,1148 @@
+// SPDX-License-Identifier: GPL-2.0
+/* SPDX-FileCopyrightText: Copyright (c) 2016-2024 NVIDIA CORPORATION & AFFILIATES.
+ * All rights reserved.
+ *
+ * Tegra Video Input 5 device common APIs
+ *
+ * Author: Frank Chen <frank@nvidia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/errno.h>
+#include <linux/freezer.h>
+#include <linux/fs.h>
+#include <linux/kthread.h>
+#include <linux/nvhost.h>
+#include <linux/pm_runtime.h>
+#include <linux/semaphore.h>
+#include <linux/syscalls.h>
+#include <media/fusa-capture/capture-vi-channel.h>
+#include <media/fusa-capture/capture-vi.h>
+#include <media/mc_common.h>
+#include <media/tegra-v4l2-camera.h>
+#include <media/tegra_camera_platform.h>
+#include <soc/tegra/camrtc-capture.h>
+#include <trace/events/camera_common.h>
+
+#include "vi5_fops.h"
+#include "vi5_formats.h"
+
+#define DEFAULT_FRAMERATE	30
+#define BPP_MEM			2
+#define VI_CSI_CLK_SCALE	110
+#define PG_BITRATE		32
+#define SLVSEC_STREAM_MAIN	0U
+
+#define VI_CHANNEL_DEV "/dev/capture-vi-channel"
+#define VI_CHAN_PATH_MAX 40
+
+#define CAPTURE_TIMEOUT_MS	2500
+
+static const struct vi_capture_setup default_setup = {
+	.channel_flags = 0
+	| CAPTURE_CHANNEL_FLAG_VIDEO
+	| CAPTURE_CHANNEL_FLAG_RAW
+	| CAPTURE_CHANNEL_FLAG_EMBDATA
+	| CAPTURE_CHANNEL_FLAG_LINETIMER
+	,
+
+	.vi_channel_mask = ~0ULL,
+	.vi2_channel_mask = ~0ULL,
+
+	.queue_depth = CAPTURE_MIN_BUFFERS,
+	.request_size = sizeof(struct capture_descriptor),
+	.mem = 0,  /* fill in later */
+};
+
+static const struct capture_descriptor capture_template = {
+	.sequence = 0,
+
+	.capture_flags = 0
+	| CAPTURE_FLAG_STATUS_REPORT_ENABLE
+	| CAPTURE_FLAG_ERROR_REPORT_ENABLE
+	,
+
+	.ch_cfg = {
+		.pixfmt_enable = 0,		/* no output */
+		.match = {
+			.stream = 0,		/* one-hot bit encoding */
+			.stream_mask = 0x3f,
+			.vc = (1u << 0),	/* one-hot bit encoding */
+			.vc_mask = 0xffff,
+		},
+	},
+};
+
+static void vi5_init_video_formats(struct tegra_channel *chan)
+{
+	int i;
+
+	chan->num_video_formats = ARRAY_SIZE(vi5_video_formats);
+	for (i = 0; i < chan->num_video_formats; i++)
+		chan->video_formats[i] = &vi5_video_formats[i];
+}
+
+static int tegra_vi5_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct tegra_channel *chan = container_of(ctrl->handler,
+				struct tegra_channel, ctrl_handler);
+	struct v4l2_subdev *sd = chan->subdev_on_csi;
+	struct camera_common_data *s_data =
+				to_camera_common_data(sd->dev);
+	struct tegracam_ctrl_handler *handler;
+	struct tegracam_sensor_data *sensor_data;
+
+	if (!s_data)
+		return -EINVAL;
+	handler = s_data->tegracam_ctrl_hdl;
+	if (!handler)
+		return -EINVAL;
+	sensor_data = &handler->sensor_data;
+
+	/* TODO: Support reading blobs for multiple devices */
+	switch (ctrl->id) {
+	case TEGRA_CAMERA_CID_SENSOR_CONFIG: {
+		struct sensor_cfg *cfg = &s_data->sensor_props.cfg;
+
+		memcpy(ctrl->p_new.p, cfg, sizeof(struct sensor_cfg));
+		break;
+	}
+	case TEGRA_CAMERA_CID_SENSOR_MODE_BLOB: {
+		struct sensor_blob *blob = &sensor_data->mode_blob;
+
+		memcpy(ctrl->p_new.p, blob, sizeof(struct sensor_blob));
+		break;
+	}
+	case TEGRA_CAMERA_CID_SENSOR_CONTROL_BLOB: {
+		struct sensor_blob *blob = &sensor_data->ctrls_blob;
+
+		memcpy(ctrl->p_new.p, blob, sizeof(struct sensor_blob));
+		break;
+	}
+	default:
+		pr_err("%s: unknown ctrl id.\n", __func__);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int tegra_vi5_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct tegra_channel *chan = container_of(ctrl->handler,
+				struct tegra_channel, ctrl_handler);
+	int err = 0;
+
+	switch (ctrl->id) {
+	case TEGRA_CAMERA_CID_WRITE_ISPFORMAT:
+		chan->write_ispformat = ctrl->val;
+		break;
+	case TEGRA_CAMERA_CID_VI_CAPTURE_TIMEOUT:
+		chan->capture_timeout_ms = ctrl->val;
+		break;
+	default:
+		dev_err(&chan->video->dev, "%s:Not valid ctrl\n", __func__);
+		return -EINVAL;
+	}
+
+	return err;
+}
+
+static const struct v4l2_ctrl_ops vi5_ctrl_ops = {
+	.s_ctrl	= tegra_vi5_s_ctrl,
+	.g_volatile_ctrl = tegra_vi5_g_volatile_ctrl,
+};
+
+static const struct v4l2_ctrl_config vi5_custom_ctrls[] = {
+	{
+		.ops = &vi5_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_WRITE_ISPFORMAT,
+		.name = "Write ISP format",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.def = 1,
+		.min = 1,
+		.max = 1,
+		.step = 1,
+	},
+	{
+		.ops = &vi5_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_SENSOR_CONFIG,
+		.name = "Sensor configuration",
+		.type = V4L2_CTRL_TYPE_U32,
+		.flags = V4L2_CTRL_FLAG_READ_ONLY |
+			V4L2_CTRL_FLAG_HAS_PAYLOAD |
+			V4L2_CTRL_FLAG_VOLATILE,
+		.min = 0,
+		.max = 0xFFFFFFFF,
+		.def = 0,
+		.step = 1,
+		.dims = { SENSOR_CONFIG_SIZE },
+	},
+	{
+		.ops = &vi5_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_SENSOR_MODE_BLOB,
+		.name = "Sensor mode I2C packet",
+		.type = V4L2_CTRL_TYPE_U32,
+		.flags = V4L2_CTRL_FLAG_READ_ONLY |
+			V4L2_CTRL_FLAG_HAS_PAYLOAD |
+			V4L2_CTRL_FLAG_VOLATILE,
+		.min = 0,
+		.max = 0xFFFFFFFF,
+		.def = 0,
+		.step = 1,
+		.dims = { SENSOR_MODE_BLOB_SIZE },
+	},
+	{
+		.ops = &vi5_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_SENSOR_CONTROL_BLOB,
+		.name = "Sensor control I2C packet",
+		.type = V4L2_CTRL_TYPE_U32,
+		.flags = V4L2_CTRL_FLAG_READ_ONLY |
+			V4L2_CTRL_FLAG_HAS_PAYLOAD |
+			V4L2_CTRL_FLAG_VOLATILE,
+		.min = 0,
+		.max = 0xFFFFFFFF,
+		.def = 0,
+		.step = 1,
+		.dims = { SENSOR_CTRL_BLOB_SIZE },
+	},
+	{
+		.ops = &vi5_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_VI_CAPTURE_TIMEOUT,
+		.name = "Override capture timeout ms",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.def = CAPTURE_TIMEOUT_MS,
+		.min = -1,
+		.max = 0x7FFFFFFF,
+		.step = 1,
+	},
+};
+
+static int vi5_add_ctrls(struct tegra_channel *chan)
+{
+	int i;
+
+	/* Add vi5 custom controls */
+	for (i = 0; i < ARRAY_SIZE(vi5_custom_ctrls); i++) {
+		v4l2_ctrl_new_custom(&chan->ctrl_handler,
+			&vi5_custom_ctrls[i], NULL);
+		if (chan->ctrl_handler.error) {
+			dev_err(chan->vi->dev,
+				"Failed to add %s ctrl\n",
+				vi5_custom_ctrls[i].name);
+			return chan->ctrl_handler.error;
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * Find a free VI channel to open. Synchronize vi capture channel sharing
+ * with other clients.
+ */
+static int vi5_channel_open(struct tegra_channel *chan, u32 vi_port)
+{
+	bool found = false;
+	char chanFilePath[VI_CHAN_PATH_MAX];
+	int channel = 0;
+	struct file *filp = NULL;
+	long err = 0;
+
+	while (!found) {
+		sprintf(chanFilePath, "%s%u", VI_CHANNEL_DEV, channel);
+
+		filp = filp_open(chanFilePath, O_RDONLY, 0);
+
+		if (IS_ERR(filp)) {
+			err = PTR_ERR(filp);
+			/* Retry with the next available channel. Opening
+			 * a channel number greater than the ones supported
+			 * by the platform will trigger a ENODEV from the
+			 * VI capture channel driver
+			 */
+			if (err == -EBUSY)
+				channel++;
+			else {
+				dev_err(&chan->video->dev,
+					"Error opening VI capture channel node %s with err: %ld\n",
+					chanFilePath, err);
+				return -ENODEV;
+			}
+		} else
+			found = true;
+	}
+
+	err = 0;
+	chan->vi_channel_id[vi_port] = channel;
+
+	chan->tegra_vi_channel[vi_port] = filp->private_data;
+
+	return err;
+}
+
+static int vi5_channel_setup_queue(struct tegra_channel *chan,
+	unsigned int *nbuffers)
+{
+	*nbuffers = clamp(*nbuffers, CAPTURE_MIN_BUFFERS, CAPTURE_MAX_BUFFERS);
+
+	chan->capture_reqs_enqueued = 0;
+
+	return 0;
+}
+
+static struct tegra_csi_channel *find_linked_csi_channel(
+	struct tegra_channel *chan)
+{
+	struct tegra_csi_channel *csi_it;
+	struct tegra_csi_channel *csi_chan = NULL;
+	int i;
+
+	struct tegra_csi_device *csi = tegra_get_mc_csi();
+	if (csi == NULL)
+	{
+		dev_err(chan->vi->dev, "csi mc not found");
+		return NULL;
+	}
+	/* Find connected csi_channel */
+	list_for_each_entry(csi_it, &csi->csi_chans, list) {
+		for (i = 0; i < chan->num_subdevs; i++) {
+			if (chan->subdev[i] == &csi_it->subdev) {
+				csi_chan = csi_it;
+				break;
+			}
+		}
+	}
+	return csi_chan;
+}
+
+static int tegra_channel_capture_setup(struct tegra_channel *chan, unsigned int vi_port)
+{
+	struct vi_capture_setup setup = default_setup;
+	long err;
+
+	setup.queue_depth = chan->capture_queue_depth;
+
+	trace_tegra_channel_capture_setup(chan, 0);
+
+	chan->request[vi_port] = dma_alloc_coherent(chan->tegra_vi_channel[vi_port]->rtcpu_dev,
+					setup.queue_depth * setup.request_size,
+					&setup.iova, GFP_KERNEL);
+	chan->request_iova[vi_port] = setup.iova;
+
+	if (chan->request[vi_port] == NULL) {
+		dev_err(chan->vi->dev, "dma_alloc_coherent failed\n");
+		return -ENOMEM;
+	}
+
+	if (chan->is_slvsec) {
+		setup.channel_flags |= CAPTURE_CHANNEL_FLAG_SLVSEC;
+		setup.slvsec_stream_main = SLVSEC_STREAM_MAIN;
+		setup.slvsec_stream_sub = SLVSEC_STREAM_DISABLED;
+	}
+
+	/* Set the NVCSI PixelParser index (Stream ID) and VC ID*/
+	setup.csi_stream_id = chan->port[vi_port];
+	setup.virtual_channel_id = chan->virtual_channel;
+	/* Set CSI port info */
+	if (chan->pg_mode) {
+		setup.csi_port = NVCSI_PORT_UNSPECIFIED;
+	} else {
+		struct tegra_csi_channel *csi_chan = find_linked_csi_channel(chan);
+
+		if (csi_chan == NULL)
+		{
+			dev_err(chan->vi->dev, "csi_chan not found");
+			return -EINVAL;
+		}
+
+		setup.csi_port = csi_chan->ports[vi_port].csi_port;
+	}
+
+	if (chan->fmtinfo->fourcc == V4L2_PIX_FMT_NV16)
+		setup.channel_flags |= CAPTURE_CHANNEL_FLAG_SEMI_PLANAR;
+
+	err = vi_capture_setup(chan->tegra_vi_channel[vi_port], &setup);
+	if (err) {
+		dev_err(chan->vi->dev, "vi capture setup failed\n");
+		dma_free_coherent(chan->tegra_vi_channel[vi_port]->rtcpu_dev,
+				setup.queue_depth * setup.request_size,
+				chan->request, setup.iova);
+		return err;
+	}
+
+	return 0;
+}
+
+static void vi5_setup_surface(struct tegra_channel *chan,
+	struct tegra_channel_buffer *buf, unsigned int descr_index, unsigned int vi_port)
+{
+	dma_addr_t offset = buf->addr + chan->buffer_offset[vi_port];
+	u32 height = chan->format.height;
+	u32 width = chan->format.width;
+	u32 format = chan->fmtinfo->img_fmt;
+	u32 bpl = chan->format.bytesperline;
+	u32 data_type = chan->fmtinfo->img_dt;
+	u32 code = chan->fmtinfo->code;
+	u32 nvcsi_stream = chan->port[vi_port];
+	struct capture_descriptor_memoryinfo *desc_memoryinfo =
+		&chan->tegra_vi_channel[vi_port]->
+		capture_data->requests_memoryinfo[descr_index];
+	struct capture_descriptor *desc = &chan->request[vi_port][descr_index];
+
+	if (chan->valid_ports > NVCSI_STREAM_1) {
+		height = chan->gang_height;
+		width = chan->gang_width;
+		offset = buf->addr + chan->buffer_offset[1 - vi_port];
+	}
+
+	memcpy(desc, &capture_template, sizeof(capture_template));
+	memset(desc_memoryinfo, 0, sizeof(*desc_memoryinfo));
+
+	desc->sequence = chan->capture_descr_sequence;
+	desc->ch_cfg.match.stream = (1u << nvcsi_stream); /* one-hot bit encoding */
+	desc->ch_cfg.match.vc = (1u << chan->virtual_channel); /* one-hot bit encoding */
+	desc->ch_cfg.frame.frame_x = width;
+	desc->ch_cfg.frame.frame_y = height;
+	if (code == MEDIA_BUS_FMT_AVT_G4C2_1X8) {
+		desc->ch_cfg.dt_enable = 1;
+		desc->ch_cfg.dt_override = TEGRA_IMAGE_DT_RAW8;		
+		desc->ch_cfg.match.datatype = 0x0;
+		desc->ch_cfg.match.datatype_mask = 0x0;
+	} else {
+	desc->ch_cfg.match.datatype = data_type;
+	desc->ch_cfg.match.datatype_mask = 0x3f;
+		desc->ch_cfg.dt_enable = 0;
+	}
+	
+	desc->ch_cfg.pixfmt_enable = 1;
+	desc->ch_cfg.pixfmt.format = format;
+
+
+	desc_memoryinfo->surface[0].base_address = offset;
+	desc_memoryinfo->surface[0].size = chan->format.bytesperline * height;
+	desc->ch_cfg.atomp.surface_stride[0] = bpl;
+	if (chan->fmtinfo->fourcc == V4L2_PIX_FMT_NV16) {
+		desc_memoryinfo->surface[1].base_address = offset + chan->format.sizeimage / 2;
+		desc_memoryinfo->surface[1].size = chan->format.bytesperline * height;
+		desc->ch_cfg.atomp.surface_stride[1] = bpl;
+	}
+
+	if (chan->embedded_data_height > 0) {
+		desc->ch_cfg.embdata_enable = 1;
+		desc->ch_cfg.frame.embed_x = chan->embedded_data_width * BPP_MEM;
+		desc->ch_cfg.frame.embed_y = chan->embedded_data_height;
+
+		desc_memoryinfo->surface[VI_ATOMP_SURFACE_EMBEDDED].base_address
+			= chan->emb_buf;
+		desc_memoryinfo->surface[VI_ATOMP_SURFACE_EMBEDDED].size
+			= desc->ch_cfg.frame.embed_x * desc->ch_cfg.frame.embed_y;
+
+		desc->ch_cfg.atomp.surface_stride[VI_ATOMP_SURFACE_EMBEDDED]
+			= chan->embedded_data_width * BPP_MEM;
+	}
+	//capture sequence should increment for each vi channel
+	if ((chan->valid_ports - vi_port) == 1)
+		chan->capture_descr_sequence += 1;
+}
+
+static void vi5_release_buffer(struct tegra_channel *chan,
+	struct tegra_channel_buffer *buf)
+{
+	struct vb2_v4l2_buffer *vbuf = &buf->buf;
+
+	vbuf->sequence = chan->sequence++;
+	vbuf->field = V4L2_FIELD_NONE;
+	vb2_set_plane_payload(&vbuf->vb2_buf, 0, chan->format.sizeimage);
+
+	vb2_buffer_done(&vbuf->vb2_buf, buf->vb2_state);
+}
+
+static void vi5_capture_enqueue(struct tegra_channel *chan,
+	struct tegra_channel_buffer *buf)
+{
+	int err = 0;
+	unsigned int vi_port;
+	unsigned long flags;
+	struct tegra_mc_vi *vi = chan->vi;
+	struct vi_capture_req request[2] = {{
+		.buffer_index = 0,
+	}, {
+		.buffer_index = 0,
+	}};
+
+	for (vi_port = 0; vi_port < chan->valid_ports; vi_port++) {
+		vi5_setup_surface(chan, buf, chan->capture_descr_index, vi_port);
+		request[vi_port].buffer_index = chan->capture_descr_index;
+
+		err = vi_capture_request(chan->tegra_vi_channel[vi_port], &request[vi_port]);
+
+		if (err) {
+			dev_err(vi->dev, "uncorr_err: request dispatch err %d\n", err);
+			goto uncorr_err;
+		}
+
+		spin_lock_irqsave(&chan->capture_state_lock, flags);
+		if (chan->capture_state != CAPTURE_ERROR) {
+			chan->capture_state = CAPTURE_GOOD;
+			chan->capture_reqs_enqueued += 1;
+		}
+		spin_unlock_irqrestore(&chan->capture_state_lock, flags);
+		buf->capture_descr_index[vi_port] = chan->capture_descr_index;
+	}
+	chan->capture_descr_index = ((chan->capture_descr_index + 1)
+					% (chan->capture_queue_depth));
+
+	spin_lock(&chan->dequeue_lock);
+	list_add_tail(&buf->queue, &chan->dequeue);
+	spin_unlock(&chan->dequeue_lock);
+
+	wake_up_interruptible(&chan->dequeue_wait);
+
+	return;
+
+uncorr_err:
+	spin_lock_irqsave(&chan->capture_state_lock, flags);
+	chan->capture_state = CAPTURE_ERROR;
+	spin_unlock_irqrestore(&chan->capture_state_lock, flags);
+}
+
+static inline int32_t vi5_capture_timeout(struct tegra_channel *chan)
+{
+	if (chan->fmtinfo->code == MEDIA_BUS_FMT_AVT_G4C2_1X8) 
+		return -1; // Wait infinite
+
+	return chan->capture_timeout_ms;
+}
+
+static void vi5_capture_dequeue(struct tegra_channel *chan,
+	struct tegra_channel_buffer *buf)
+{
+	int err = 0;
+	bool frame_err = false;
+	int vi_port = 0;
+	int gang_prev_frame_id = 0;
+	unsigned long flags;
+	struct tegra_mc_vi *vi = chan->vi;
+	struct vb2_v4l2_buffer *vb = &buf->buf;
+	const int32_t timeout_ms = vi5_capture_timeout(chan);
+	struct timespec64 ts;
+	struct capture_descriptor *descr = NULL;
+
+	for (vi_port = 0; vi_port < chan->valid_ports; vi_port++) {
+		descr = &chan->request[vi_port][buf->capture_descr_index[vi_port]];
+
+		if (buf->vb2_state != VB2_BUF_STATE_ACTIVE)
+			goto rel_buf;
+
+		/* Dequeue a frame and check its capture status */
+		err = vi_capture_status(chan->tegra_vi_channel[vi_port], timeout_ms);
+		if (err) {
+			if (err == -ETIMEDOUT) {
+				if (timeout_ms < 0) {
+					spin_lock_irqsave(&chan->capture_state_lock, flags);
+					chan->capture_state = CAPTURE_ERROR_TIMEOUT;
+					spin_unlock_irqrestore(&chan->capture_state_lock, flags);
+					buf->vb2_state = VB2_BUF_STATE_ERROR;
+					goto rel_buf;
+				} else {
+					dev_err(vi->dev,
+						"uncorr_err: request timed out after %d ms\n",
+						timeout_ms);
+				}
+			} else {
+				dev_err(vi->dev, "uncorr_err: request err %d\n", err);
+			}
+			goto uncorr_err;
+		} else if (descr->status.status != CAPTURE_STATUS_SUCCESS) {
+			if ((descr->status.flags
+					& CAPTURE_STATUS_FLAG_CHANNEL_IN_ERROR) != 0) {
+				chan->queue_error = true;
+				dev_err(vi->dev, "uncorr_err: flags %d, err_data %d\n",
+					descr->status.flags, descr->status.err_data);
+			} else {
+				dev_warn(vi->dev,
+					"corr_err: discarding frame %d, flags: %d, "
+					"err_data %d\n",
+					descr->status.frame_id, descr->status.flags,
+					descr->status.err_data);
+				frame_err = true;
+			}
+		} else if (!vi_port) {
+			gang_prev_frame_id = descr->status.frame_id;
+		} else if (descr->status.frame_id != gang_prev_frame_id) {
+			dev_err(vi->dev, "frame_id out of sync: ch2 %d vs ch1 %d\n",
+					gang_prev_frame_id, descr->status.frame_id);
+			goto uncorr_err;
+		}
+
+		spin_lock_irqsave(&chan->capture_state_lock, flags);
+		if (chan->capture_state != CAPTURE_ERROR) {
+			chan->capture_reqs_enqueued -= 1;
+			chan->capture_state = CAPTURE_GOOD;
+		}
+		spin_unlock_irqrestore(&chan->capture_state_lock, flags);
+	}
+
+	wake_up_interruptible(&chan->start_wait);
+	/* Read SOF from capture descriptor */
+	ts = ns_to_timespec64((s64)descr->status.sof_timestamp);
+	trace_tegra_channel_capture_frame("sof", &ts);
+	vb->vb2_buf.timestamp = descr->status.sof_timestamp;
+
+	if (frame_err)
+		buf->vb2_state = VB2_BUF_STATE_ERROR;
+	else
+		buf->vb2_state = VB2_BUF_STATE_DONE;
+	/* Read EOF from capture descriptor */
+	ts = ns_to_timespec64((s64)descr->status.eof_timestamp);
+	trace_tegra_channel_capture_frame("eof", &ts);
+
+	goto rel_buf;
+
+uncorr_err:
+	spin_lock_irqsave(&chan->capture_state_lock, flags);
+	chan->capture_state = CAPTURE_ERROR;
+	spin_unlock_irqrestore(&chan->capture_state_lock, flags);
+
+	buf->vb2_state = VB2_BUF_STATE_ERROR;
+
+rel_buf:
+	vi5_release_buffer(chan, buf);
+}
+
+static int vi5_channel_error_recover(struct tegra_channel *chan,
+	bool queue_error)
+{
+	int err = 0;
+	unsigned int vi_port = 0;
+	struct tegra_channel_buffer *buf;
+	struct tegra_mc_vi *vi = chan->vi;
+	struct v4l2_subdev *csi_subdev;
+
+	/* stop vi channel */
+	for (vi_port = 0; vi_port < chan->valid_ports; vi_port++) {
+		err = vi_capture_release(chan->tegra_vi_channel[vi_port],
+			CAPTURE_CHANNEL_RESET_FLAG_IMMEDIATE);
+		if (err) {
+			dev_err(&chan->video->dev, "vi capture release failed\n");
+			goto done;
+		}
+		vi_channel_close_ex(chan->vi_channel_id[vi_port],
+					chan->tegra_vi_channel[vi_port]);
+		chan->tegra_vi_channel[vi_port] = NULL;
+	}
+
+
+	/* release all previously-enqueued capture buffers to v4l2 */
+	while (!list_empty(&chan->capture)) {
+		buf = dequeue_buffer(chan, false);
+		if (!buf)
+			break;
+		vb2_buffer_done(&buf->buf.vb2_buf, VB2_BUF_STATE_ERROR);
+	}
+	while (!list_empty(&chan->dequeue)) {
+		buf = dequeue_dequeue_buffer(chan);
+		if (!buf)
+			break;
+		buf->vb2_state = VB2_BUF_STATE_ERROR;
+		vi5_capture_dequeue(chan, buf);
+	}
+
+	/* report queue error to application */
+	if (queue_error)
+		vb2_queue_error(&chan->queue);
+
+	/* reset nvcsi stream */
+	csi_subdev = tegra_channel_find_linked_csi_subdev(chan);
+	if (!csi_subdev) {
+		dev_err(vi->dev, "unable to find linked csi subdev\n");
+		err = -1;
+		goto done;
+	}
+
+#if 0 /* disable for Canonical kernel */
+	v4l2_subdev_call(csi_subdev, core, sync,
+		V4L2_SYNC_EVENT_SUBDEV_ERROR_RECOVER);
+#endif
+
+	/* restart vi channel */
+	for (vi_port = 0; vi_port < chan->valid_ports; vi_port++) {
+		err = vi5_channel_open(chan, vi_port);
+		if (IS_ERR(chan->tegra_vi_channel[vi_port])) {
+			err = PTR_ERR(chan);
+			goto done;
+		}
+		err = tegra_channel_capture_setup(chan, vi_port);
+		if (err < 0)
+			goto done;
+	}
+
+	chan->sequence = 0;
+	tegra_channel_init_ring_buffer(chan);
+
+	chan->capture_reqs_enqueued = 0;
+
+	/* clear capture channel error state */
+	chan->capture_state = CAPTURE_IDLE;
+
+done:
+	return err;
+}
+
+static int tegra_channel_kthread_capture_enqueue(void *data)
+{
+	struct tegra_channel *chan = data;
+	struct tegra_channel_buffer *buf;
+	unsigned long flags;
+	set_freezable();
+
+	while (1) {
+		try_to_freeze();
+
+		wait_event_interruptible(chan->start_wait,
+			(kthread_should_stop() || !list_empty(&chan->capture)));
+
+		while (!(kthread_should_stop() || list_empty(&chan->capture))) {
+			spin_lock_irqsave(&chan->capture_state_lock, flags);
+			if ((chan->capture_state == CAPTURE_ERROR)
+					|| !(chan->capture_reqs_enqueued
+					< (chan->capture_queue_depth * chan->valid_ports))) {
+				spin_unlock_irqrestore(
+					&chan->capture_state_lock, flags);
+				break;
+			}
+			spin_unlock_irqrestore(&chan->capture_state_lock,
+				flags);
+
+			buf = dequeue_buffer(chan, false);
+			if (!buf)
+				break;
+
+			buf->vb2_state = VB2_BUF_STATE_ACTIVE;
+
+			vi5_capture_enqueue(chan, buf);
+		}
+
+		if (kthread_should_stop())
+			break;
+	}
+
+	return 0;
+}
+
+static int tegra_channel_kthread_capture_dequeue(void *data)
+{
+	int err = 0;
+	unsigned long flags;
+	struct tegra_channel *chan = data;
+	struct tegra_channel_buffer *buf;
+
+	set_freezable();
+	allow_signal(SIGINT);
+
+	while (1) {
+		try_to_freeze();
+
+		wait_event_interruptible(chan->dequeue_wait,
+			(kthread_should_stop()
+				|| !list_empty(&chan->dequeue)
+				|| (chan->capture_state == CAPTURE_ERROR)));
+
+		while (!(kthread_should_stop() || list_empty(&chan->dequeue)
+				|| (chan->capture_state == CAPTURE_ERROR))) {
+
+			buf = dequeue_dequeue_buffer(chan);
+			if (!buf)
+				break;
+
+			vi5_capture_dequeue(chan, buf);
+		}
+
+		spin_lock_irqsave(&chan->capture_state_lock, flags);
+		if (chan->capture_state == CAPTURE_ERROR_TIMEOUT) {
+			spin_unlock_irqrestore(&chan->capture_state_lock,
+				flags);
+			break;
+		}
+
+		if (chan->capture_state == CAPTURE_ERROR) {
+			spin_unlock_irqrestore(&chan->capture_state_lock,
+				flags);
+			err = tegra_channel_error_recover(chan, false);
+			if (err) {
+				dev_err(chan->vi->dev,
+					"fatal: error recovery failed\n");
+				break;
+			}
+		} else
+			spin_unlock_irqrestore(&chan->capture_state_lock,
+				flags);
+		if (kthread_should_stop())
+			break;
+	}
+
+	return 0;
+}
+
+static int vi5_channel_start_kthreads(struct tegra_channel *chan)
+{
+	int err = 0;
+
+	/* Start the kthread for capture enqueue */
+	if (chan->kthread_capture_start) {
+		dev_err(chan->vi->dev, "enqueue kthread already initialized\n");
+		err = -1;
+		goto done;
+	}
+	chan->kthread_capture_start = kthread_run(
+		tegra_channel_kthread_capture_enqueue, chan, chan->video->name);
+	if (IS_ERR(chan->kthread_capture_start)) {
+		dev_err(&chan->video->dev,
+			"failed to run kthread for capture enqueue\n");
+		err = PTR_ERR(chan->kthread_capture_start);
+		goto done;
+	}
+
+	/* Start the kthread for capture dequeue */
+	if (chan->kthread_capture_dequeue) {
+		dev_err(chan->vi->dev, "dequeue kthread already initialized\n");
+		err = -1;
+		goto done;
+	}
+	chan->kthread_capture_dequeue = kthread_run(
+		tegra_channel_kthread_capture_dequeue, chan, chan->video->name);
+	if (IS_ERR(chan->kthread_capture_dequeue)) {
+		dev_err(&chan->video->dev,
+			"failed to run kthread for capture dequeue\n");
+		err = PTR_ERR(chan->kthread_capture_dequeue);
+		goto done;
+	}
+
+done:
+	return err;
+}
+
+static void vi5_channel_stop_kthreads(struct tegra_channel *chan)
+{
+	mutex_lock(&chan->stop_kthread_lock);
+
+	/* Stop the kthread for capture enqueue */
+	if (chan->kthread_capture_start) {
+		kthread_stop(chan->kthread_capture_start);
+		chan->kthread_capture_start = NULL;
+	}
+
+	/* Stop the kthread for capture dequeue */
+	if (chan->kthread_capture_dequeue) {
+		send_sig(SIGINT, chan->kthread_capture_dequeue, 1);
+		kthread_stop(chan->kthread_capture_dequeue);
+		chan->kthread_capture_dequeue = NULL;
+	}
+
+	mutex_unlock(&chan->stop_kthread_lock);
+}
+
+static void vi5_unit_get_device_handle(struct platform_device *pdev,
+		uint32_t csi_stream_id, struct device **dev)
+{
+	if (dev)
+		*dev = vi_csi_stream_to_nvhost_device(pdev, csi_stream_id);
+	else
+		dev_err(&pdev->dev, "dev pointer is NULL\n");
+}
+
+static int vi5_channel_start_streaming(struct vb2_queue *vq, u32 count)
+{
+	struct tegra_channel *chan = vb2_get_drv_priv(vq);
+	/* WAR: With newer version pipe init has some race condition */
+	/* TODO: resolve this issue to block userspace not to cleanup media */
+	int ret = 0;
+	int vi_port = 0;
+	unsigned long flags;
+	struct v4l2_subdev *sd;
+	struct device_node *node;
+	struct sensor_mode_properties *sensor_mode;
+	struct camera_common_data *s_data;
+	unsigned int emb_buf_size = 0;
+
+	ret = tegra_channel_alloc_buffer_queue(chan, vq->num_buffers);
+	if (ret < 0)
+		goto err_open_ex;
+
+	/* Skip in bypass mode */
+	if (!chan->bypass) {
+		for (vi_port = 0; vi_port < chan->valid_ports; vi_port++) {
+			int err = vi5_channel_open(chan, vi_port);
+
+			if (err)
+				goto err_open_ex;
+
+			spin_lock_irqsave(&chan->capture_state_lock, flags);
+			chan->capture_state = CAPTURE_IDLE;
+			spin_unlock_irqrestore(&chan->capture_state_lock, flags);
+
+			if (!chan->pg_mode) {
+				sd = chan->subdev_on_csi;
+				node = sd->dev->of_node;
+				s_data = to_camera_common_data(sd->dev);
+
+				/* get sensor properties from DT */
+				if (s_data != NULL && node != NULL) {
+					int idx = s_data->mode_prop_idx;
+
+					emb_buf_size = 0;
+					if (idx < s_data->sensor_props.\
+								num_modes) {
+						sensor_mode =
+							&s_data->sensor_props.\
+							sensor_modes[idx];
+
+						chan->embedded_data_width =
+							sensor_mode->\
+							image_properties.width;
+						chan->embedded_data_height =
+							sensor_mode->\
+							 image_properties.\
+						      embedded_metadata_height;
+						/* rounding up to page size */
+						emb_buf_size =
+							round_up(chan->\
+							embedded_data_width *
+								chan->\
+							embedded_data_height *
+							BPP_MEM, PAGE_SIZE);
+					}
+				}
+				/* Allocate buffer for Embedded Data if need to*/
+				if (emb_buf_size > chan->emb_buf_size) {
+					struct device *vi_unit_dev;
+
+					vi5_unit_get_device_handle(\
+						chan->vi->ndev, chan->port[0],\
+						&vi_unit_dev);
+				/*
+				 * if old buffer is smaller than what we need,
+				 * release the old buffer and re-allocate a
+				 * bigger one below.
+				 */
+					if (chan->emb_buf_size > 0) {
+						dma_free_coherent(vi_unit_dev,
+							chan->emb_buf_size,
+							chan->emb_buf_addr,
+							chan->emb_buf);
+						chan->emb_buf_size = 0;
+					}
+
+					chan->emb_buf_addr =
+						dma_alloc_coherent(vi_unit_dev,
+							emb_buf_size,
+						&chan->emb_buf, GFP_KERNEL);
+					if (!chan->emb_buf_addr) {
+						dev_err(&chan->video->dev,
+							"Can't allocate memory"
+							"for embedded data\n");
+						goto err_setup;
+					}
+					chan->emb_buf_size = emb_buf_size;
+				}
+			}
+			ret = tegra_channel_capture_setup(chan, vi_port);
+			if (ret < 0)
+				goto err_setup;
+		}
+		chan->sequence = 0;
+		tegra_channel_init_ring_buffer(chan);
+
+		ret = vi5_channel_start_kthreads(chan);
+		if (ret != 0)
+			goto err_start_kthreads;
+	}
+
+	/* csi stream/sensor devices should be streamon post vi channel setup */
+	ret = tegra_channel_set_stream(chan, true);
+	if (ret < 0)
+		goto err_set_stream;
+
+	ret = tegra_channel_write_blobs(chan);
+	if (ret < 0)
+		goto err_write_blobs;
+
+	return 0;
+
+err_write_blobs:
+	tegra_channel_set_stream(chan, false);
+
+err_set_stream:
+	if (!chan->bypass)
+		vi5_channel_stop_kthreads(chan);
+
+err_start_kthreads:
+	if (!chan->bypass)
+		for (vi_port = 0; vi_port < chan->valid_ports; vi_port++)
+			vi_capture_release(chan->tegra_vi_channel[vi_port],
+				CAPTURE_CHANNEL_RESET_FLAG_IMMEDIATE);
+
+err_setup:
+	if (!chan->bypass)
+		for (vi_port = 0; vi_port < chan->valid_ports; vi_port++) {
+			vi_channel_close_ex(chan->vi_channel_id[vi_port],
+						chan->tegra_vi_channel[vi_port]);
+			chan->tegra_vi_channel[vi_port] = NULL;
+		}
+
+err_open_ex:
+	vq->start_streaming_called = 0;
+	tegra_channel_queued_buf_done(chan, VB2_BUF_STATE_QUEUED, false);
+
+	return ret;
+}
+
+static int vi5_channel_stop_streaming(struct vb2_queue *vq)
+{
+	struct tegra_channel *chan = vb2_get_drv_priv(vq);
+	long err;
+	int vi_port = 0;
+	if (!chan->bypass) {
+		for (vi_port = 0; vi_port < chan->valid_ports; vi_port++) {
+			vi_capture_abort(chan->tegra_vi_channel[vi_port]);
+		}
+		
+		vi5_channel_stop_kthreads(chan);
+	}
+		
+
+	/* csi stream/sensor(s) devices to be closed before vi channel */
+	tegra_channel_set_stream(chan, false);
+
+	if (!chan->bypass) {
+		for (vi_port = 0; vi_port < chan->valid_ports; vi_port++) {
+			err = vi_capture_release(chan->tegra_vi_channel[vi_port],
+				CAPTURE_CHANNEL_RESET_FLAG_IMMEDIATE);
+
+			if (err)
+				dev_err(&chan->video->dev,
+					"vi capture release failed\n");
+
+			/* Release capture requests */
+			if (chan->request[vi_port] != NULL) {
+				dma_free_coherent(chan->tegra_vi_channel[vi_port]->rtcpu_dev,
+				chan->capture_queue_depth * sizeof(struct capture_descriptor),
+				chan->request[vi_port], chan->request_iova[vi_port]);
+			}
+			chan->request[vi_port] = NULL;
+
+			/* Release emd data buffers */
+			if (chan->emb_buf_size > 0) {
+				struct device *vi_unit_dev;
+				vi5_unit_get_device_handle(chan->vi->ndev, chan->port[0],\
+										&vi_unit_dev);
+				dma_free_coherent(vi_unit_dev, chan->emb_buf_size,
+								chan->emb_buf_addr, chan->emb_buf);
+				chan->emb_buf_size = 0;
+			}
+
+			vi_channel_close_ex(chan->vi_channel_id[vi_port],
+						chan->tegra_vi_channel[vi_port]);
+			chan->tegra_vi_channel[vi_port] = NULL;
+		}
+
+		/* release all remaining buffers to v4l2 */
+		tegra_channel_queued_buf_done(chan, VB2_BUF_STATE_ERROR, false);
+
+	}
+
+	return 0;
+}
+
+int tegra_vi5_enable(struct tegra_mc_vi *vi)
+{
+	int ret;
+
+	ret = tegra_camera_emc_clk_enable();
+	if (ret)
+		goto err_emc_enable;
+
+	return 0;
+
+err_emc_enable:
+	return ret;
+}
+
+void tegra_vi5_disable(struct tegra_mc_vi *vi)
+{
+	tegra_channel_ec_close(vi);
+	tegra_camera_emc_clk_disable();
+}
+
+static int vi5_power_on(struct tegra_channel *chan)
+{
+	int ret = 0;
+	struct device *dev;
+	struct tegra_mc_vi *vi;
+	struct tegra_csi_device *csi;
+
+	vi = chan->vi;
+	csi = vi->csi;
+	vi5_unit_get_device_handle(vi->ndev, chan->port[0], &dev);
+
+	/* Resume VI5 to set ICC bandwidth with maximum value */
+	if (pm_runtime_enabled(dev)) {
+		ret = pm_runtime_resume_and_get(dev);
+		if (ret < 0) {
+			return ret;
+		}
+	}
+
+	ret = tegra_vi5_enable(vi);
+	if (ret < 0)
+		return ret;
+
+	ret = tegra_channel_set_power(chan, 1);
+	if (ret < 0) {
+		dev_err(vi->dev, "Failed to power on subdevices\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static void vi5_power_off(struct tegra_channel *chan)
+{
+	int ret = 0;
+	struct device *dev;
+	struct tegra_mc_vi *vi;
+	struct tegra_csi_device *csi;
+
+	vi = chan->vi;
+	csi = vi->csi;
+	vi5_unit_get_device_handle(vi->ndev, chan->port[0], &dev);
+
+	ret = tegra_channel_set_power(chan, 0);
+	if (ret < 0)
+		dev_err(vi->dev, "Failed to power off subdevices\n");
+
+	tegra_vi5_disable(vi);
+
+	/* Suspend VI5 to reset ICC bandwidth request */
+	if (pm_runtime_enabled(dev)) {
+		pm_runtime_mark_last_busy(dev);
+		pm_runtime_put_autosuspend(dev);
+	}
+}
+
+struct tegra_vi_fops vi5_fops = {
+	.vi_power_on = vi5_power_on,
+	.vi_power_off = vi5_power_off,
+	.vi_start_streaming = vi5_channel_start_streaming,
+	.vi_stop_streaming = vi5_channel_stop_streaming,
+	.vi_setup_queue = vi5_channel_setup_queue,
+	.vi_error_recover = vi5_channel_error_recover,
+	.vi_add_ctrls = vi5_add_ctrls,
+	.vi_init_video_formats = vi5_init_video_formats,
+	.vi_unit_get_device_handle = vi5_unit_get_device_handle,
+};
+EXPORT_SYMBOL(vi5_fops);
diff --git a/drivers/media/platform/tegra/camera/vi/vi5_formats.h b/drivers/media/platform/tegra/camera/vi/vi5_formats.h
new file mode 100644
index 0000000..08e246d
--- /dev/null
+++ b/drivers/media/platform/tegra/camera/vi/vi5_formats.h
@@ -0,0 +1,159 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * NVIDIA Tegra Video Input Device Driver VI5 formats
+ *
+ * Copyright (c) 2017-2022, NVIDIA CORPORATION.  All rights reserved.
+ */
+
+#ifndef __VI5_FORMATS_H_
+#define __VI5_FORMATS_H_
+
+#include <media/tegra_camera_core.h>
+
+/*
+ * These go into the VI_CHn_PIXFMT_FORMAT register bits 7:0
+ * Output pixel memory format for the VI channel.
+ */
+enum tegra_image_format {
+	TEGRA_IMAGE_FORMAT_T_R5G6B5 = 1,
+	TEGRA_IMAGE_FORMAT_T_B5G6R5,
+
+	TEGRA_IMAGE_FORMAT_T_R8 = 5,
+
+	TEGRA_IMAGE_FORMAT_T_A8B8G8R8 = 8,
+	TEGRA_IMAGE_FORMAT_T_A8R8G8B8,
+	TEGRA_IMAGE_FORMAT_T_B8G8R8A8,
+	TEGRA_IMAGE_FORMAT_T_R8G8B8A8,
+
+	TEGRA_IMAGE_FORMAT_T_Y8_U8__Y8_V8 = 16,
+	TEGRA_IMAGE_FORMAT_T_Y8_V8__Y8_U8,
+	TEGRA_IMAGE_FORMAT_T_V8_Y8__U8_Y8,
+	TEGRA_IMAGE_FORMAT_T_U8_Y8__V8_Y8,
+
+	TEGRA_IMAGE_FORMAT_T_Y8__U8V8_N420 = 34,
+	TEGRA_IMAGE_FORMAT_T_Y8__V8U8_N420,
+
+	TEGRA_IMAGE_FORMAT_T_B5G5R5A1 = 42,
+	TEGRA_IMAGE_FORMAT_T_R5G5B5A1,
+	TEGRA_IMAGE_FORMAT_T_Y8__U8V8_N422,
+	TEGRA_IMAGE_FORMAT_T_Y8__V8U8_N422,
+	TEGRA_IMAGE_FORMAT_T_Y8__U8__V8_N422,
+	TEGRA_IMAGE_FORMAT_T_Y8__U8__V8_N420,
+
+	TEGRA_IMAGE_FORMAT_T_DPCM_RAW10 = 64,
+
+	TEGRA_IMAGE_FORMAT_T_A2B10G10R10 = 68,
+	TEGRA_IMAGE_FORMAT_T_A2R10G10B10,
+	TEGRA_IMAGE_FORMAT_T_B10G10R10A2,
+	TEGRA_IMAGE_FORMAT_T_R10G10B10A2,
+
+	TEGRA_IMAGE_FORMAT_T_A4B4G4R4 = 80,
+	TEGRA_IMAGE_FORMAT_T_A4R4G4B4,
+	TEGRA_IMAGE_FORMAT_T_B4G4R4A4,
+	TEGRA_IMAGE_FORMAT_T_R4G4B4A4,
+	TEGRA_IMAGE_FORMAT_T_A1B5G5R5,
+	TEGRA_IMAGE_FORMAT_T_A1R5G5B5,
+
+	TEGRA_IMAGE_FORMAT_T_Y10__V10U10_N420 = 98,
+	TEGRA_IMAGE_FORMAT_T_Y10__U10V10_N420,
+	TEGRA_IMAGE_FORMAT_T_Y10__U10__V10_N420,
+	TEGRA_IMAGE_FORMAT_T_Y10__V10U10_N422,
+	TEGRA_IMAGE_FORMAT_T_Y10__U10V10_N422,
+	TEGRA_IMAGE_FORMAT_T_Y10__U10__V10_N422,
+
+	TEGRA_IMAGE_FORMAT_T_DPCM_RAW12 = 128,
+
+	TEGRA_IMAGE_FORMAT_T_R16_ISP = 194,
+	TEGRA_IMAGE_FORMAT_T_R16_F,
+	TEGRA_IMAGE_FORMAT_T_R16,
+	TEGRA_IMAGE_FORMAT_T_R16_I,
+
+	TEGRA_IMAGE_FORMAT_T_R32 = 230,
+
+	TEGRA_IMAGE_FORMAT_T_R32_F = 232,
+
+	TEGRA_IMAGE_FORMAT_T_DPCM_RAW16 = 254,
+	TEGRA_IMAGE_FORMAT_T_DPCM_RAW20,
+};
+
+static const struct tegra_video_format vi5_video_formats[] = {
+	/* RAW 6: TODO */
+
+	/* RAW 7: TODO */
+
+	/* RAW 8 */
+	TEGRA_VIDEO_FORMAT(RAW8, 8, AVT_G4C2_1X8, 1, 1, T_R8,
+				RAW8, AVT_G4C2, "AVT G4C2"),
+	TEGRA_VIDEO_FORMAT(RAW8, 8, Y8_1X8, 1, 1, T_R8,
+				RAW8, GREY, "Mono8"),				
+	TEGRA_VIDEO_FORMAT(RAW8, 8, SRGGB8_1X8, 1, 1, T_R8,
+				RAW8, SRGGB8, "RGRG.. GBGB.."),
+	TEGRA_VIDEO_FORMAT(RAW8, 8, SGRBG8_1X8, 1, 1, T_R8,
+				RAW8, SGRBG8, "GRGR.. BGBG.."),
+	TEGRA_VIDEO_FORMAT(RAW8, 8, SGBRG8_1X8, 1, 1, T_R8,
+				RAW8, SGBRG8, "GBGB.. RGRG.."),
+	TEGRA_VIDEO_FORMAT(RAW8, 8, SBGGR8_1X8, 1, 1, T_R8,
+				RAW8, SBGGR8, "BGBG.. GRGR.."),
+
+	/* RAW 10 */
+	TEGRA_VIDEO_FORMAT(RAW10, 10, Y10_1X10, 2, 1, T_R16,
+				RAW10, Y10, "Mono10"),
+	TEGRA_VIDEO_FORMAT(RAW10, 10, SRGGB10_1X10, 2, 1, T_R16,
+				RAW10, SRGGB10, "RGRG.. GBGB.."),
+	TEGRA_VIDEO_FORMAT(RAW10, 10, SGRBG10_1X10, 2, 1, T_R16,
+				RAW10, SGRBG10, "GRGR.. BGBG.."),
+	TEGRA_VIDEO_FORMAT(RAW10, 10, SGBRG10_1X10, 2, 1, T_R16,
+				RAW10, SGBRG10, "GBGB.. RGRG.."),
+	TEGRA_VIDEO_FORMAT(RAW10, 10, SBGGR10_1X10, 2, 1, T_R16,
+				RAW10, SBGGR10, "BGBG.. GRGR.."),
+
+	/* RAW 12 */
+	TEGRA_VIDEO_FORMAT(RAW12, 12, Y12_1X12, 2, 1, T_R16,
+				RAW12, Y12, "Mono12"),
+	TEGRA_VIDEO_FORMAT(RAW12, 12, SRGGB12_1X12, 2, 1, T_R16,
+				RAW12, SRGGB12, "RGRG.. GBGB.."),
+	TEGRA_VIDEO_FORMAT(RAW12, 12, SGRBG12_1X12, 2, 1, T_R16,
+				RAW12, SGRBG12, "GRGR.. BGBG.."),
+	TEGRA_VIDEO_FORMAT(RAW12, 12, SGBRG12_1X12, 2, 1, T_R16,
+				RAW12, SGBRG12, "GBGB.. RGRG.."),
+	TEGRA_VIDEO_FORMAT(RAW12, 12, SBGGR12_1X12, 2, 1, T_R16,
+				RAW12, SBGGR12, "BGBG.. GRGR.."),
+
+	/* RGB888 */
+	TEGRA_VIDEO_FORMAT(RGB888, 24, RGB888_1X24, 4, 1, T_A8B8G8R8,
+				RGB888, RGBA32, "RGBA-8-8-8-8"),
+
+	TEGRA_VIDEO_FORMAT(RGB888, 24, RGB888_1X24, 4, 1, T_B8G8R8A8,
+				RGB888, XRGB32, "RGB-8-8-8"),
+	TEGRA_VIDEO_FORMAT(RGB888, 24, BGR888_1X24, 4, 1, T_A8R8G8B8,
+				RGB888, XBGR32, "BGR-8-8-8"),
+	
+	TEGRA_VIDEO_FORMAT(RGB888, 24, RGB888_1X24, 4, 1, T_A8B8G8R8,
+				RGB888, RGBX32, "RGB-8-8-8"),
+	TEGRA_VIDEO_FORMAT(RGB888, 24, BGR888_1X24, 4, 1, T_R8G8B8A8,
+				RGB888, BGRX32, "BGR-8-8-8"),
+
+
+
+	/* YUV422 */
+	TEGRA_VIDEO_FORMAT(YUV422, 16, UYVY8_1X16, 2, 1, T_U8_Y8__V8_Y8,
+				YUV422_8, UYVY, "YUV 4:2:2"),
+	TEGRA_VIDEO_FORMAT(YUV422, 16, VYUY8_1X16, 2, 1, T_V8_Y8__U8_Y8,
+				YUV422_8, VYUY, "YUV 4:2:2"),
+	TEGRA_VIDEO_FORMAT(YUV422, 16, YUYV8_1X16, 2, 1, T_Y8_U8__Y8_V8,
+				YUV422_8, YUYV, "YUV 4:2:2"),
+	TEGRA_VIDEO_FORMAT(YUV422, 16, YVYU8_1X16, 2, 1, T_Y8_V8__Y8_U8,
+				YUV422_8, YVYU, "YUV 4:2:2"),
+	TEGRA_VIDEO_FORMAT(YUV422, 16, UYVY8_1X16, 1, 1, T_Y8__V8U8_N422,
+				YUV422_8, NV16, "NV16"),
+	TEGRA_VIDEO_FORMAT(YUV422, 16, UYVY8_2X8, 2, 1, T_U8_Y8__V8_Y8,
+				YUV422_8, UYVY, "YUV 4:2:2 UYVY"),
+	TEGRA_VIDEO_FORMAT(YUV422, 16, VYUY8_2X8, 2, 1, T_V8_Y8__U8_Y8,
+				YUV422_8, VYUY, "YUV 4:2:2 VYUY"),
+	TEGRA_VIDEO_FORMAT(YUV422, 16, YUYV8_2X8, 2, 1, T_Y8_U8__Y8_V8,
+				YUV422_8, YUYV, "YUV 4:2:2 YUYV"),
+	TEGRA_VIDEO_FORMAT(YUV422, 16, YVYU8_2X8, 2, 1, T_Y8_V8__Y8_U8,
+				YUV422_8, YVYU, "YUV 4:2:2 YVYU"),
+};
+
+#endif
diff --git a/drivers/video/tegra/host/vi/vi5.c b/drivers/video/tegra/host/vi/vi5.c
new file mode 100644
index 0000000..e7f6e51
--- /dev/null
+++ b/drivers/video/tegra/host/vi/vi5.c
@@ -0,0 +1,474 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// SPDX-FileCopyrightText: Copyright (c) 2017-2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
+/*
+ * VI5 driver
+ */
+
+#include <asm/ioctls.h>
+#include <linux/debugfs.h>
+#include <linux/device.h>
+#include <linux/dma-buf.h>
+#include <linux/dma-mapping.h>
+#include <linux/export.h>
+#include <linux/fs.h>
+#include <linux/interconnect.h>
+#include <linux/module.h>
+#include <linux/nvhost.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_graph.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/platform/tegra/emc_bwmgr.h>
+#include <linux/platform/tegra/latency_allowance.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/regulator/consumer.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/version.h>
+#include <media/fusa-capture/capture-vi-channel.h>
+#include <media/mc_common.h>
+#include <media/tegra_camera_platform.h>
+#include <media/vi.h>
+#include <soc/tegra/camrtc-capture.h>
+#include <soc/tegra/fuse.h>
+#include <uapi/linux/nvhost_vi_ioctl.h>
+
+#include "capture/capture-support.h"
+#include "vi5.h"
+
+/* HW capability, pixels per clock */
+#define NUM_PPC		8
+/* 15% bus protocol overhead */
+/* + 5% SW overhead */
+#define VI_OVERHEAD	20
+
+#define VI_CLASS_ID 0x30
+
+struct host_vi5 {
+	struct platform_device *pdev;
+	struct platform_device *vi_thi;
+	struct vi vi_common;
+	struct icc_path *icc_write;
+	struct clk *clk;
+
+	/* Debugfs */
+	struct vi5_debug {
+		struct debugfs_regset32 ch0;
+	} debug;
+
+	/* WAR: Adding a temp flags to avoid registering to V4L2 and
+	 * tegra camera platform device.
+	 */
+	bool skip_v4l2_init;
+};
+
+static int vi5_init_debugfs(struct host_vi5 *vi5);
+static void vi5_remove_debugfs(struct host_vi5 *vi5);
+
+static int vi5_alloc_syncpt(struct platform_device *pdev,
+			const char *name,
+			uint32_t *syncpt_id)
+{
+	struct nvhost_device_data *info = platform_get_drvdata(pdev);
+	struct host_vi5 *vi5 = info->private_data;
+
+	return capture_alloc_syncpt(vi5->vi_thi, name, syncpt_id);
+}
+
+int nvhost_vi5_aggregate_constraints(struct platform_device *dev,
+				int clk_index,
+				unsigned long floor_rate,
+				unsigned long pixelrate,
+				unsigned long bw_constraint)
+{
+	struct nvhost_device_data *pdata = nvhost_get_devdata(dev);
+
+	if (!pdata) {
+		dev_err(&dev->dev,
+			"No platform data, fall back to default policy\n");
+		return 0;
+	}
+
+	if (clk_index != 0)
+		return 0;
+	/*
+	 * SCF and V4l2 send request using NVHOST_CLK through tegra_camera_platform,
+	 * which is calculated in floor_rate.
+	 */
+	return floor_rate + (pixelrate / pdata->num_ppc);
+}
+
+static void vi5_release_syncpt(struct platform_device *pdev, uint32_t id)
+{
+	struct nvhost_device_data *info = platform_get_drvdata(pdev);
+	struct host_vi5 *vi5 = info->private_data;
+
+	capture_release_syncpt(vi5->vi_thi, id);
+}
+
+static void vi5_get_gos_table(struct platform_device *pdev, int *count,
+			const dma_addr_t **table)
+{
+	struct nvhost_device_data *info = platform_get_drvdata(pdev);
+	struct host_vi5 *vi5 = info->private_data;
+
+	capture_get_gos_table(vi5->vi_thi, count, table);
+}
+
+static int vi5_get_syncpt_gos_backing(struct platform_device *pdev,
+			uint32_t id,
+			dma_addr_t *syncpt_addr,
+			uint32_t *gos_index,
+			uint32_t *gos_offset)
+{
+	struct nvhost_device_data *info = platform_get_drvdata(pdev);
+	struct host_vi5 *vi5 = info->private_data;
+
+	return capture_get_syncpt_gos_backing(vi5->vi_thi, id,
+				syncpt_addr, gos_index, gos_offset);
+}
+
+static struct vi_channel_drv_ops vi5_channel_drv_ops = {
+	.alloc_syncpt = vi5_alloc_syncpt,
+	.release_syncpt = vi5_release_syncpt,
+	.get_gos_table = vi5_get_gos_table,
+	.get_syncpt_gos_backing = vi5_get_syncpt_gos_backing,
+};
+
+int vi5_priv_early_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct nvhost_device_data *info;
+	struct device_node *thi_np;
+	struct platform_device *thi = NULL;
+	struct host_vi5 *vi5;
+	int err = 0;
+
+	info = (void *)of_device_get_match_data(dev);
+	if (unlikely(info == NULL)) {
+		dev_WARN(dev, "no platform data\n");
+		return -ENODATA;
+	}
+
+	thi_np = of_parse_phandle(dev->of_node, "nvidia,vi-falcon-device", 0);
+	if (thi_np == NULL) {
+		dev_WARN(dev, "missing %s handle\n", "nvidia,vi-falcon-device");
+		return -ENODEV;
+	}
+
+	thi = of_find_device_by_node(thi_np);
+	of_node_put(thi_np);
+
+	if (thi == NULL)
+		return -ENODEV;
+
+	if (thi->dev.driver == NULL) {
+		err = -EPROBE_DEFER;
+		goto put_vi;
+	}
+
+	err = vi_channel_drv_fops_register(&vi5_channel_drv_ops);
+	if (err) {
+		dev_warn(&pdev->dev, "syncpt fops register failed, defer probe\n");
+		goto put_vi;
+	}
+
+	vi5 = (struct host_vi5 *) devm_kzalloc(dev, sizeof(*vi5), GFP_KERNEL);
+	if (!vi5) {
+		err = -ENOMEM;
+		goto put_vi;
+	}
+
+	vi5->skip_v4l2_init = of_property_read_bool(dev->of_node,
+					"nvidia,skip-v4l2-init");
+	vi5->vi_thi = thi;
+	vi5->pdev = pdev;
+	info->pdev = pdev;
+	mutex_init(&info->lock);
+	platform_set_drvdata(pdev, info);
+	info->private_data = vi5;
+
+	(void) dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(39));
+
+#ifdef CONFIG_DMABUF_DEFERRED_UNMAPPING
+	if (dma_buf_defer_unmapping(dev, true) < 0)
+		dev_warn(dev, "Failed to set deferred dma buffer unmapping\n");
+#endif
+
+	return 0;
+
+put_vi:
+	platform_device_put(thi);
+	if (err != -EPROBE_DEFER)
+		dev_err(&pdev->dev, "probe failed: %d\n", err);
+
+	info->private_data = NULL;
+
+	return err;
+}
+
+static int vi5_set_rate(struct tegra_camera_dev_info *cdev_info, unsigned long rate)
+{
+	struct nvhost_device_data *info = platform_get_drvdata(cdev_info->pdev);
+	struct host_vi5 *vi5 = info->private_data;
+
+	return clk_set_rate(vi5->clk, rate);
+}
+
+static struct tegra_camera_dev_ops vi5_cdev_ops = {
+	.set_rate = vi5_set_rate,
+};
+
+int vi5_priv_late_probe(struct platform_device *pdev)
+{
+	struct tegra_camera_dev_info vi_info;
+	struct nvhost_device_data *info = platform_get_drvdata(pdev);
+	struct host_vi5 *vi5 = info->private_data;
+	int err;
+
+	memset(&vi_info, 0, sizeof(vi_info));
+	vi_info.pdev = pdev;
+	vi_info.hw_type = HWTYPE_VI;
+	vi_info.ppc = NUM_PPC;
+	vi_info.overhead = VI_OVERHEAD;
+	vi_info.ops = &vi5_cdev_ops;
+
+	err = tegra_camera_device_register(&vi_info, vi5);
+	if (err)
+		goto device_release;
+
+	vi5_init_debugfs(vi5);
+
+	return 0;
+
+device_release:
+	nvhost_client_device_release(pdev);
+
+	return err;
+}
+
+static int vi5_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct nvhost_device_data *pdata;
+	struct host_vi5 *vi5;
+	int err;
+
+	dev_dbg(dev, "%s: probe %s\n", __func__, pdev->name);
+
+	err = vi5_priv_early_probe(pdev);
+	if (err)
+		goto error;
+
+	pdata = platform_get_drvdata(pdev);
+	vi5 = pdata->private_data;
+
+	vi5->clk = devm_clk_get(dev, NULL);
+	if (IS_ERR(vi5->clk)) {
+		dev_err(&pdev->dev, "failed to get clock\n");
+		return PTR_ERR(vi5->clk);
+	}
+
+	vi5->icc_write = devm_of_icc_get(dev, "write");
+	if (IS_ERR(vi5->icc_write)) {
+		dev_err(dev, "failed to get icc write handle\n");
+		return PTR_ERR(vi5->icc_write);
+	}
+
+	err = nvhost_client_device_get_resources(pdev);
+	if (err)
+		goto put_vi;
+
+	err = nvhost_module_init(pdev);
+	if (err)
+		goto put_vi;
+
+	err = nvhost_client_device_init(pdev);
+	if (err)
+		goto deinit;
+
+	err = vi5_priv_late_probe(pdev);
+	if (err)
+		goto deinit;
+
+	return 0;
+
+deinit:
+	nvhost_module_deinit(pdev);
+put_vi:
+	platform_device_put(vi5->vi_thi);
+	if (err != -EPROBE_DEFER)
+		dev_err(dev, "probe failed: %d\n", err);
+error:
+	return err;
+}
+
+static int vi5_remove(struct platform_device *pdev)
+{
+	struct nvhost_device_data *pdata = platform_get_drvdata(pdev);
+	struct host_vi5 *vi5 = pdata->private_data;
+
+	tegra_camera_device_unregister(vi5);
+
+	vi5_remove_debugfs(vi5);
+	platform_device_put(vi5->vi_thi);
+	return 0;
+}
+
+static struct nvhost_device_data t19_vi5_info = {
+	.devfs_name		= "vi",
+	.moduleid		= 2, //NVHOST_MODULE_VI,
+	.clocks = {
+		{"vi", UINT_MAX},
+		{"emc", 0,
+		 NVHOST_MODULE_ID_EXTERNAL_MEMORY_CONTROLLER,
+		 TEGRA_SET_EMC_FLOOR, false, UINT_MAX}
+	},
+	.num_ppc		= 8,
+	.aggregate_constraints	= nvhost_vi5_aggregate_constraints,
+	.pre_virt_init		= vi5_priv_early_probe,
+	.post_virt_init		= vi5_priv_late_probe,
+	.bwmgr_client_id	= TEGRA_BWMGR_CLIENT_VI,
+};
+
+static struct nvhost_device_data t23x_vi0_info = {
+	.devfs_name		= "vi0",
+	.moduleid		= 2, //NVHOST_MODULE_VI,
+	.clocks = {
+		{"vi", UINT_MAX},
+	},
+	.num_ppc		= 8,
+	.aggregate_constraints	= nvhost_vi5_aggregate_constraints,
+	.pre_virt_init		= vi5_priv_early_probe,
+	.post_virt_init		= vi5_priv_late_probe,
+	.class			= VI_CLASS_ID,
+};
+
+static struct nvhost_device_data t23x_vi1_info = {
+	.devfs_name		= "vi1",
+	.moduleid		= 3, //NVHOST_MODULE_VI2,
+	.clocks = {
+		{"vi", UINT_MAX},
+	},
+	.num_ppc		= 8,
+	.aggregate_constraints	= nvhost_vi5_aggregate_constraints,
+	.pre_virt_init		= vi5_priv_early_probe,
+	.post_virt_init		= vi5_priv_late_probe,
+	.class			= VI_CLASS_ID,
+};
+
+static const struct of_device_id tegra_vi5_of_match[] = {
+	{
+		.name = "vi",
+		.compatible = "nvidia,tegra194-vi",
+		.data = &t19_vi5_info,
+	},
+	{
+		.name = "vi0",
+		.compatible = "nvidia,tegra234-vi",
+		.data = &t23x_vi0_info,
+	},
+	{
+		.name = "vi1",
+		.compatible = "nvidia,tegra234-vi",
+		.data = &t23x_vi1_info,
+	},
+	{ },
+};
+MODULE_DEVICE_TABLE(of, tegra_vi5_of_match);
+
+static int vi_runtime_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct nvhost_device_data *info = platform_get_drvdata(pdev);
+	struct host_vi5 *vi5 = info->private_data;
+	int err;
+
+	if (nvhost_module_pm_ops.runtime_suspend != NULL) {
+		err = nvhost_module_pm_ops.runtime_suspend(dev);
+		if (!err && vi5->icc_write) {
+			err = icc_set_bw(vi5->icc_write, 0, 0);
+			if (err)
+				dev_warn(dev,
+					 "failed to set icc_write bw: %d\n", err);
+			return 0;
+		}
+		return err;
+	}
+
+	return -EOPNOTSUPP;
+}
+
+static int vi_runtime_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct nvhost_device_data *pdata = platform_get_drvdata(pdev);
+	struct host_vi5 *vi5 = pdata->private_data;
+	int err;
+
+	if (nvhost_module_pm_ops.runtime_resume != NULL) {
+		err = nvhost_module_pm_ops.runtime_resume(dev);
+		if (!err && vi5->icc_write) {
+			err = icc_set_bw(vi5->icc_write, 0, UINT_MAX);
+			if (err)
+				dev_warn(dev,
+					 "failed to set icc_write bw: %d\n", err);
+			return 0;
+		}
+		return err;
+	}
+
+	return -EOPNOTSUPP;
+}
+
+const struct dev_pm_ops vi_pm_ops = {
+	SET_RUNTIME_PM_OPS(vi_runtime_suspend, vi_runtime_resume, NULL)
+	SET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,
+				pm_runtime_force_resume)
+};
+
+static struct platform_driver vi5_driver = {
+	.probe = vi5_probe,
+	.remove = vi5_remove,
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "tegra194-vi5",
+#ifdef CONFIG_OF
+		.of_match_table = tegra_vi5_of_match,
+#endif
+#ifdef CONFIG_PM
+		.pm = &vi_pm_ops,
+#endif
+	},
+};
+
+module_platform_driver(vi5_driver);
+
+/* === Debugfs ========================================================== */
+
+static int vi5_init_debugfs(struct host_vi5 *vi5)
+{
+	static const struct debugfs_reg32 vi5_ch_regs[] = {
+		{ .name = "protocol_version", 0x00 },
+		{ .name = "perforce_changelist", 0x4 },
+		{ .name = "build_timestamp", 0x8 },
+		{ .name = "channel_count", 0x80 },
+	};
+	struct nvhost_device_data *pdata = platform_get_drvdata(vi5->pdev);
+	struct dentry *dir = pdata->debugfs;
+	struct vi5_debug *debug = &vi5->debug;
+
+	debug->ch0.base = pdata->aperture[0];
+	debug->ch0.regs = vi5_ch_regs;
+	debug->ch0.nregs = ARRAY_SIZE(vi5_ch_regs);
+	debugfs_create_regset32("ch0", S_IRUGO, dir, &debug->ch0);
+
+	return 0;
+}
+
+static void vi5_remove_debugfs(struct host_vi5 *vi5)
+{
+}
+MODULE_LICENSE("GPL");
diff --git a/hardware/nvidia/t23x/nv-public/overlay/Makefile b/hardware/nvidia/t23x/nv-public/overlay/Makefile
index 93728f4..72c9704 100644
--- a/hardware/nvidia/t23x/nv-public/overlay/Makefile
+++ b/hardware/nvidia/t23x/nv-public/overlay/Makefile
@@ -65,6 +65,7 @@ dtbo-y += tegra234-p3767-camera-p3768-imx219-A.dtbo
 dtbo-y += tegra234-p3767-camera-p3768-imx219-imx477.dtbo
 dtbo-y += tegra234-p3767-camera-p3768-imx477-C.dtbo
 dtbo-y += tegra234-p3767-camera-p3768-imx477-A.dtbo
+dtbo-y += tegra234-p3767-camera-p3768-avt-tc358743.dtbo
 
 ifneq ($(dtb-y),)
 dtb-y := $(addprefix $(makefile-path)/,$(dtb-y))
diff --git a/hardware/nvidia/t23x/nv-public/overlay/tegra234-p3767-camera-p3768-2avt-tc358743-gmsl.dts b/hardware/nvidia/t23x/nv-public/overlay/tegra234-p3767-camera-p3768-2avt-tc358743-gmsl.dts
new file mode 100644
index 0000000..422f1cf
--- /dev/null
+++ b/hardware/nvidia/t23x/nv-public/overlay/tegra234-p3767-camera-p3768-2avt-tc358743-gmsl.dts
@@ -0,0 +1,462 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// SPDX-FileCopyrightText: Copyright (c) 2023-2024, SSRC/TII. All rights reserved.
+
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/clock/tegra234-clock.h>
+#include <dt-bindings/gpio/tegra234-gpio.h>
+
+#define CAM_I2C_MUX		TEGRA234_AON_GPIO(CC, 3)
+#define TC358743_RST	TEGRA234_MAIN_GPIO(AC, 0)
+#define TC358743_INT	TEGRA234_MAIN_GPIO(P, 1)
+
+/ {
+	overlay-name = "Camera Alvium (2x2 lanes) and HDMI-CSI2 Bridge TC358743 (4 lanes)";
+	jetson-header-name = "Jetson 24pin CSI Connector";
+	compatible = "nvidia,p3768-0000+p3767-0000", "nvidia,p3768-0000+p3767-0001", "nvidia,p3768-0000+p3767-0003", "nvidia,p3768-0000+p3767-0004", "nvidia,p3768-0000+p3767-0005";
+	/* Alvium connected on CSI A/B and TC358743 connected on CSI C/D */
+
+	fragment@0 {
+		target-path = "/";
+		__overlay__ {
+			tegra-capture-vi {
+				status = "okay";
+				compatible = "alliedvision,tegra-camrtc-capture-vi", "nvidia,tegra-camrtc-capture-vi";
+				num-channels = <3>;
+				ports {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					status = "okay";
+					port@0 {
+						status = "okay";
+						reg = <0>;
+						avt_csi2_vi_in0: endpoint {
+							port-index = <0>;
+							bus-width = <2>;
+							remote-endpoint = <&avt_csi2_csi_out0>;
+						};
+					};
+					port@1 {
+						status = "okay";
+						reg = <1>;
+						avt_csi2_vi_in1: endpoint {
+							status = "okay";
+							port-index = <1>;
+							bus-width = <2>;
+							remote-endpoint = <&avt_csi2_csi_out1>;
+						};
+					};
+					port@2 {
+						status = "okay";
+						reg = <2>;
+						tc358743_vi_in0: endpoint {
+							status = "okay";
+							port-index = <2>;
+							bus-width = <4>;
+							remote-endpoint = <&tc358743_csi_out0>;
+						};
+					};
+				};
+			};
+		};
+	};
+
+	fragment@1 {
+		target-path="/bus@0";
+		__overlay__ {
+			host1x@13e00000 {
+				nvcsi@15a00000 {
+					status = "okay";
+					num-channels = <3>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+					channel@0 {
+						status = "okay";
+						reg = <0>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+							status = "okay";
+							port@0 {
+								status = "okay";
+								reg = <0>;
+								avt_csi2_csi_in0: endpoint@0 {
+									status = "okay";
+									port-index = <0>;
+									bus-width = <2>;
+									remote-endpoint = <&avt_csi2_i2c_out0>;
+								};
+							};
+							port@1 {
+								status = "okay";
+								reg = <1>;
+								avt_csi2_csi_out0: endpoint@1 {
+									status = "okay";
+									remote-endpoint = <&avt_csi2_vi_in0>;
+								};
+							};
+						};
+					};
+					channel@1 {
+						status = "okay";
+						reg = <1>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+							port@0 {
+								status = "okay";
+								reg = <0>;
+								avt_csi2_csi_in1: endpoint@2 {
+									status = "okay";
+									port-index = <1>;
+									bus-width = <2>;
+									remote-endpoint = <&avt_csi2_i2c_out1>;
+								};
+							};
+							port@1 {
+								status = "okay";
+								reg = <1>;
+								avt_csi2_csi_out1: endpoint@3 {
+									status = "okay";
+									remote-endpoint = <&avt_csi2_vi_in1>;
+								};
+							};
+						};
+					};
+				};
+				channel@1 {
+					status = "okay";
+					reg = <2>;
+					ports {
+						#address-cells = <1>;
+						#size-cells = <0>;
+						port@0 {
+							status = "okay";
+							reg = <0>;
+							tc358743_csi_in0: endpoint@4 {
+								status = "okay";
+								port-index = <2>;
+								bus-width = <4>;
+								remote-endpoint = <&tc358743_i2c_out0>;
+							};
+						};
+						port@1 {
+							status = "okay";
+							reg = <1>;
+							tc358743_csi_out0: endpoint@5 {
+								status = "okay";
+								remote-endpoint = <&tc358743_vi_in0>;
+							};
+						};
+					};
+				};
+			};
+		};
+	};
+
+	fragment@2 {
+		target-path = "/bus@0";
+		__overlay__ {
+			cam_i2cmux {
+				status = "okay";
+				compatible = "i2c-mux-gpio";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				mux-gpios = <&gpio_aon CAM_I2C_MUX GPIO_ACTIVE_HIGH>;
+				i2c-parent = <&cam_i2c>;
+				i2c@0 {
+					status = "okay";
+					reg = <0>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+					rbpcv2_imx219_a@10 {
+						status = "disabled";
+					};
+					avt_csi2_cam0@3c {
+						compatible = "alliedvision,avt3-nv";
+						/* I2C device address */
+						reg = <0x3c>;
+						status = "okay";
+						/* V4L2 device node location */
+						devnode = "video0";
+						avt3,userptr;
+						mode0 {
+							num_lanes = "2";
+							tegra_sinterface = "serial_a";
+							lane_polarity = "6";
+
+							discontinuous_clk = "no";
+							cil_settletime = "0";
+							embedded_metadata_height = "0";
+
+							mclk_khz = "24000";
+							phy_mode = "DPHY";
+							dpcm_enable = "false";
+
+							csi_pixel_bit_depth = "4";
+
+							active_w = "5488";
+							active_h = "4112";
+							pixel_t = "bayer_bggr";
+							readout_orientation = "0";
+							line_length = "5488";
+							inherent_gain = "1";
+							mclk_multiplier = "31.25";
+							pix_clk_hz = "750000000";
+
+							gain_factor = "16";
+							framerate_factor = "1000000";
+							exposure_factor = "1000000";
+							min_gain_val = "16"; /* 1.0 */
+							max_gain_val = "256"; /* 16.0 */
+							step_gain_val = "1"; /* 0.125 */
+							min_hdr_ratio = "1";
+							max_hdr_ratio = "64";
+							min_framerate = "1500000"; /* 1.5 */
+							max_framerate = "30000000"; /* 30 */
+							step_framerate = "1";
+							min_exp_time = "34"; /* us */
+							max_exp_time = "550385"; /* us */
+							step_exp_time = "1";
+						};
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+							port@0 {
+								reg = <0>;
+								avt_csi2_i2c_out0: endpoint {
+									port-index = <0>;
+									bus-width = <2>;
+									data-lanes = <1 2>;
+									clock-lanes = <0>;
+									link-frequencies = /bits/ 64 <750000000>;
+									remote-endpoint = <&avt_csi2_csi_in0>;
+								};
+							};
+						};
+					};
+				};
+				i2c@1 {
+					status = "okay";
+					reg = <1>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+					rbpcv2_imx219_b@10 {
+						status = "disabled";
+					};
+					avt_csi2_cam1@3d {
+						compatible = "alliedvision,avt3-nv";
+						/* I2C device address */
+						reg = <0x3d>;
+						status = "okay";
+						/* V4L2 device node location */
+						devnode = "video1";
+						avt3,userptr;
+						mode0 {
+							num_lanes = "2";
+							tegra_sinterface = "serial_b";
+							lane_polarity = "6";
+
+							discontinuous_clk = "no";
+							cil_settletime = "0";
+							embedded_metadata_height = "0";
+
+							mclk_khz = "24000";
+							phy_mode = "DPHY";
+							dpcm_enable = "false";
+
+							csi_pixel_bit_depth = "4";
+
+							active_w = "5488";
+							active_h = "4112";
+							pixel_t = "bayer_bggr";
+							readout_orientation = "0";
+							line_length = "5488";
+							inherent_gain = "1";
+							mclk_multiplier = "31.25";
+							pix_clk_hz = "750000000";	/* to be changed to 650MHz */
+
+							gain_factor = "16";
+							framerate_factor = "1000000";
+							exposure_factor = "1000000";
+							min_gain_val = "16"; /* 1.0 */
+							max_gain_val = "256"; /* 16.0 */
+							step_gain_val = "1"; /* 0.125 */
+							min_hdr_ratio = "1";
+							max_hdr_ratio = "64";
+							min_framerate = "1500000"; /* 1.5 */
+							max_framerate = "30000000"; /* 30 */
+							step_framerate = "1";
+							min_exp_time = "34"; /* us */
+							max_exp_time = "550385"; /* us */
+							step_exp_time = "1";
+						};
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+							port@0 {
+								reg = <0>;
+								avt_csi2_i2c_out1: endpoint {
+									port-index = <1>;
+									bus-width = <2>;
+									data-lanes = <1 2>;
+									clock-lanes = <0>;	/* to be checked */
+									link-frequencies = /bits/ 64 <750000000>;
+									remote-endpoint = <&avt_csi2_csi_in1>;
+								};
+							};
+						};
+					};
+				};
+				i2c@3 {
+					status = "okay";
+					reg = <2>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+					tc358743@0f {
+						status = "okay";
+						compatible = "toshiba,tc358743";
+						reg = <0x0F>; /* shifted by 2 */
+						devnode = "video2";
+						refclk_hz = <27000000>;  // refclk_hz -> regclk
+						refclk = <27000000>;  // refclk_hz -> regclk
+						reset-gpios = <&gpio TC358743_RST GPIO_ACTIVE_HIGH>;
+						// interrupts = <&tegra_main_gpio TC358743_INT GPIO_ACTIVE_LOW>;
+						clocks = <&bpmp TEGRA234_CLK_EXTPERIPH1>;
+						clock-names = "extperiph1";
+						clock-frequency = <27000000>;
+						mclk = "extperiph1";
+						/* Physical dimensions of sensor */
+						physical_w = "4.713";
+						physical_h = "3.494";
+						/* Sensor Model */
+						sensor_model ="tc358743";
+						use_sensor_mode_id = "true";
+						num_lanes = "4";
+						tegra_sinterface = "serial_c";
+						phy_mode = "DPHY";
+						discontinuous_clk = "no";
+						cil_settletime = "30";
+						ddc5v_delay = <2>;
+						enable_hdcp = "false";
+						lineinitcnt = <0xe80>;
+						lptxtimecnt = <0x003>;
+						tclk_headercnt = <0x1403>;
+						tclk_trailcnt = <0x00>;
+						ths_headercnt = <0x0103>;
+						twakeup = <0x4882>;
+						tclk_postcnt = <0x008>;
+						ths_trailcnt = <0x02>;
+						hstxvregcnt = <0>;
+						active_h = "720";
+						active_w = "1280";
+						default_framerate = "50000000"; /* 50.0 fps */
+						lane_polarity = "0";
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+							port@0 {
+								reg = <0>;
+								tc358743_i2c_out0: endpoint {
+									port-index = <3>;
+									bus-width = <4>;
+									data-lanes = <1 2 3 4>;
+									clock-lanes = <0>;
+									link-frequencies = /bits/ 64 <297000000>; // <594000000>; // <297000000>; // <148500000>;
+									remote-endpoint = <&tc358743_csi_in0>;
+								};
+							};
+						};
+					};
+				};
+			};
+		};
+	};
+
+
+	fragment@3 {
+		target-path = "/";
+		__overlay__ {
+			gpio@2200000 {
+				camera-control-output-low {
+					gpio-hog;
+					output-low;
+					gpios = <TC358743_RST 0>;
+					label = "cam0-rst";
+				};
+				camera-control-input {
+					status = "okay";
+					gpio-hog;
+					gpios = <TC358743_INT 0>;
+					input;
+					label = "tc358743-int";
+				};
+			};
+			avt_csitl {
+				supported_data_types = [ 31 ];
+				min_announced_frames = <1>;
+				ipu {
+					y_min = <32>;
+					y_inc = <1>;
+					y_max = <32768>;
+					x_min = <256>;
+					x_inc = <192>;
+					x_max = <32768>;
+				};
+			};
+			tegra-camera-platform {
+				status = "okay";
+				compatible = "nvidia, tegra-camera-platform";
+				num_csi_lanes = <8>;
+				max_lane_speed = <1500000>;
+				min_bits_per_pixel = <10>;
+				vi_peak_byte_per_pixel = <2>;
+				vi_bw_margin_pct = <25>;
+				max_pixel_rate = <7500000>;
+				isp_peak_byte_per_pixel = <5>;
+				isp_bw_margin_pct = <25>;
+
+				modules {
+					status = "okay";
+					module0 {
+						status = "okay";
+						badge = "avt_csi2_cam0";
+						position = "front";
+						orientation = "1";
+						drivernode0 {
+							status = "okay";
+							pcl_id = "v4l2_sensor";
+							devname = "avt_csi2_cam0";
+							proc-device-tree = "/proc/device-tree/bus@0/i2c@3180000/avt_csi2_cam0@3c";
+						};
+					};
+					module1 {
+						status = "okay";
+						badge = "avt_csi2_cam1";
+						position = "rear";
+						orientation = "0";
+						drivernode0 {
+							status = "okay";
+							pcl_id = "v4l2_sensor";
+							devname = "avt_csi2_cam1";
+							proc-device-tree = "/proc/device-tree/bus@0/i2c@3180000/avt_csi2_cam1@3d";
+						};
+					};
+					module2 {
+						status = "okay";
+						badge = "tc358743";
+						position = "rear";
+						orientation = "0";
+						drivernode0 {
+							status = "okay";
+							pcl_id = "v4l2_sensor";
+							devname = "tc358743";
+							proc-device-tree = "/proc/device-tree/bus@0/i2c@3180000/tc358743@0f";
+						};
+					};
+				};
+			};
+		};
+	};
+};
diff --git a/hardware/nvidia/t23x/nv-public/overlay/tegra234-p3767-camera-p3768-avt-tc358743.dts b/hardware/nvidia/t23x/nv-public/overlay/tegra234-p3767-camera-p3768-avt-tc358743.dts
new file mode 100644
index 0000000..76cf4da
--- /dev/null
+++ b/hardware/nvidia/t23x/nv-public/overlay/tegra234-p3767-camera-p3768-avt-tc358743.dts
@@ -0,0 +1,344 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// SPDX-FileCopyrightText: Copyright (c) 2023-2024, SSRC/TII. All rights reserved.
+
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/clock/tegra234-clock.h>
+#include <dt-bindings/gpio/tegra234-gpio.h>
+
+#define CAM_I2C_MUX		TEGRA234_AON_GPIO(CC, 3)
+#define TC358743_RST	TEGRA234_MAIN_GPIO(AC, 0)
+#define TC358743_INT	TEGRA234_MAIN_GPIO(P, 1)
+
+/ {
+	overlay-name = "Camera Alvium and HDMI-CSI2 Bridge TC358743";
+	jetson-header-name = "Jetson 24pin CSI Connector";
+	compatible = "nvidia,p3768-0000+p3767-0000", "nvidia,p3768-0000+p3767-0001", "nvidia,p3768-0000+p3767-0003", "nvidia,p3768-0000+p3767-0004", "nvidia,p3768-0000+p3767-0005";
+	/* Alvium connected on CSI A/B and TC358743 connected on CSI C/D */
+
+	fragment@0 {
+		target-path = "/";
+		__overlay__ {
+			tegra-capture-vi {
+				status = "okay";
+				compatible = "alliedvision,tegra-camrtc-capture-vi", "nvidia,tegra-camrtc-capture-vi";
+				num-channels = <2>;
+				ports {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					status = "okay";
+					port@0 {
+						status = "okay";
+						reg = <0>;
+						avt_csi2_vi_in0: endpoint {
+							port-index = <0>;
+							bus-width = <4>;
+							remote-endpoint = <&avt_csi2_csi_out0>;
+						};
+					};
+					port@1 {
+						status = "okay";
+						reg = <1>;
+						tc358743_vi_in0: endpoint {
+							status = "okay";
+							port-index = <2>;
+							bus-width = <2>;
+							remote-endpoint = <&tc358743_csi_out0>;
+						};
+					};
+				};
+			};
+		};
+	};
+
+	fragment@1 {
+		target-path="/bus@0";
+		__overlay__ {
+			host1x@13e00000 {
+				nvcsi@15a00000 {
+					status = "okay";
+					num-channels = <2>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+					channel@0 {
+						status = "okay";
+						reg = <0>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+							status = "okay";
+							port@0 {
+								status = "okay";
+								reg = <0>;
+								avt_csi2_csi_in0: endpoint@0 {
+									status = "okay";
+									port-index = <0>;
+									bus-width = <4>;
+									remote-endpoint = <&avt_csi2_i2c_out0>;
+								};
+							};
+							port@1 {
+								status = "okay";
+								reg = <1>;
+								avt_csi2_csi_out0: endpoint@1 {
+									status = "okay";
+									remote-endpoint = <&avt_csi2_vi_in0>;
+								};
+							};
+						};
+					};
+					channel@1 {
+						status = "okay";
+						reg = <1>;
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+							port@0 {
+								status = "okay";
+								reg = <0>;
+								tc358743_csi_in0: endpoint@2 {
+									status = "okay";
+									port-index = <2>;
+									bus-width = <2>;
+									remote-endpoint = <&tc358743_i2c_out0>;
+								};
+							};
+							port@1 {
+								status = "okay";
+								reg = <1>;
+								tc358743_csi_out0: endpoint@3 {
+									status = "okay";
+									remote-endpoint = <&tc358743_vi_in0>;
+								};
+							};
+						};
+					};
+				};
+			};
+		};
+	};
+
+	fragment@2 {
+		target-path = "/bus@0";
+		__overlay__ {
+			cam_i2cmux {
+				status = "okay";
+				compatible = "i2c-mux-gpio";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				mux-gpios = <&gpio_aon CAM_I2C_MUX GPIO_ACTIVE_HIGH>;
+				i2c-parent = <&cam_i2c>;
+				i2c@0 {
+					status = "okay";
+					reg = <0>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+					rbpcv2_imx219_a@10 {
+						status = "disabled";
+					};
+					avt_csi2_cam@3c {
+						compatible = "alliedvision,avt3-nv";
+						/* I2C device address */
+						reg = <0x3c>;
+						status = "okay";
+						/* V4L2 device node location */
+						devnode = "video0";
+						avt3,userptr;
+						mode0 {
+							num_lanes = "4";
+							tegra_sinterface = "serial_a";
+							lane_polarity = "6";
+
+							discontinuous_clk = "no";
+							cil_settletime = "0";
+							embedded_metadata_height = "0";
+
+							mclk_khz = "24000";
+							phy_mode = "DPHY";
+							dpcm_enable = "false";
+
+							csi_pixel_bit_depth = "4";
+
+							active_w = "5488";
+							active_h = "4112";
+							pixel_t = "bayer_bggr";
+							readout_orientation = "0";
+							line_length = "5488";
+							inherent_gain = "1";
+							mclk_multiplier = "31.25";
+							pix_clk_hz = "750000000";
+
+							gain_factor = "16";
+							framerate_factor = "1000000";
+							exposure_factor = "1000000";
+							min_gain_val = "16"; /* 1.0 */
+							max_gain_val = "256"; /* 16.0 */
+							step_gain_val = "1"; /* 0.125 */
+							min_hdr_ratio = "1";
+							max_hdr_ratio = "64";
+							min_framerate = "1500000"; /* 1.5 */
+							max_framerate = "30000000"; /* 30 */
+							step_framerate = "1";
+							min_exp_time = "34"; /* us */
+							max_exp_time = "550385"; /* us */
+							step_exp_time = "1";
+						};
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+							port@0 {
+								reg = <0>;
+								avt_csi2_i2c_out0: endpoint {
+									port-index = <0>;
+									bus-width = <4>;
+									data-lanes = <1 2 3 4>;
+									clock-lanes = <0>;
+									link-frequencies = /bits/ 64 <400000000>;
+									remote-endpoint = <&avt_csi2_csi_in0>;
+								};
+							};
+						};
+					};
+				};
+				i2c@1 {
+					status = "okay";
+					reg = <1>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+					rbpcv2_imx219_c@10 {
+						status = "disabled";
+					};
+					tc358743@0f {
+						status = "okay";
+						compatible = "toshiba,tc358743";
+						reg = <0x0F>; /* shifted by 2 */
+						devnode = "video1";
+						refclk_hz = <27000000>;  // refclk_hz -> regclk
+						refclk = <27000000>;  // refclk_hz -> regclk
+						reset-gpios = <&gpio TC358743_RST GPIO_ACTIVE_HIGH>;
+						// interrupts = <&tegra_main_gpio TC358743_INT GPIO_ACTIVE_LOW>;
+						clocks = <&bpmp TEGRA234_CLK_EXTPERIPH1>;
+						clock-names = "extperiph1";
+						clock-frequency = <27000000>;
+						mclk = "extperiph1";
+						/* Physical dimensions of sensor */
+						physical_w = "4.713";
+						physical_h = "3.494";
+						/* Sensor Model */
+						sensor_model ="tc358743";
+						use_sensor_mode_id = "true";
+						num_lanes = "2";
+						tegra_sinterface = "serial_c";
+						phy_mode = "DPHY";
+						discontinuous_clk = "no";
+						cil_settletime = "30";
+						ddc5v_delay = <2>;
+						enable_hdcp = "false";
+						lineinitcnt = <0xe80>;
+						lptxtimecnt = <0x003>;
+						tclk_headercnt = <0x1403>;
+						tclk_trailcnt = <0x00>;
+						ths_headercnt = <0x0103>;
+						twakeup = <0x4882>;
+						tclk_postcnt = <0x008>;
+						ths_trailcnt = <0x02>;
+						hstxvregcnt = <0>;
+						active_h = "720";
+						active_w = "1280";
+						default_framerate = "50000000"; /* 50.0 fps */
+						lane_polarity = "0";
+						ports {
+							#address-cells = <1>;
+							#size-cells = <0>;
+							port@0 {
+								reg = <0>;
+								tc358743_i2c_out0: endpoint {
+									port-index = <2>;
+									bus-width = <2>;
+									data-lanes = <1 2>;
+									clock-lanes = <0>;
+									link-frequencies = /bits/ 64 <297000000>; // <594000000>; // <297000000>; // <148500000>;
+									remote-endpoint = <&tc358743_csi_in0>;
+								};
+							};
+						};
+					};
+				};
+			};
+		};
+	};
+
+	fragment@3 {
+		target-path = "/";
+		__overlay__ {
+			gpio@2200000 {
+				camera-control-output-low {
+					gpio-hog;
+					output-low;
+					gpios = <TC358743_RST 0>;
+					label = "cam0-rst";
+				};
+				camera-control-input {
+					status = "okay";
+					gpio-hog;
+					gpios = <TC358743_INT 0>;
+					input;
+					label = "tc358743-int";
+				};
+			};
+			avt_csitl {
+				supported_data_types = [ 31 ];
+				min_announced_frames = <1>;
+				ipu {
+					y_min = <32>;
+					y_inc = <1>;
+					y_max = <32768>;
+					x_min = <256>;
+					x_inc = <192>;
+					x_max = <32768>;
+				};
+			};
+			tegra-camera-platform {
+				status = "okay";
+				compatible = "nvidia, tegra-camera-platform";
+				num_csi_lanes = <8>;
+				max_lane_speed = <1500000>;
+				min_bits_per_pixel = <10>;
+				vi_peak_byte_per_pixel = <2>;
+				vi_bw_margin_pct = <25>;
+				max_pixel_rate = <7500000>;
+				isp_peak_byte_per_pixel = <5>;
+				isp_bw_margin_pct = <25>;
+
+				modules {
+					status = "okay";
+					module0 {
+						status = "okay";
+						badge = "avt_csi2_cam";
+						position = "front";
+						orientation = "1";
+						drivernode0 {
+							status = "okay";
+							pcl_id = "v4l2_sensor";
+							devname = "avt_csi2 0-003c";
+							proc-device-tree = "/proc/device-tree/bus@0/i2c@3180000/avt_csi2_cam@3c";
+						};
+					};
+					module1 {
+						status = "okay";
+						badge = "tc358743";
+						position = "rear";
+						orientation = "0";
+						drivernode0 {
+							status = "okay";
+							pcl_id = "v4l2_sensor";
+							devname = "tc358743 1-000f";
+							proc-device-tree = "/proc/device-tree/bus@0/i2c@3180000/tc358743@0f";
+						};
+					};
+				};
+			};
+		};
+	};
+};
diff --git a/include/media/avt-csi2-regs.h b/include/media/avt-csi2-regs.h
new file mode 100644
index 0000000..ae4a449
--- /dev/null
+++ b/include/media/avt-csi2-regs.h
@@ -0,0 +1,419 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/* 
+ * Allied Vision Alvium register definitons
+ * 
+ * Copyright (C) 2022 - 2024 Allied Vision Technologies GmbH
+ */
+
+#ifndef __AVT_CSI2_REGS_H__
+#define __AVT_CSI2_REGS_H__
+
+// BCRM register offsets
+#define BCRM_VERSION_32R 				0x0000
+#define BCRM_FEATURE_INQUIRY_64R 			0x0008
+#define BCRM_DEVICE_FIRMWARE_VERSION_64R 		0x0010
+#define BCRM_WRITE_HANDSHAKE_8RW 			0x0018
+
+/* Streaming Control Registers */
+#define BCRM_SUPPORTED_CSI2_LANE_COUNTS_8R 		0x0040
+#define BCRM_CSI2_LANE_COUNT_8RW 			0x0044
+#define BCRM_CSI2_CLOCK_MIN_32R 			0x0048
+#define BCRM_CSI2_CLOCK_MAX_32R 			0x004C
+#define BCRM_CSI2_CLOCK_32RW 				0x0050
+#define BCRM_BUFFER_SIZE_32R 				0x0054
+
+#define BCRM_IPU_X_MIN_32W 				0x0058
+#define BCRM_IPU_X_MAX_32W 				0x005C
+#define BCRM_IPU_X_INC_32W 				0x0060
+#define BCRM_IPU_Y_MIN_32W 				0x0064
+#define BCRM_IPU_Y_MAX_32W 				0x0068
+#define BCRM_IPU_Y_INC_32W 				0x006C
+#define BCRM_IPU_X_32R 					0x0070
+#define BCRM_IPU_Y_32R 					0x0074
+
+#define BCRM_PHY_RESET_8RW 				0x0078
+#define BCRM_STREAM_ON_DELAY_32RW 			0x007C
+
+/* Acquisition Control Registers */
+#define BCRM_ACQUISITION_START_8RW 			0x0080
+#define BCRM_ACQUISITION_STOP_8RW 			0x0084
+#define BCRM_ACQUISITION_ABORT_8RW 			0x0088
+#define BCRM_ACQUISITION_STATUS_8R 			0x008C
+#define BCRM_ACQUISITION_FRAME_RATE_64RW 		0x0090
+#define BCRM_ACQUISITION_FRAME_RATE_MIN_64R 		0x0098
+#define BCRM_ACQUISITION_FRAME_RATE_MAX_64R 		0x00A0
+#define BCRM_ACQUISITION_FRAME_RATE_INC_64R 		0x00A8
+#define BCRM_ACQUISITION_FRAME_RATE_ENABLE_8RW 		0x00B0
+
+#define BCRM_FRAME_START_TRIGGER_MODE_8RW 		0x00B4
+#define BCRM_FRAME_START_TRIGGER_SOURCE_8RW 		0x00B8
+#define BCRM_FRAME_START_TRIGGER_ACTIVATION_8RW 	0x00BC
+#define BCRM_FRAME_START_TRIGGER_SOFTWARE_8W 		0x00C0
+#define BCRM_FRAME_START_TRIGGER_DELAY_32RW 		0x00C4
+#define BCRM_EXPOSURE_ACTIVE_LINE_MODE_8RW 		0x00C8
+#define BCRM_EXPOSURE_ACTIVE_LINE_SELECTOR_8RW 		0x00CC
+#define BCRM_LINE_CONFIGURATION_32RW 			0x00D0
+
+#define BCRM_IMG_WIDTH_32RW 				0x0100
+#define BCRM_IMG_WIDTH_MIN_32R 				0x0104
+#define BCRM_IMG_WIDTH_MAX_32R 				0x0108
+#define BCRM_IMG_WIDTH_INC_32R 				0x010C
+
+#define BCRM_IMG_HEIGHT_32RW 				0x0110
+#define BCRM_IMG_HEIGHT_MIN_32R 			0x0114
+#define BCRM_IMG_HEIGHT_MAX_32R 			0x0118
+#define BCRM_IMG_HEIGHT_INC_32R 			0x011C
+
+#define BCRM_IMG_OFFSET_X_32RW 				0x0120
+#define BCRM_IMG_OFFSET_X_MIN_32R 			0x0124
+#define BCRM_IMG_OFFSET_X_MAX_32R 			0x0128
+#define BCRM_IMG_OFFSET_X_INC_32R 			0x012C
+
+#define BCRM_IMG_OFFSET_Y_32RW 				0x0130
+#define BCRM_IMG_OFFSET_Y_MIN_32R 			0x0134
+#define BCRM_IMG_OFFSET_Y_MAX_32R 			0x0138
+#define BCRM_IMG_OFFSET_Y_INC_32R 			0x013C
+
+#define BCRM_IMG_MIPI_DATA_FORMAT_32RW 			0x0140
+#define BCRM_IMG_AVAILABLE_MIPI_DATA_FORMATS_64R 	0x0148
+#define BCRM_IMG_BAYER_PATTERN_INQUIRY_8R 		0x0150
+#define BCRM_IMG_BAYER_PATTERN_8RW 			0x0154
+#define BCRM_IMG_REVERSE_X_8RW 				0x0158
+#define BCRM_IMG_REVERSE_Y_8RW				0x015C
+
+#define BCRM_SENSOR_WIDTH_32R 				0x0160
+#define BCRM_SENSOR_HEIGHT_32R 				0x0164
+#define BCRM_WIDTH_MAX_32R 				0x0168
+#define BCRM_HEIGHT_MAX_32R 				0x016C
+
+#define BCRM_BINNING_INQ_16R 				0x0170
+#define BCRM_BINNING_SETTING_8RW 			0x0174
+#define BCRM_BINNING_MODE_8RW 				0x0178
+
+#define BCRM_EXPOSURE_TIME_64RW 			0x0180
+#define BCRM_EXPOSURE_TIME_MIN_64R 			0x0188
+#define BCRM_EXPOSURE_TIME_MAX_64R 			0x0190
+#define BCRM_EXPOSURE_TIME_INC_64R 			0x0198
+#define BCRM_EXPOSURE_AUTO_8RW 				0x01A0
+
+#define BCRM_INTENSITY_AUTO_PRECEDENCE_8RW 		0x01A4
+#define BCRM_INTENSITY_AUTO_PRECEDENCE_VALUE_32RW	0x01A8
+#define BCRM_INTENSITY_AUTO_PRECEDENCE_MIN_32R 		0x01AC
+#define BCRM_INTENSITY_AUTO_PRECEDENCE_MAX_32R 		0x01B0
+#define BCRM_INTENSITY_AUTO_PRECEDENCE_INC_32R 		0x01B4
+
+#define BCRM_BLACK_LEVEL_32RW 				0x01B8
+#define BCRM_BLACK_LEVEL_MIN_32R 			0x01BC
+#define BCRM_BLACK_LEVEL_MAX_32R 			0x01C0
+#define BCRM_BLACK_LEVEL_INC_32R 			0x01C4
+
+#define BCRM_GAIN_64RW 					0x01C8
+#define BCRM_GAIN_MIN_64R 				0x01D0
+#define BCRM_GAIN_MAX_64R 				0x01D8
+#define BCRM_GAIN_INC_64R 				0x01E0
+#define BCRM_GAIN_AUTO_8RW 				0x01E8
+
+#define BCRM_GAMMA_64RW 				0x01F0
+#define BCRM_GAMMA_MIN_64R 				0x01F8
+#define BCRM_GAMMA_MAX_64R 				0x0200
+#define BCRM_GAMMA_INC_64R 				0x0208
+
+#define BCRM_CONTRAST_VALUE_32RW 			0x0214
+#define BCRM_CONTRAST_VALUE_MIN_32R 			0x0218
+#define BCRM_CONTRAST_VALUE_MAX_32R 			0x021C
+#define BCRM_CONTRAST_VALUE_INC_32R 			0x0220
+
+#define BCRM_SATURATION_32RW 				0x0240
+#define BCRM_SATURATION_MIN_32R 			0x0244
+#define BCRM_SATURATION_MAX_32R 			0x0248
+#define BCRM_SATURATION_INC_32R 			0x024C
+
+#define BCRM_HUE_32RW 					0x0250
+#define BCRM_HUE_MIN_32R 				0x0254
+#define BCRM_HUE_MAX_32R 				0x0258
+#define BCRM_HUE_INC_32R 				0x025C
+
+#define BCRM_ALL_BALANCE_RATIO_64RW 			0x0260
+#define BCRM_ALL_BALANCE_RATIO_MIN_64R 			0x0268
+#define BCRM_ALL_BALANCE_RATIO_MAX_64R 			0x0270
+#define BCRM_ALL_BALANCE_RATIO_INC_64R 			0x0278
+
+#define BCRM_RED_BALANCE_RATIO_64RW 			0x0280
+#define BCRM_RED_BALANCE_RATIO_MIN_64R 			0x0288
+#define BCRM_RED_BALANCE_RATIO_MAX_64R 			0x0290
+#define BCRM_RED_BALANCE_RATIO_INC_64R 			0x0298
+
+#define BCRM_GREEN_BALANCE_RATIO_64RW 			0x02A0
+#define BCRM_GREEN_BALANCE_RATIO_MIN_64R 		0x02A8
+#define BCRM_GREEN_BALANCE_RATIO_MAX_64R 		0x02B0
+#define BCRM_GREEN_BALANCE_RATIO_INC_64R 		0x02B8
+
+#define BCRM_BLUE_BALANCE_RATIO_64RW 			0x02C0
+#define BCRM_BLUE_BALANCE_RATIO_MIN_64R 		0x02C8
+#define BCRM_BLUE_BALANCE_RATIO_MAX_64R 		0x02D0
+#define BCRM_BLUE_BALANCE_RATIO_INC_64R 		0x02D8
+
+#define BCRM_WHITE_BALANCE_AUTO_8RW 			0x02E0
+#define BCRM_SHARPNESS_32RW 				0x0300
+#define BCRM_SHARPNESS_MIN_32R 				0x0304
+#define BCRM_SHARPNESS_MAX_32R 				0x0308
+#define BCRM_SHARPNESS_INC_32R 				0x030C
+
+#define BCRM_DEVICE_TEMPERATURE_32R 			0x0310
+#define BCRM_EXPOSURE_AUTO_MIN_64RW 			0x0330
+#define BCRM_EXPOSURE_AUTO_MAX_64RW 			0x0338
+#define BCRM_GAIN_AUTO_MIN_64RW 			0x0340
+#define BCRM_GAIN_AUTO_MAX_64RW 			0x0348
+
+#define _BCRM_LAST_ADDR 				BCRM_GAIN_AUTO_MAX_64RW
+
+/************************************************/
+
+/* GenCP Registers */
+#define GENCP_CHANGEMODE_8W				0x021C
+#define GENCP_CURRENTMODE_8R				0x021D
+
+#define GENCP_OUT_HANDSHAKE_8RW				0x0018
+#define GENCP_IN_HANDSHAKE_8RW				0x001c
+#define GENCP_OUT_SIZE_16W				0x0020
+#define GENCP_IN_SIZE_16R				0x0024
+
+#define BCRM_HANDSHAKE_STATUS_MASK			0x01
+#define BCRM_HANDSHAKE_AVAILABLE_MASK			0x80
+
+#if !defined(V4L2_MBUS_CSI2_MAX_DATA_LANES) && defined(V4L2_FWNODE_CSI2_MAX_DATA_LANES)
+#define V4L2_MBUS_CSI2_MAX_DATA_LANES V4L2_FWNODE_CSI2_MAX_DATA_LANES
+#endif
+
+enum CCI_REG_INFO {
+	CCI_REGISTER_LAYOUT_VERSION = 0,
+	DEVICE_CAPABILITIES,
+	GCPRM_ADDRESS,
+	BCRM_ADDRESS,
+	DEVICE_GUID,
+	MANUFACTURER_NAME,
+	MODEL_NAME,
+	FAMILY_NAME,
+	DEVICE_VERSION,
+	MANUFACTURER_INFO,
+	SERIAL_NUMBER,
+	USER_DEFINED_NAME,
+	CHECKSUM,
+	CHANGE_MODE,
+	CURRENT_MODE,
+	SOFT_RESET,
+	HEARTBEAT,
+	CAM_I2C_ADDRESS,
+};
+
+struct cci_cmd {
+	__u8 command_index; /* diagnostc test name */
+	const __u32 address; /* NULL for no alias name */
+	__u32 byte_count;
+};
+
+static struct cci_cmd cci_cmd_tbl[] = {
+	[CCI_REGISTER_LAYOUT_VERSION] = { CCI_REGISTER_LAYOUT_VERSION, 0x0000,  4 },
+	[DEVICE_CAPABILITIES]         = { DEVICE_CAPABILITIES,         0x0008,  8 },
+	[GCPRM_ADDRESS]               = { GCPRM_ADDRESS,               0x0010,  2 },
+	[BCRM_ADDRESS]                = { BCRM_ADDRESS,                0x0014,  2 },
+	[DEVICE_GUID]                 = { DEVICE_GUID,                 0x0018, 64 },
+	[MANUFACTURER_NAME]           = { MANUFACTURER_NAME,           0x0058, 64 },
+	[MODEL_NAME]                  = { MODEL_NAME,                  0x0098, 64 },
+	[FAMILY_NAME]                 = { FAMILY_NAME,                 0x00D8, 64 },
+	[DEVICE_VERSION]              = { DEVICE_VERSION,              0x0118, 64 },
+	[MANUFACTURER_INFO]           = { MANUFACTURER_INFO,           0x0158, 64 },
+	[SERIAL_NUMBER]               = { SERIAL_NUMBER,               0x0198, 64 },
+	[USER_DEFINED_NAME]           = { USER_DEFINED_NAME,           0x01D8, 64 },
+	[CHECKSUM]                    = { CHECKSUM,                    0x0218,  4 },
+	[CHANGE_MODE]                 = { CHANGE_MODE,                 0x021C,  1 },
+	[CURRENT_MODE]                = { CURRENT_MODE,                0x021D,  1 },
+	[SOFT_RESET]                  = { SOFT_RESET,                  0x021E,  1 },
+	[HEARTBEAT]                   = { HEARTBEAT,                   0x021F,  1 },
+	[CAM_I2C_ADDRESS]             = { CAM_I2C_ADDRESS,             0x0220,  1 },
+};
+
+enum CCI_CAPS_STRING_ENCODING {
+	CCI_CAPS_SE_ASCII = 0,
+	CCI_CAPS_SE_UTF8,
+	CCI_CAPS_SE_UTF16,
+	CCI_CAPS_SE_MAX
+};
+
+union cci_device_caps_reg {
+	struct {
+		__u64 user_name:1;
+		__u64 bcrm:1;
+		__u64 gencp:1;
+		__u64 reserved:1;
+		__u64 string_encoding:4;
+		__u64 family_name:1;
+		__u64 reserved2:55;
+	} caps;
+	__u64 value;
+};
+
+/*struct*/ union __attribute__((__packed__)) cci_reg {
+	struct __attribute__((__packed__)) {
+	__u32   layout_version;				// +   0x000	r
+	__u32   reserved_4bytes;			// +   0x004	r
+	union cci_device_caps_reg device_capabilities; 	// +   0x008	r
+	__u16   gcprm_address;				// +   0x010	r
+	__u16   reserved_2bytes;			// +   0x012	r
+	__u16   bcrm_addr;				// +   0x014	r
+	__u16   reserved_2bytes2;			// +   0x016	r
+	char    device_guid[64];			// +   0x018	r
+	char    manufacturer_name[64];			// +   0x058	r
+	char    model_name[64];				// +   0x098	r
+	char    family_name[64];			// +   0x0d8	r
+	char    device_version[64];			// +   0x118	r
+	char    manufacturer_info[64];			// +   0x158	r
+	char    serial_number[64];			// +   0x198	r
+	char    user_defined_name[64];			// +   0x1d8	r
+	__u32   checksum;				// +   0x218	r
+	__u8    change_mode;				// +   0x21c	w
+	__u8    current_mode;				// +   0x21d	r
+	__u8    soft_reset;				// +   0x21e	rw
+	__u8    heartbeat;				// +   0x21f	rw
+	__u8    cam_i2c_address;			// +   0x220	rw
+	} reg;
+	__u8    buf[0x220];			
+};
+
+struct __attribute__((__packed__)) gencp_reg {
+	__u32   gcprm_layout_version;
+	__u16   gencp_out_buffer_address;
+	__u16   reserved_2byte;
+	__u16   gencp_out_buffer_size;
+	__u16   reserved_2byte_1;
+	__u16	gencp_in_buffer_address;
+	__u16   reserved_2byte_2;
+	__u16   gencp_in_buffer_size;
+	__u16   reserved_2byte_3;
+	__u32   checksum;
+};
+
+
+union bcrm_feature_inquiry_reg {
+	struct {
+		unsigned long long reverse_x_avail:1;
+		unsigned long long reverse_y_avail:1;
+		unsigned long long intensity_auto_precedence_avail:1;
+		unsigned long long black_level_avail:1;
+		unsigned long long gain_avail:1;
+		unsigned long long gamma_avail:1;
+		unsigned long long contrast_avail:1;
+		unsigned long long saturation_avail:1;
+		unsigned long long hue_avail:1;
+		unsigned long long white_balance_avail:1;
+		unsigned long long sharpness_avail:1;
+		unsigned long long exposure_auto_avail:1;
+		unsigned long long gain_auto_avail:1;
+		unsigned long long white_balance_auto_avail:1;
+		unsigned long long device_temperature_avail:1;
+		unsigned long long acquisition_abort:1;
+		unsigned long long acquisition_frame_rate:1;
+		unsigned long long frame_trigger:1;
+		unsigned long long exposure_active_line_available:1;
+		unsigned long long reserved:45;
+	} feature_inq;
+
+	unsigned long long value;
+};
+
+union device_firmware_version_reg {
+	struct {
+		unsigned long long special_version:8;
+		unsigned long long major_version:8;
+		unsigned long long minor_version:16;
+		unsigned long long patch_version:32;
+	} device_firmware;
+
+	unsigned long long value;
+};
+
+union bcrm_avail_mipi_reg {
+	struct {
+		unsigned long long yuv420_8_leg_avail:1;
+		unsigned long long yuv420_8_avail:1;
+		unsigned long long yuv420_10_avail:1;
+		unsigned long long yuv420_8_csps_avail:1;
+		unsigned long long yuv420_10_csps_avail:1;
+		unsigned long long yuv422_8_avail:1;
+		unsigned long long yuv422_10_avail:1;
+		unsigned long long rgb888_avail:1;
+		unsigned long long rgb666_avail:1;
+		unsigned long long rgb565_avail:1;
+		unsigned long long rgb555_avail:1;
+		unsigned long long rgb444_avail:1;
+		unsigned long long raw6_avail:1;
+		unsigned long long raw7_avail:1;
+		unsigned long long raw8_avail:1;
+		unsigned long long raw10_avail:1;
+		unsigned long long raw12_avail:1;
+		unsigned long long raw14_avail:1;
+		unsigned long long jpeg_avail:1;
+		unsigned long long reserved:45;
+	} avail_mipi;
+
+	unsigned long long value;
+};
+
+union bcrm_bayer_inquiry_reg {
+	struct {
+		unsigned char monochrome_avail:1;
+		unsigned char bayer_GR_avail:1;
+		unsigned char bayer_RG_avail:1;
+		unsigned char bayer_GB_avail:1;
+		unsigned char bayer_BG_avail:1;
+		unsigned char reserved:3;
+	} bayer_pattern;
+
+	unsigned char value;
+};
+
+union bcrm_supported_lanecount_reg {
+	struct {
+		unsigned char one_lane_avail:1;
+		unsigned char two_lane_avail:1;
+		unsigned char three_lane_avail:1;
+		unsigned char four_lane_avail:1;
+		unsigned char reserved:4;
+	} lane_mask;
+
+	unsigned char value;
+};
+
+/**
+ * struct avt_csi_information - sensor specific csi2 bus configuration.
+ * TODO: The cid to query this structure is V4L2_CID_AVT_CSI_INFORMATION.
+ *
+ * @max_lanefrequency  Max available CSI frequency per lane in Hertz.
+ * @lanecount          Available CSI lane count.
+ * @laneassignment     describes the physical CSI-2 connection between host and camera module.
+ *                     The index starts with 0 as CSI lane 1 of the host.
+ *                     The value starts with 1 as the CSI lane 1 of the sensor.
+ */
+struct avt_csi_information {
+	__u32 csi_clk_freq; //max_lane_frequency;
+	__u8 lane_count;
+	__u8 lane_assignment[V4L2_MBUS_CSI2_MAX_DATA_LANES];
+	__u8 clk_lane;
+};
+
+#define AV_CAM_REG_SIZE		2
+#define AV_CAM_DATA_SIZE_8	1
+#define AV_CAM_DATA_SIZE_16	2
+#define AV_CAM_DATA_SIZE_32	4
+#define AV_CAM_DATA_SIZE_64	8
+#define ALVIUM_MAX_REG_ADDR	0x0fff
+
+//enum AV_BCRM_FRAME_TRIGGER_SOURCE {
+//	BCRM_TS_CAM_LINE_0 = 0,
+//	BCRM_TS_CAM_LINE_1 = 1,
+//	BCRM_TS_CAM_LINE_2 = 2,
+//	BCRM_TS_CAM_LINE_3 = 3,
+//	BCRM_TS_CAM_SOFTWARE = 4
+//};
+
+#endif
diff --git a/include/media/avt-csi2-version.h b/include/media/avt-csi2-version.h
new file mode 100644
index 0000000..92bc52e
--- /dev/null
+++ b/include/media/avt-csi2-version.h
@@ -0,0 +1 @@
+#define DRIVER_VERSION "1.2.0"
\ No newline at end of file
diff --git a/include/media/avt-csi2.h b/include/media/avt-csi2.h
new file mode 100644
index 0000000..126057a
--- /dev/null
+++ b/include/media/avt-csi2.h
@@ -0,0 +1,729 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/* 
+ * Allied Vision Alvium camera driver
+ * 
+ * Copyright (C) 2022 - 2024 Allied Vision Technologies GmbH
+ */
+
+#ifndef __AVT_CSI2_H__
+#define __AVT_CSI2_H__
+
+#include <linux/avt-csi2.h>
+
+#include "avt-csi2-version.h"
+#include "avt-csi2-regs.h"
+
+#ifdef NVIDIA
+#include <media/camera_common.h>
+#endif //#ifdef NVIDIA
+
+#define USEMUTEX
+
+
+/* Driver release version */
+#define STR_HELPER(x) #x
+#define STR(x) STR_HELPER(x)
+
+
+#define BCRM_DEVICE_VERSION	0x00010000
+#define BCRM_MAJOR_VERSION	0x0001
+#define BCRM_MINOR_VERSION	0x0000
+
+#define GCPRM_DEVICE_VERSION	0x00010000
+#define GCPRM_MAJOR_VERSION	0x0001
+#define GCPRM_MINOR_VERSION	0x0000
+
+
+struct avt_frame_param {
+	/* crop settings */
+	struct v4l2_rect r;
+
+	/* min/max/step values for frame size */
+	uint32_t minh;
+	uint32_t maxh;
+	uint32_t sh;
+	uint32_t minw;
+	uint32_t maxw;
+	uint32_t sw;
+	uint32_t minhoff;
+	uint32_t maxhoff;
+	uint32_t shoff;
+	uint32_t minwoff;
+	uint32_t maxwoff;
+	uint32_t swoff;
+};
+
+enum avt_mode {
+	AVT_BCRM_MODE,
+	AVT_GENCP_MODE,
+};
+
+#define AVT_CTRL_FLAG_STREAM_DISABLED 		(1 << 1)
+#define AVT_CTRL_FLAG_READ_BACK 		(1 << 2)
+
+struct avt_ctrl_mapping {
+	u8 reg_length;
+	u16 min_offset;
+	u16 max_offset;
+	u16 reg_offset;
+	u16 step_offset;
+	u32 id;
+	u32 type;
+	u32 flags;
+	struct {
+		s8	*name;
+		s8	feature_avail;
+	} attr;
+	s64 min_value;
+	s64 max_value;
+	s64 step_value;
+	s64 default_value;
+	const char * const * qmenu;
+	u32 avt_flags;
+};
+
+#define AV_ATTR_REVERSE_X		{"Reverse X",			0}
+#define AV_ATTR_REVERSE_Y		{"Reverse Y",			1}
+#define AV_ATTR_INTENSITY_AUTO		{"Intensity Auto",		2}
+#define AV_ATTR_BRIGHTNESS		{"Brightness",			3}
+
+#define AV_ATTR_GAIN			{"Gain",			4}
+#define AV_ATTR_GAMMA			{"Gamma",			5}
+#define AV_ATTR_CONTRAST		{"Contrast",			6}
+#define AV_ATTR_SATURATION		{"Saturation",			7}
+#define AV_ATTR_HUE			{"Hue",				8}
+#define AV_ATTR_WHITEBALANCE		{"White Balance",		9}
+#define AV_ATTR_RED_BALANCE		{"Red Balance",			9}
+#define AV_ATTR_BLUE_BALANCE		{"Blue Balance",		9}
+#define AV_ATTR_SHARPNESS		{"Sharpness",			10}
+#define AV_ATTR_EXPOSURE_AUTO		{"Exposure Auto",		11}
+#define AV_ATTR_EXPOSURE_AUTO_MIN	{"Exposure Auto Min",		11}
+#define AV_ATTR_EXPOSURE_AUTO_MAX	{"Exposure Auto Max",		11}
+#define AV_ATTR_AUTOGAIN		{"Auto Gain",			12}
+#define AV_ATTR_GAIN_AUTO_MIN		{"Gain Auto Min",		12}
+#define AV_ATTR_GAIN_AUTO_MAX		{"Gain Auto Max",		12}
+#define AV_ATTR_WHITEBALANCE_AUTO	{"Auto White Balance",		13}
+#define AV_ATTR_LINK_FREQ		{"MIPI CSI-2 Link Frequency",	15}
+
+
+#define AV_ATTR_TRIGGER_MODE		{"Trigger Mode",		17}
+#define AV_ATTR_TRIGGER_ACTIVATION	{"Trigger Activation",		17}
+#define AV_ATTR_TRIGGER_SOURCE		{"Trigger Source",		17}
+#define AV_ATTR_TRIGGER_SOFTWARE	{"Trigger Software",    	17}
+
+#define AV_ATTR_EXPOSURE		{"Exposure",			-1}
+#define AV_ATTR_EXPOSURE_ABS		{"Exposure Absolute",		-1}
+
+#define AV_ATTR_BINNING_MODE		{"Binning Mode",		-1}
+#define AV_ATTR_BINNING_SETTING		{"Binning Setting",		-1}
+
+#define AV_ATTR_FIRMWARE_VERSION	{"Firmware Version",		-1}
+#define AV_ATTR_CAMERA_NAME		{"Camera name",			-1}
+#define AV_ATTR_SERIAL_NUMBER		{"Serial Number",		-1}
+
+
+
+static const char * const v4l2_triggeractivation_menu[] = {
+	"Rising Edge",
+	"Falling Edge",
+	"Any Edge",
+	"Level High",
+	"Level Low"
+};
+static const char * const v4l2_triggersource_menu[] = {
+	"Line 0",
+	"Line 1",
+	"Line 2",
+	"Line 3",
+	"Software"
+};
+
+static const char *  const v4l2_binning_mode_menu[] = {
+	"Average",
+	"Sum"
+};
+
+static const char *  const v4l2_binning_selector_menu[] = {
+	"Digital",
+	"Sensor"
+};
+
+static const char * const avt_intensity_auto_precendence_menu[] = {
+	[AVT_INTENSITY_AUTO_PRECEDENCE_MINIMIZE_NOISE] = "Minimize Noise",
+	[AVT_INTENSITY_AUTO_PRECEDENCE_MINIMIZE_BLUR] = "Minimize Blur",
+	[AVT_INTENSITY_AUTO_PRECEDENCE_MAXIMIZE_DOF] = "Maximize Depth of Field"
+};
+
+
+
+const struct avt_ctrl_mapping avt_ctrl_mappings[] = {
+	{
+		.id		= V4L2_CID_EXPOSURE,
+		.attr		= AV_ATTR_EXPOSURE,
+		.min_offset	= BCRM_EXPOSURE_TIME_MIN_64R,
+		.max_offset	= BCRM_EXPOSURE_TIME_MAX_64R,
+		.reg_offset	= BCRM_EXPOSURE_TIME_64RW,
+		.step_value	= 1,
+		.reg_length	= AV_CAM_DATA_SIZE_64,
+		.type		= V4L2_CTRL_TYPE_INTEGER64,
+		.flags		= V4L2_CTRL_FLAG_VOLATILE
+			 	| V4L2_CTRL_FLAG_EXECUTE_ON_WRITE,
+	},
+	{
+		.id		= V4L2_CID_EXPOSURE_ABSOLUTE,
+		.attr		= AV_ATTR_EXPOSURE_ABS,
+		.min_offset	= BCRM_EXPOSURE_TIME_MIN_64R,
+		.max_offset	= BCRM_EXPOSURE_TIME_MAX_64R,
+		.reg_offset	= BCRM_EXPOSURE_TIME_64RW,
+		.step_value	= 1,
+		.reg_length	= AV_CAM_DATA_SIZE_64,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.flags		= V4L2_CTRL_FLAG_VOLATILE
+			 	| V4L2_CTRL_FLAG_EXECUTE_ON_WRITE,
+	},
+	{
+		.id		= V4L2_CID_GAIN,
+		.attr		= AV_ATTR_GAIN,
+		.min_offset	= BCRM_GAIN_MIN_64R,
+		.max_offset	= BCRM_GAIN_MAX_64R,
+		.reg_offset	= BCRM_GAIN_64RW,
+		.step_offset	= BCRM_GAIN_INC_64R,
+		.reg_length	= AV_CAM_DATA_SIZE_64,
+		.type		= V4L2_CTRL_TYPE_INTEGER64,
+		.flags		= V4L2_CTRL_FLAG_VOLATILE
+			 	| V4L2_CTRL_FLAG_EXECUTE_ON_WRITE,
+	},
+
+	{
+		.id		= V4L2_CID_HFLIP,
+		.attr		= AV_ATTR_REVERSE_X,
+		.reg_offset	= BCRM_IMG_REVERSE_X_8RW,
+		.reg_length	= AV_CAM_DATA_SIZE_8,
+		.type		= V4L2_CTRL_TYPE_BOOLEAN,
+		.flags		= 0,
+		.avt_flags	= AVT_CTRL_FLAG_STREAM_DISABLED,
+	},
+	{
+		.id		= V4L2_CID_VFLIP,
+		.attr		= AV_ATTR_REVERSE_Y,
+		.reg_offset	= BCRM_IMG_REVERSE_Y_8RW,
+		.reg_length	= AV_CAM_DATA_SIZE_8,
+		.type		= V4L2_CTRL_TYPE_BOOLEAN,
+		.flags		= 0,
+		.avt_flags	= AVT_CTRL_FLAG_STREAM_DISABLED,
+	},
+	{
+		.id		= V4L2_CID_BRIGHTNESS,
+		.attr		= AV_ATTR_BRIGHTNESS,
+		.min_offset	= BCRM_BLACK_LEVEL_MIN_32R,
+		.max_offset	= BCRM_BLACK_LEVEL_MAX_32R,
+		.reg_offset	= BCRM_BLACK_LEVEL_32RW,
+		.step_offset	= BCRM_BLACK_LEVEL_INC_32R,
+		.reg_length	= AV_CAM_DATA_SIZE_32,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.flags		= 0,
+		.avt_flags	= AVT_CTRL_FLAG_STREAM_DISABLED,
+	},
+	{
+		.id		= V4L2_CID_CONTRAST,
+		.attr		= AV_ATTR_CONTRAST,
+		.min_offset	= BCRM_CONTRAST_VALUE_MIN_32R,
+		.max_offset	= BCRM_CONTRAST_VALUE_MAX_32R,
+		.reg_offset	= BCRM_CONTRAST_VALUE_32RW,
+		.step_offset	= BCRM_CONTRAST_VALUE_INC_32R,
+		.reg_length	= AV_CAM_DATA_SIZE_32,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.flags		= 0,
+	},
+	{
+		.id		= V4L2_CID_SATURATION,
+		.attr		= AV_ATTR_SATURATION,
+		.min_offset	= BCRM_SATURATION_MIN_32R,
+		.max_offset	= BCRM_SATURATION_MAX_32R,
+		.reg_offset	= BCRM_SATURATION_32RW,
+		.step_offset	= BCRM_SATURATION_INC_32R,
+		.reg_length	= AV_CAM_DATA_SIZE_32,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.flags		= 0,
+	},
+	{
+		.id		= V4L2_CID_HUE,
+		.attr		= AV_ATTR_HUE,
+		.min_offset	= BCRM_HUE_MIN_32R,
+		.max_offset	= BCRM_HUE_MAX_32R,
+		.reg_offset	= BCRM_HUE_32RW,
+		.step_offset	= BCRM_HUE_INC_32R,
+		.reg_length	= AV_CAM_DATA_SIZE_32,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.flags		= 0,
+	},
+	{
+		.id		= V4L2_CID_AUTO_WHITE_BALANCE,
+		.attr		= AV_ATTR_WHITEBALANCE_AUTO,
+		.reg_offset	= BCRM_WHITE_BALANCE_AUTO_8RW,
+		.reg_length	= AV_CAM_DATA_SIZE_8,
+		.type		= V4L2_CTRL_TYPE_BOOLEAN,
+		.flags		= 0,
+	},
+	{
+		.id		= V4L2_CID_DO_WHITE_BALANCE,
+		.attr		= AV_ATTR_WHITEBALANCE,
+		.reg_offset	= BCRM_WHITE_BALANCE_AUTO_8RW,
+		.reg_length	= AV_CAM_DATA_SIZE_8,
+		.type		= V4L2_CTRL_TYPE_BUTTON,
+		.flags		= 0,
+	},
+	{
+		.id		= V4L2_CID_RED_BALANCE,
+		.attr		= AV_ATTR_RED_BALANCE,
+		.min_offset	= BCRM_RED_BALANCE_RATIO_MIN_64R,
+		.max_offset	= BCRM_RED_BALANCE_RATIO_MAX_64R,
+		.reg_offset	= BCRM_RED_BALANCE_RATIO_64RW,
+		.step_offset	= BCRM_RED_BALANCE_RATIO_INC_64R,
+		.reg_length	= AV_CAM_DATA_SIZE_64,
+		.type		= V4L2_CTRL_TYPE_INTEGER64,
+		.flags		= V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE,
+	},
+	{
+		.id		= V4L2_CID_BLUE_BALANCE,
+		.attr		= AV_ATTR_BLUE_BALANCE,
+		.min_offset	= BCRM_BLUE_BALANCE_RATIO_MIN_64R,
+		.max_offset	= BCRM_BLUE_BALANCE_RATIO_MAX_64R,
+		.reg_offset	= BCRM_BLUE_BALANCE_RATIO_64RW,
+		.step_offset	= BCRM_BLUE_BALANCE_RATIO_INC_64R,
+		.reg_length	= AV_CAM_DATA_SIZE_64,
+		.type		= V4L2_CTRL_TYPE_INTEGER64,
+		.flags		= V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE,
+	},
+	{
+		.id		= V4L2_CID_GAMMA,
+		.attr		= AV_ATTR_GAMMA,
+		.min_offset	= BCRM_GAMMA_MIN_64R,
+		.max_offset	= BCRM_GAMMA_MAX_64R,
+		.reg_offset	= BCRM_GAMMA_64RW,
+		.step_offset	= BCRM_GAMMA_INC_64R,
+		.reg_length	= AV_CAM_DATA_SIZE_64,
+		.type		= V4L2_CTRL_TYPE_INTEGER64,
+		.flags		= 0,
+	},
+	{
+		.id		= V4L2_CID_AUTOGAIN,
+		.attr		= AV_ATTR_AUTOGAIN,
+		.reg_offset	= BCRM_GAIN_AUTO_8RW,
+		.reg_length	= AV_CAM_DATA_SIZE_8,
+		.type		= V4L2_CTRL_TYPE_BOOLEAN,
+		.flags		= 0,
+	},
+	{
+		.id		= V4L2_CID_SHARPNESS,
+		.attr		= AV_ATTR_SHARPNESS,
+		.min_offset	= BCRM_SHARPNESS_MIN_32R,
+		.max_offset	= BCRM_SHARPNESS_MAX_32R,
+		.reg_offset	= BCRM_SHARPNESS_32RW,
+		.step_offset	= BCRM_SHARPNESS_INC_32R,
+		.reg_length	= AV_CAM_DATA_SIZE_32,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.flags		= 0,
+	},
+	{
+		.id 		= V4L2_CID_EXPOSURE_AUTO,
+		.attr 		= AV_ATTR_EXPOSURE_AUTO,
+		.reg_offset 	= BCRM_EXPOSURE_AUTO_8RW,
+		.reg_length 	= AV_CAM_DATA_SIZE_8,
+		.type 		= V4L2_CTRL_TYPE_MENU,
+		.min_value	= 0,
+		.max_value	= 1,
+		.default_value	= 1,
+		.flags 		= 0,
+	},
+	{
+		.id 		= AVT_CID_TRIGGER_MODE,
+		.attr 		= AV_ATTR_TRIGGER_MODE,
+		.reg_offset 	= BCRM_FRAME_START_TRIGGER_MODE_8RW,
+		.reg_length 	= AV_CAM_DATA_SIZE_8,
+		.type 		= V4L2_CTRL_TYPE_BOOLEAN,
+		.flags 		= 0,
+		.avt_flags 	= AVT_CTRL_FLAG_STREAM_DISABLED,
+	},
+	{
+		.id 		= AVT_CID_TRIGGER_ACTIVATION,
+		.attr 		= AV_ATTR_TRIGGER_ACTIVATION,
+		.reg_offset 	= BCRM_FRAME_START_TRIGGER_ACTIVATION_8RW,
+		.reg_length 	= AV_CAM_DATA_SIZE_8,
+		.type 		= V4L2_CTRL_TYPE_MENU,
+		.flags 		= 0,
+		.min_value 	= 0,
+		.max_value 	= 4,
+		.qmenu 		= v4l2_triggeractivation_menu,
+		.avt_flags 	= AVT_CTRL_FLAG_STREAM_DISABLED,
+	},
+	{
+		.id 		= AVT_CID_TRIGGER_SOURCE,
+		.attr 		= AV_ATTR_TRIGGER_SOURCE,
+		.reg_offset 	= BCRM_FRAME_START_TRIGGER_SOURCE_8RW,
+		.reg_length 	= AV_CAM_DATA_SIZE_8,
+		.type 		= V4L2_CTRL_TYPE_MENU,
+		.flags 		= 0,
+		.min_value 	= 0,
+		.max_value 	= 4,
+		.qmenu 		= v4l2_triggersource_menu,
+		.avt_flags 	= AVT_CTRL_FLAG_STREAM_DISABLED,
+	},
+	{
+		.id 		= AVT_CID_TRIGGER_SOFTWARE,
+		.attr 		= AV_ATTR_TRIGGER_SOFTWARE,
+		.reg_offset 	= BCRM_FRAME_START_TRIGGER_SOFTWARE_8W,
+		.reg_length 	= AV_CAM_DATA_SIZE_8,
+		.type 		= V4L2_CTRL_TYPE_BUTTON,
+		.flags 		= V4L2_CTRL_FLAG_INACTIVE,
+	},
+	{
+		.id 		= AVT_CID_BINNING_MODE,
+		.attr		= AV_ATTR_BINNING_MODE,
+		.reg_offset	= BCRM_BINNING_MODE_8RW,
+		.reg_length	= AV_CAM_DATA_SIZE_8,
+		.type		= V4L2_CTRL_TYPE_MENU,
+		.flags		= 0,
+		.min_value 	= 0,
+		.max_value 	= 1,
+		.qmenu		= v4l2_binning_mode_menu,
+		.avt_flags	= AVT_CTRL_FLAG_STREAM_DISABLED,
+	},
+	{
+		.id 		= AVT_CID_BINNING_SETTING,
+		.attr		= AV_ATTR_BINNING_SETTING,
+		.type		= V4L2_CTRL_TYPE_AREA,
+		.flags		= V4L2_CTRL_FLAG_VOLATILE,
+	},
+	{
+		.id 		= AVT_CID_FIRMWARE_VERSION,
+		.attr		= AV_ATTR_FIRMWARE_VERSION,
+		.type		= V4L2_CTRL_TYPE_STRING,
+		.flags		= V4L2_CTRL_FLAG_READ_ONLY,
+		.min_value	= 0,
+		.max_value	= 20,
+		.step_value	= 1,
+	},
+	{
+		.id 		= AVT_CID_CAMERA_NAME,
+		.attr		= AV_ATTR_CAMERA_NAME,
+		.type		= V4L2_CTRL_TYPE_STRING,
+		.flags		= V4L2_CTRL_FLAG_READ_ONLY,
+		.min_value	= 0,
+		.max_value	= 128,
+		.step_value	= 1,
+	},
+	{
+		.id 		= AVT_CID_SERIAL_NUMBER,
+		.attr		= AV_ATTR_SERIAL_NUMBER,
+		.type		= V4L2_CTRL_TYPE_STRING,
+		.flags		= V4L2_CTRL_FLAG_READ_ONLY,
+		.min_value	= 0,
+		.max_value	= 64,
+		.step_value	= 1,
+	},
+	{
+		.id 		= AVT_CID_ACQUISITION_STATUS,
+		.attr		= {"Acquisition status", -1},
+		.reg_length	= AV_CAM_DATA_SIZE_8,
+		.reg_offset 	= BCRM_ACQUISITION_STATUS_8R,
+		.type		= V4L2_CTRL_TYPE_BOOLEAN,
+		.flags		= V4L2_CTRL_FLAG_VOLATILE
+				| V4L2_CTRL_FLAG_READ_ONLY,
+	},
+	{
+		.id		= AVT_CID_EXPOSURE_AUTO_MIN,
+		.attr		= AV_ATTR_EXPOSURE_AUTO_MIN,
+		.min_offset	= BCRM_EXPOSURE_TIME_MIN_64R,
+		.max_offset	= BCRM_EXPOSURE_AUTO_MAX_64RW,
+		.reg_offset	= BCRM_EXPOSURE_AUTO_MIN_64RW,
+		.step_value	= 1,
+		.reg_length	= AV_CAM_DATA_SIZE_64,
+		.type		= V4L2_CTRL_TYPE_INTEGER64,
+		.flags		= 0,
+		.avt_flags 	= AVT_CTRL_FLAG_READ_BACK,
+	},
+	{
+		.id		= AVT_CID_EXPOSURE_AUTO_MAX,
+		.attr		= AV_ATTR_EXPOSURE_AUTO_MAX,
+		.min_offset	= BCRM_EXPOSURE_AUTO_MIN_64RW,
+		.max_offset	= BCRM_EXPOSURE_TIME_MAX_64R,
+		.reg_offset	= BCRM_EXPOSURE_AUTO_MAX_64RW,
+		.step_value	= 1,
+		.reg_length	= AV_CAM_DATA_SIZE_64,
+		.type		= V4L2_CTRL_TYPE_INTEGER64,
+		.flags		= 0,
+		.avt_flags 	= AVT_CTRL_FLAG_READ_BACK,
+	},
+	{
+		.id		= AVT_CID_GAIN_AUTO_MIN,
+		.attr		= AV_ATTR_GAIN_AUTO_MIN,
+		.min_offset	= BCRM_GAIN_MIN_64R,
+		.max_offset	= BCRM_GAIN_AUTO_MAX_64RW,
+		.reg_offset	= BCRM_GAIN_AUTO_MIN_64RW,
+		.step_value	= 1,
+		.reg_length	= AV_CAM_DATA_SIZE_64,
+		.type		= V4L2_CTRL_TYPE_INTEGER64,
+		.flags		= 0,
+		.avt_flags 	= AVT_CTRL_FLAG_READ_BACK,
+	},
+	{
+		.id		= AVT_CID_GAIN_AUTO_MAX,
+		.attr		= AV_ATTR_GAIN_AUTO_MAX,
+		.min_offset	= BCRM_GAIN_AUTO_MIN_64RW,
+		.max_offset	= BCRM_GAIN_MAX_64R,
+		.reg_offset	= BCRM_GAIN_AUTO_MAX_64RW,
+		.step_value	= 1,
+		.reg_length	= AV_CAM_DATA_SIZE_64,
+		.type		= V4L2_CTRL_TYPE_INTEGER64,
+		.flags		= 0,
+		.avt_flags 	= AVT_CTRL_FLAG_READ_BACK,
+	},
+	{
+		.id		= AVT_CID_DEVICE_TEMPERATURE,
+		.attr		= { "Device Temperature", 14 },
+		.reg_offset	= BCRM_DEVICE_TEMPERATURE_32R,
+		.reg_length	= AV_CAM_DATA_SIZE_32,
+		.min_value	= -1000,
+		.max_value	= 2000,
+		.step_value	= 1,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.flags		= V4L2_CTRL_FLAG_VOLATILE
+			 	| V4L2_CTRL_FLAG_READ_ONLY,
+	},
+	{
+		.id		= AVT_CID_EXPOSURE_ACTIVE_LINE_MODE,
+		.attr		= { "Exposure Active Line Mode", 18 },
+		.reg_offset	= BCRM_EXPOSURE_ACTIVE_LINE_MODE_8RW,
+		.reg_length	= AV_CAM_DATA_SIZE_8,
+		.type		= V4L2_CTRL_TYPE_BOOLEAN,
+	},
+	{
+		.id		= AVT_CID_EXPOSURE_ACTIVE_LINE_SELECTOR,
+		.attr		= { "Exposure Active Line Selector",18 },
+		.reg_offset	= BCRM_EXPOSURE_ACTIVE_LINE_SELECTOR_8RW,
+		.reg_length	= AV_CAM_DATA_SIZE_8,
+		.min_value	= 0,
+		.max_value	= 1,
+		.step_value	= 1,
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+	},
+	{
+		.id		= AVT_CID_EXPOSURE_ACTIVE_INVERT,
+		.attr		= { "Exposure Active Invert",18 },
+		.type		= V4L2_CTRL_TYPE_BOOLEAN,
+	},
+	{
+		.id		= AVT_CID_BINNING_SELECTOR,
+		.attr		= { "Binning Selector", -1 },
+		.type		= V4L2_CTRL_TYPE_MENU,
+		.qmenu		= v4l2_binning_selector_menu,
+		.flags		= 0,
+		.min_value 	= 0,
+		.max_value 	= 1,
+		.avt_flags	= AVT_CTRL_FLAG_STREAM_DISABLED,
+	},
+	{
+		.id 		= AVT_CID_INTENSITY_AUTO_PRECEDENCE,
+		.attr		= { "Intensity Auto Precedence", 2 },
+		.type		= V4L2_CTRL_TYPE_MENU,
+		.qmenu		= avt_intensity_auto_precendence_menu,
+		.flags		= 0,
+		.min_value 	= 0,
+		.max_value	= ARRAY_SIZE(avt_intensity_auto_precendence_menu) - 1,
+		.reg_offset	= BCRM_INTENSITY_AUTO_PRECEDENCE_8RW,
+		.reg_length	= AV_CAM_DATA_SIZE_8
+			
+	},
+	{
+		.id		= AVT_CID_INTENSITY_AUTO_PRECEDENCE_TARGET,
+		.attr		= { "Intensity Auto Precedence Target", 2 },
+		.type		= V4L2_CTRL_TYPE_INTEGER,
+		.flags		= 0,
+		.min_offset	= BCRM_INTENSITY_AUTO_PRECEDENCE_MIN_32R,
+		.max_offset	= BCRM_INTENSITY_AUTO_PRECEDENCE_MAX_32R,
+		.step_offset	= BCRM_INTENSITY_AUTO_PRECEDENCE_INC_32R,
+		.reg_offset	= BCRM_INTENSITY_AUTO_PRECEDENCE_VALUE_32RW,
+		.reg_length	= AV_CAM_DATA_SIZE_32,
+	}
+};
+
+
+
+#define AVT_MAX_CTRLS (ARRAY_SIZE(avt_ctrl_mappings))
+
+enum avt_exposure_mode {
+	EMODE_MANUAL = 0,
+	EMODE_AUTO = 2,
+};
+
+#define AVT_BINNING_TYPE_CNT 	2
+
+struct avt_binning_info {
+    	u32 sel;
+	u32 hfact;
+	u32 vfact;
+	u32 max_width;
+	u32 max_height;
+	u32 type;
+};
+
+struct avt_dev
+{
+	struct i2c_client *i2c_client;
+#ifdef NVIDIA
+	struct camera_common_data s_data;
+#else
+	struct v4l2_subdev subdev;
+#endif
+
+	struct mutex lock;
+
+	struct regmap *regmap;
+	
+	struct media_pad pad;
+	union device_firmware_version_reg cam_firmware_version;
+	uint32_t bcrm_handshake_timeout_ms;
+	bool bcrm_write_handshake;
+
+	struct v4l2_mbus_framefmt fmt;
+	bool pending_mode_change;
+	int open_refcnt;
+	bool is_streaming;
+	enum avt_mode mode;
+
+	struct v4l2_ctrl_handler v4l2_ctrl_hdl;
+	struct v4l2_ctrl_config	avt_ctrl_cfg[AVT_MAX_CTRLS];
+	struct v4l2_ctrl *avt_ctrls[AVT_MAX_CTRLS];
+
+	struct v4l2_fwnode_endpoint v4l2_fwnode_ep; /* the parsed DT endpoint info */
+	struct fwnode_handle *endpoint;
+	
+	struct gpio_desc *reset_gpio;
+	struct gpio_desc *pwdn_gpio;
+
+	int power_count;
+
+	struct v4l2_mbus_framefmt mbus_framefmt;
+	struct v4l2_captureparm streamcap;
+
+	struct v4l2_rect max_rect;
+	struct v4l2_rect min_rect;
+	struct v4l2_rect curr_rect;
+
+	int pending_hardtreset_request;
+	int pending_softreset_request;
+	int pending_dphyreset_request;
+
+	uint32_t avt_min_clk;
+	uint32_t avt_max_clk;
+
+	struct v4l2_fract frame_interval;
+
+	union cci_reg cci_reg;
+	struct gencp_reg gencp_reg;
+
+	union bcrm_feature_inquiry_reg feature_inquiry_reg;
+	union bcrm_avail_mipi_reg avail_mipi_reg;
+	union bcrm_bayer_inquiry_reg bayer_inquiry_reg;
+	union bcrm_supported_lanecount_reg lane_capabilities;
+
+	struct avt_csi_mipi_mode_mapping *available_fmts;
+	uint32_t available_fmts_cnt;
+
+	struct list_head requests_queued;
+	struct completion bcrm_wrhs_completion;
+
+	struct work_struct bcrm_wrhs_work;
+	struct workqueue_struct *bcrm_wrhs_queue;
+
+	u32 mbus_fmt_code;
+	bool cross_update;
+	struct avt_frame_param frmp;
+	uint32_t streamon_delay;
+	uint32_t force_reset_on_init;
+	u8	 stream_start_phy_reset;
+
+#ifdef BCRM_HS_THREAD
+	struct task_struct *bcrm_hs_task;
+	struct semaphore 	bcrm_sem;
+	struct completion 	bcrm_completion;
+#endif
+
+	struct avt_binning_info *binning_infos[AVT_BINNING_TYPE_CNT];
+	size_t binning_info_cnt[AVT_BINNING_TYPE_CNT];
+	u32 curr_binning_type;
+	const struct avt_binning_info *curr_binning_info;
+
+	struct v4l2_rect sensor_rect;
+
+	bool framerate_auto;
+
+	atomic_t  bcrm_wrhs_enabled;
+
+	struct bin_attribute *i2c_xfer_attr;
+
+	struct avt_i2c_xfer	next_fw_rd_transfer;
+
+	struct device_attribute	*mode_attr;
+};
+
+enum avt_ctrl {
+  V4L2_AV_CSI2_WIDTH = 0x1001,
+  V4L2_AV_CSI2_HEIGHT,
+  V4L2_AV_CSI2_PIXELFORMAT,
+  V4L2_AV_CSI2_STREAMON,
+  V4L2_AV_CSI2_STREAMOFF,
+  V4L2_AV_CSI2_ABORT,
+  V4L2_AV_CSI2_HFLIP,
+  V4L2_AV_CSI2_VFLIP,
+  V4L2_AV_CSI2_OFFSET_X,
+  V4L2_AV_CSI2_OFFSET_Y,
+  V4L2_AV_CSI2_CHANGEMODE,
+  V4L2_AV_CSI2_BAYER_PATTERN
+};
+
+enum bayer_format {
+	bayer_ignore = -1,
+	monochrome = 0,
+	bayer_gr = 1,
+	bayer_rg = 2,
+	bayer_gb = 3,
+	bayer_bg = 4,
+};
+
+struct avt_csi_mipi_mode_mapping {
+	u32 mbus_code;
+	u16 mipi_fmt;
+	u32 colorspace;
+	u32 fourcc;           /* v4l2 format id */
+	enum bayer_format bayer_pattern;
+	char name[32];
+#ifdef DEBUG
+	char  mb_code_string[32];
+#endif
+};
+
+struct bcrm_to_v4l2 {
+	int64_t min_bcrm;
+	int64_t max_bcrm;
+	int64_t step_bcrm;
+	int32_t min_v4l2;
+	int32_t max_v4l2;
+	int32_t step_v4l2;
+};
+
+#define CLEAR(x)       memset(&(x), 0, sizeof(x))
+
+#define EXP_ABS		100000LL
+#define UHZ_TO_HZ	1000000UL
+
+#define CCI_REG_LAYOUT_MINVER_MASK (0x0000ffff)
+#define CCI_REG_LAYOUT_MINVER_SHIFT (0)
+#define CCI_REG_LAYOUT_MAJVER_MASK (0xffff0000)
+#define CCI_REG_LAYOUT_MAJVER_SHIFT (16)
+
+#define CCI_REG_LAYOUT_MINVER	0
+#define CCI_REG_LAYOUT_MAJVER	1
+
+#endif
diff --git a/include/media/avt-mipi-csi2.h b/include/media/avt-mipi-csi2.h
new file mode 100644
index 0000000..b37bcec
--- /dev/null
+++ b/include/media/avt-mipi-csi2.h
@@ -0,0 +1,43 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * MIPI CSI-2 Data Types
+ *
+ * Copyright (C) 2022 Laurent Pinchart <laurent.pinchart@ideasonboard.com>
+ */
+
+#ifndef _AVT_MIPI_CSI2_H
+#define _AVT_MIPI_CSI2_H
+
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(5, 17, 0))
+#include <media/mipi-csi2.h>
+#else 
+/* Long packet data types */
+#define MIPI_CSI2_DT_NULL		0x10
+#define MIPI_CSI2_DT_BLANKING		0x11
+#define MIPI_CSI2_DT_EMBEDDED_8B	0x12
+#define MIPI_CSI2_DT_YUV420_8B		0x18
+#define MIPI_CSI2_DT_YUV420_10B		0x19
+#define MIPI_CSI2_DT_YUV420_8B_LEGACY	0x1a
+#define MIPI_CSI2_DT_YUV420_8B_CS	0x1c
+#define MIPI_CSI2_DT_YUV420_10B_CS	0x1d
+#define MIPI_CSI2_DT_YUV422_8B		0x1e
+#define MIPI_CSI2_DT_YUV422_10B		0x1f
+#define MIPI_CSI2_DT_RGB444		0x20
+#define MIPI_CSI2_DT_RGB555		0x21
+#define MIPI_CSI2_DT_RGB565		0x22
+#define MIPI_CSI2_DT_RGB666		0x23
+#define MIPI_CSI2_DT_RGB888		0x24
+#define MIPI_CSI2_DT_RAW24		0x27
+#define MIPI_CSI2_DT_RAW6		0x28
+#define MIPI_CSI2_DT_RAW7		0x29
+#define MIPI_CSI2_DT_RAW8		0x2a
+#define MIPI_CSI2_DT_RAW10		0x2b
+#define MIPI_CSI2_DT_RAW12		0x2c
+#define MIPI_CSI2_DT_RAW14		0x2d
+#define MIPI_CSI2_DT_RAW16		0x2e
+#define MIPI_CSI2_DT_RAW20		0x2f
+#define MIPI_CSI2_DT_USER_DEFINED(n)	(0x30 + (n))	/* 0..7 */
+#endif 
+
+#endif /* _AVT_MIPI_CSI2_H */
\ No newline at end of file
diff --git a/include/media/fusa-capture/capture-vi.h b/include/media/fusa-capture/capture-vi.h
new file mode 100644
index 0000000..eadd1a1
--- /dev/null
+++ b/include/media/fusa-capture/capture-vi.h
@@ -0,0 +1,458 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2017-2022 NVIDIA Corporation.  All rights reserved.
+ */
+
+/**
+ * @file include/media/fusa-capture/capture-vi.h
+ *
+ * @brief VI channel operations header for the T186/T194 Camera RTCPU platform.
+ */
+
+#ifndef __FUSA_CAPTURE_VI_H__
+#define __FUSA_CAPTURE_VI_H__
+
+#if defined(__KERNEL__)
+#include <linux/compiler.h>
+#include <linux/types.h>
+#else
+#include <stdint.h>
+#endif
+#include <media/fusa-capture/capture-common.h>
+#include <media/fusa-capture/capture-vi-channel.h>
+#include "soc/tegra/camrtc-capture.h"
+#include "soc/tegra/camrtc-capture-messages.h"
+
+#define __VI_CAPTURE_ALIGN __aligned(8)
+
+struct tegra_vi_channel;
+struct capture_buffer_table;
+
+/**
+ * @brief VI channel capture context.
+ */
+struct vi_capture {
+	uint16_t channel_id; /**< RCE-assigned VI FW channel id */
+	struct device *rtcpu_dev; /**< rtcpu device */
+	struct tegra_vi_channel *vi_channel; /**< VI channel context */
+	struct capture_buffer_table *buf_ctx;
+		/**< Surface buffer management table */
+	struct capture_common_buf requests; /**< Capture descriptors queue */
+	struct capture_descriptor_memoryinfo *requests_memoryinfo;
+		/**< memory info ringbuffer handle*/
+	uint64_t requests_memoryinfo_iova;
+		/**< memory info ringbuffer rtcpu iova */
+	size_t request_buf_size;
+		/**< Size of capture descriptor queue [byte] */
+	uint32_t queue_depth; /**< No. of capture descriptors in queue */
+	uint32_t request_size; /**< Size of single capture descriptor [byte] */
+	bool is_mem_pinned; /**< Whether capture request memory is pinned */
+
+	struct capture_common_status_notifier progress_status_notifier;
+		/**< Capture progress status notifier context */
+	uint32_t progress_status_buffer_depth;
+		/**< No. of capture descriptors */
+	bool is_progress_status_notifier_set;
+		/**< Whether progress_status_notifer has been initialized */
+
+	uint32_t stream_id; /**< NVCSI PixelParser index [0-5] */
+	uint32_t csi_port; /**< NVCSI ports A-H [0-7] */
+	uint32_t virtual_channel_id; /**< CSI virtual channel id [0-15] */
+
+	uint32_t num_gos_tables; /**< No. of cv devices in gos_tables */
+	const dma_addr_t *gos_tables; /**< IOVA addresses of all GoS devices */
+
+	struct syncpoint_info progress_sp; /**< Syncpoint for frame progress */
+	struct syncpoint_info embdata_sp;
+		/**< Syncpoint for embedded metadata */
+	struct syncpoint_info linetimer_sp;
+		/**< Syncpoint for frame line timer */
+
+	struct completion control_resp;
+		/**< Completion for capture-control IVC response */
+	struct completion capture_resp;
+		/**<
+		 * Completion for capture requests (frame), if progress status
+		 * notifier is not in use
+		 */
+	struct mutex control_msg_lock;
+		/**< Lock for capture-control IVC control_resp_msg */
+	struct CAPTURE_CONTROL_MSG control_resp_msg;
+		/**< capture-control IVC resp msg written to by callback */
+
+	struct mutex reset_lock;
+		/**< Channel lock for reset/abort support (via RCE) */
+	struct mutex unpins_list_lock; /**< Lock for unpins_list */
+	struct capture_common_unpins *unpins_list;
+		/**< List of capture request buffer unpins */
+
+	uint64_t vi_channel_mask;
+		/**< Bitmask of RCE-assigned VI FW channel(s). */
+	uint64_t vi2_channel_mask;
+		/**< Bitmask of RCE-assigned VI FW channel(s) for 2nd VI. */
+};
+
+/**
+ * @brief VI channel setup config (IOCTL payload).
+ *
+ * These fields are used to set up the VI channel and capture contexts, and will
+ * be copied verbatim in the IVC capture_channel_config struct to allocate VI
+ * resources in the RCE subsystem.
+ */
+struct vi_capture_setup {
+	uint32_t channel_flags;
+		/**<
+		 * Bitmask for channel flags, see @ref CAPTURE_CHANNEL_FLAGS
+		 */
+	uint32_t error_mask_correctable;
+		/**<
+		 * Bitmask for correctable channel errors. See
+		 * @ref CAPTURE_CHANNEL_ERRORS
+		 */
+	uint64_t vi_channel_mask;
+		/**< Bitmask of VI channels to consider for allocation by RCE */
+	uint64_t vi2_channel_mask;
+		/**< Bitmask of 2nd VI channels */
+	uint32_t queue_depth; /**< No. of capture descriptors in queue. */
+	uint32_t request_size;
+		/**< Size of a single capture descriptor [byte] */
+	union {
+		uint32_t mem; /**< Capture descriptors queue NvRm handle */
+		uint64_t iova;
+			/**<
+			 * Capture descriptors queue base address (written back
+			 * after pinning by KMD)
+			 */
+	};
+	uint8_t slvsec_stream_main;
+		/**< SLVS-EC main stream (hardcode to 0x00) */
+	uint8_t slvsec_stream_sub;
+		/**< SLVS-EC sub stream (hardcode to 0xFF - disabled) */
+	uint16_t __pad_slvsec1;
+
+	uint32_t csi_stream_id; /**< NVCSI PixelParser index [0-5] */
+	uint32_t virtual_channel_id; /**< Virtual Channel index [0-15] */
+	uint32_t csi_port; /**< NVCSI Port [0-7], not valid for TPG */
+	uint32_t __pad_csi; /**< Reserved */
+
+	uint32_t error_mask_uncorrectable;
+		/**<
+		 * Bitmask for correctable channel errors. See
+		 * @ref CAPTURE_CHANNEL_ERRORS
+		 */
+	uint64_t stop_on_error_notify_bits;
+		/**<
+		 * Bitmask for NOTIFY errors that force channel stop upon
+		 * receipt
+		 */
+	uint64_t reserved[2];
+} __VI_CAPTURE_ALIGN;
+
+/**
+ * @brief VI capture info (resp. to query).
+ */
+struct vi_capture_info {
+	struct vi_capture_syncpts {
+		uint32_t progress_syncpt; /**< Progress syncpoint id */
+		uint32_t progress_syncpt_val; /**< Progress syncpoint value. */
+		uint32_t emb_data_syncpt; /**< Embedded metadata syncpoint id */
+		uint32_t emb_data_syncpt_val;
+			/**< Embedded metadata syncpt value. */
+		uint32_t line_timer_syncpt; /**< Line timer syncpoint id */
+		uint32_t line_timer_syncpt_val;
+			/**< Line timer syncpoint value */
+	} syncpts;
+	uint32_t hw_channel_id; /**< RCE-assigned VI FW channel id */
+	uint32_t __pad;
+	uint64_t vi_channel_mask;
+		/**< Bitmask of RCE-assigned VI FW channel(s) */
+	uint64_t vi2_channel_mask;
+		/**< Bitmask of RCE-assigned VI FW channel(s) for 2nd VI */
+} __VI_CAPTURE_ALIGN;
+
+/**
+ * @brief Container for CAPTURE_CONTROL_MSG req./resp. from FuSa UMD (IOCTL
+ * payload).
+ *
+ * The response and request pointers may be to the same memory allocation; in
+ * which case the request message will be overwritten by the response.
+ */
+struct vi_capture_control_msg {
+	uint64_t ptr; /**< Pointer to capture-control message req. */
+	uint32_t size; /**< Size of req./resp. msg [byte] */
+	uint32_t __pad;
+	uint64_t response; /**< Pointer to capture-control message resp. */
+} __VI_CAPTURE_ALIGN;
+
+/**
+ * @brief VI capture request (IOCTL payload).
+ */
+struct vi_capture_req {
+	uint32_t buffer_index; /**< Capture descriptor index. */
+	uint32_t num_relocs; /**< No. of surface buffers to pin/reloc. */
+	uint64_t reloc_relatives;
+		/**<
+		 * Offsets to surface buffer addresses to patch in capture
+		 * descriptor [byte].
+		 */
+} __VI_CAPTURE_ALIGN;
+
+/**
+ * @brief VI capture progress status setup config (IOCTL payload)
+ */
+struct vi_capture_progress_status_req {
+	uint32_t mem; /**< NvRm handle to buffer region start. */
+	uint32_t mem_offset; /**< Status notifier offset [byte]. */
+	uint32_t buffer_depth; /**< Capture descriptor queue size [num]. */
+	uint32_t __pad[3];
+} __VI_CAPTURE_ALIGN;
+
+/**
+ * @brief Add VI capture surface buffer to management table (IOCTL payload)
+ */
+struct vi_buffer_req {
+	uint32_t mem; /**< NvRm handle to buffer. */
+	uint32_t flag; /**< Buffer @ref CAPTURE_BUFFER_OPS bitmask. */
+} __VI_CAPTURE_ALIGN;
+
+/**
+ * @brief The compand configuration describes a piece-wise linear tranformation
+ * function used by the VI companding module.
+ */
+#define VI_CAPTURE_NUM_COMPAND_KNEEPTS 10
+
+/**
+ * @brief VI compand setup config (IOCTL payload).
+ */
+struct vi_capture_compand {
+	uint32_t base[VI_CAPTURE_NUM_COMPAND_KNEEPTS];
+		/**< kneept base param. */
+	uint32_t scale[VI_CAPTURE_NUM_COMPAND_KNEEPTS];
+		/**< kneept scale param. */
+	uint32_t offset[VI_CAPTURE_NUM_COMPAND_KNEEPTS];
+		/**< kneept offset param. */
+} __VI_CAPTURE_ALIGN;
+
+/**
+ * @brief Initialize a VI channel capture context (at channel open).
+ *
+ * The VI channel context is already partially-initialized by the calling
+ * function, the channel capture context is allocated and linked here.
+ *
+ * @param[in,out]	chan		Allocated VI channel context,
+ *					partially-initialized
+ * @param[in]		is_mem_pinned	Whether capture request memory is pinned
+ *
+ * @returns		0 (success), neg. errno (failure)
+ */
+int vi_capture_init(
+	struct tegra_vi_channel *chan,
+	bool is_mem_pinned);
+
+/**
+ * @brief De-initialize a VI capture channel, closing open VI/NVCSI streams, and
+ * freeing the buffer management table and channel capture context.
+ *
+ * The VI channel context is not freed in this function, only the capture
+ * context is.
+ *
+ * @param[in,out]	chan		VI channel context
+ */
+void vi_capture_shutdown(
+	struct tegra_vi_channel *chan);
+
+/**
+ * @brief Select the NvHost VI client instance platform driver to be
+ * associated with the channel.
+ * Only used in the case where VI standalone driver is used
+ * to enumerate the VI channel character drivers
+ *
+ * @param[in/out]	chan	VI channel context
+ * @param[in]	setup	VI channel setup config
+ *
+ */
+void vi_get_nvhost_device(
+	struct tegra_vi_channel *chan,
+	struct vi_capture_setup *setup);
+
+/**
+ * @brief The function returns the corresponding NvHost VI client device
+ * pointer associated with the NVCSI stream Id. A NULL value is returned
+ * if invalid input parameters are passed.
+ *
+ * @param[in]	pdev	VI capture platform device pointer
+ * @param[in]	csi_stream_id	NVCSI stream Id
+ *
+ * @returns		reference to VI device (success), null (failure)
+ */
+struct device *vi_csi_stream_to_nvhost_device(
+	struct platform_device *pdev,
+	uint32_t csi_stream_id);
+
+/**
+ * @brief Open a VI channel in RCE, sending channel configuration to request a
+ * HW channel allocation. Syncpoints are allocated by the KMD in this
+ * subroutine.
+ *
+ * @param[in,out]	chan	VI channel context
+ * @param[in]		setup	VI channel setup config
+ *
+ * @returns		0 (success), neg. errno (failure)
+ */
+int vi_capture_setup(
+	struct tegra_vi_channel *chan,
+	struct vi_capture_setup *setup);
+
+/**
+ * @brief Get the pointer to tegra_vi_channel struct associated with the
+ * stream id and virtual id passed as function input params.
+ *
+ * If no valid tegra_vi_channel pointer is found associated with the given
+ * stream id/ VC id combo then NULL is returned.
+ *
+ * @param[in]	stream_id	CSI stream ID
+ * @param[in]	virtual_channel_id	CSI virtual channel ID
+ *
+ * @returns		pointer to tegra_vi_channel(success), NULL(failure)
+ */
+struct tegra_vi_channel *get_tegra_vi_channel(
+	unsigned int stream_id,
+	unsigned int virtual_channel_id);
+
+
+void vi_capture_abort(struct tegra_vi_channel *chan);
+
+/**
+ * @brief Reset an opened VI channel, all pending capture requests to RCE are
+ * discarded.
+ *
+ * The channel's progress syncpoint is advanced to the threshold of the latest
+ * capture request to unblock any waiting observers.
+ *
+ * A reset barrier may be enqueued in the capture IVC channel to flush stale
+ * capture descriptors, in case of abnormal channel termination.
+ *
+ * @param[in]	chan		VI channel context
+ * @param[in]	reset_flags	Bitmask for VI channel reset options
+ *				(CAPTURE_CHANNEL_RESET_FLAG_*)
+ *
+ * @returns	0 (success), neg. errno (failure)
+ */
+int vi_capture_reset(
+	struct tegra_vi_channel *chan,
+	uint32_t reset_flags);
+
+/**
+ * @brief Release an opened VI channel; the RCE channel allocation, syncpts and
+ * IVC channel callbacks are released.
+ *
+ * @param[in]	chan		VI channel context
+ * @param[in]	reset_flags	Bitmask for VI channel reset options
+ *				(CAPTURE_CHANNEL_RESET_FLAG_*)
+ *
+ *  @returns	0 (success), neg. errno (failure)
+ */
+int vi_capture_release(
+	struct tegra_vi_channel *chan,
+	uint32_t reset_flags);
+
+/**
+ * @brief Release the TPG and/or NVCSI stream on a VI channel, if they are
+ * active.
+ *
+ * This function normally does not execute except in the event of abnormal UMD
+ * termination, as it is the client's responsibility to open and close NVCSI and
+ * TPG sources.
+ *
+ * @param[in]	chan	VI channel context
+ *
+ * @returns	0 (success), neg. errno (failure)
+ */
+int csi_stream_release(
+	struct tegra_vi_channel *chan);
+
+/**
+ * @brief Send a capture-control IVC message to RCE and wait for a response.
+ *
+ * This is a blocking call, with the possibility of timeout.
+ *
+ * @param[in]		chan	VI channel context
+ * @param[in,out]	msg	capture-control IVC container w/ req./resp. pair
+ *
+ * @returns		0 (success), neg. errno (failure)
+ */
+int vi_capture_control_message(
+	struct tegra_vi_channel *chan,
+	struct vi_capture_control_msg *msg);
+
+/**
+ * @brief Send a capture-control IVC message which is received from
+ * userspace to RCE and wait for a response.
+ *
+ * This is a blocking call, with the possibility of timeout.
+ *
+ * @param[in]		chan	VI channel context
+ * @param[in,out]	msg	capture-control IVC container w/ req./resp. pair
+ *
+ * @returns		0 (success), neg. errno (failure)
+ */
+int vi_capture_control_message_from_user(
+	struct tegra_vi_channel *chan,
+	struct vi_capture_control_msg *msg);
+
+/**
+ * @brief Query a VI channel's syncpt ids and values, and retrieve the
+ * RCE-assigned VI FW channel id and mask.
+ *
+ * @param[in]	chan	VI channel context
+ * @param[out]	info	VI channel info response
+ * @returns	0 (success), neg. errno (failure)
+ */
+int vi_capture_get_info(
+	struct tegra_vi_channel *chan,
+	struct vi_capture_info *info);
+
+/**
+ * @brief Send a capture request for a frame via the capture IVC channel to RCE.
+ *
+ * This is a non-blocking call.
+ *
+ * @param[in]	chan	VI channel context
+ * @param[in]	req	VI capture request
+ *
+ * @returns	0 (success), neg. errno (failure)
+ */
+int vi_capture_request(
+	struct tegra_vi_channel *chan,
+	struct vi_capture_req *req);
+
+/**
+ * @brief Wait on receipt of the capture status of the head of the capture
+ *	  request FIFO queue to RCE. The RCE VI driver sends a
+ *	  CAPTURE_STATUS_IND notification at frame completion.
+ *
+ * This is a blocking call, with the possibility of timeout.
+ *
+ * @param[in]	chan		VI channel context
+ * @param[in]	timeout_ms	Time to wait for status completion [ms], set to
+ *				a negative value for indefinite
+ *
+ * @returns	0 (success), neg. errno (failure)
+ */
+int vi_capture_status(
+	struct tegra_vi_channel *chan,
+	int32_t timeout_ms);
+
+/**
+ * @brief Setup VI channel capture status progress notifier.
+ *
+ * @param[in]	chan	VI channel context
+ * @param[in]	req	VI capture progress status setup config
+ *
+ * @returns	0 (success), neg. errno (failure)
+ */
+int vi_capture_set_progress_status_notifier(
+	struct tegra_vi_channel *chan,
+	struct vi_capture_progress_status_req *req);
+
+#endif /* __FUSA_CAPTURE_VI_H__ */
diff --git a/include/media/libcsi_ioctl.h b/include/media/libcsi_ioctl.h
new file mode 100644
index 0000000..348ed14
--- /dev/null
+++ b/include/media/libcsi_ioctl.h
@@ -0,0 +1,355 @@
+/*=============================================================================
+  Copyright (C) 2020 Allied Vision Technologies.  All Rights Reserved.
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+  -----------------------------------------------------------------------------
+
+File:        libcsi_ioctl.h
+
+version:     1.7.10
+=============================================================================*/
+
+
+
+////////////////////////////////////////////////////////////////////////////////
+// DEFINES
+////////////////////////////////////////////////////////////////////////////////
+#ifndef LIBCSI_IOCTL_H
+#define LIBCSI_IOCTL_H
+
+#include <linux/videodev2.h>
+
+/* Version of the libcsi - driver interface spec */
+#define LIBCSI_DRV_SPEC_VERSION_MAJOR       1
+#define LIBCSI_DRV_SPEC_VERSION_MINOR       0
+#define LIBCSI_DRV_SPEC_VERSION_PATCH       8
+
+/* Buffer status reported by driver for returned frames */
+#define V4L2_BUF_FLAG_INCOMPLETE            0x10000000
+#define V4L2_BUF_FLAG_UNUSED                0x20000000
+#define V4L2_BUF_FLAG_VALID                 0x40000000
+#define V4L2_BUF_FLAG_INVALID               0x80000000
+#define V4L2_BUF_FLAG_INVALIDINCOMPLETE     (V4L2_BUF_FLAG_INCOMPLETE | V4L2_BUF_FLAG_INVALID)
+/* Driver capabilities flags. See v4l2_csi_driver_info */
+#define AVT_DRVCAP_USRPTR                   0x00000001  
+#define AVT_DRVCAP_MMAP                     0x00000002
+
+////////////////////////////////////////////////////////////////////////////////
+// ENUMS
+////////////////////////////////////////////////////////////////////////////////
+enum v4l2_lane_counts
+{
+    V4L2_LANE_COUNT_1_LaneSupport       = 0x1,
+    V4L2_LANE_COUNT_2_LaneSupport       = 0x2,
+    V4L2_LANE_COUNT_3_LaneSupport       = 0x4,
+    V4L2_LANE_COUNT_4_LaneSupport       = 0x8,
+};
+
+enum v4l2_statistics_capability
+{
+    V4L2_STATISTICS_CAPABILITY_FrameCount           = 0x1,
+    V4L2_STATISTICS_CAPABILITY_PacketCRCError       = 0x2,
+    V4L2_STATISTICS_CAPABILITY_FramesUnderrun       = 0x4,
+    V4L2_STATISTICS_CAPABILITY_FramesIncomplete     = 0x8,
+    V4L2_STATISTICS_CAPABILITY_CurrentFrameCount    = 0x10,
+    V4L2_STATISTICS_CAPABILITY_CurrentFrameInterval = 0x20,
+};
+
+enum gencp_handshake_state
+{
+    GENCP_HANDSHAKE_BUFFER_CLEARED      = 0x0,
+    GENCP_HANDSHAKE_BUFFER_VALID        = 0x1,
+    GENCP_HANDSHAKE_BUFFER_PROCESSED    = 0x2,
+};
+
+enum manufacturer_id
+{
+    MANUFACTURER_ID_NXP                 = 0x00,
+    MANUFACTURER_ID_NVIDIA              = 0x01,
+    MANUFACTURER_ID_AMDXLNX             = 0x02,
+};                                      
+                                        
+enum soc_family_id                      
+{                                       
+    SOC_FAMILY_ID_IMX6                  = 0x00,
+    SOC_FAMILY_ID_TEGRA                 = 0x01,
+    SOC_FAMILY_ID_IMX8                  = 0x02,
+    SOC_FAMILY_ID_IMX8M                 = 0x03,
+    SOC_FAMILY_ID_IMX8X                 = 0x04,
+    SOC_FAMILY_ID_IMX8MP                = 0x05,
+    SOC_FAMILY_ID_ZYNQMP                = 0x06,
+};                                      
+
+/* ToDo: check whether the soc specific driver id is really needed */
+
+enum imx6_driver_id                     
+{                                       
+    IMX6_DRIVER_ID_NITROGEN             = 0x00,
+    IMX6_DRIVER_ID_WANDBOARD            = 0x01,
+};                                      
+                                        
+enum tegra_driver_id                    
+{                                       
+    TEGRA_DRIVER_ID_DEFAULT             = 0x00,
+};                                      
+                                        
+enum imx8_driver_id                     
+{                                       
+    IMX8_DRIVER_ID_DEFAULT              = 0x00,
+};                                      
+                                        
+enum imx8m_driver_id                    
+{                                       
+    IMX8M_DRIVER_ID_DEFAULT             = 0x00,
+};                                      
+                                        
+enum imx8x_driver_id                    
+{                                       
+    IMX8X_DRIVER_ID_DEFAULT             = 0x00,
+};
+
+
+enum v4l2_triggeractivation
+{
+    V4L2_TRIGGER_ACTIVATION_RISING_EDGE  = 0,
+    V4L2_TRIGGER_ACTIVATION_FALLING_EDGE = 1,
+    V4L2_TRIGGER_ACTIVATION_ANY_EDGE     = 2,
+    V4L2_TRIGGER_ACTIVATION_LEVEL_HIGH   = 3,
+    V4L2_TRIGGER_ACTIVATION_LEVEL_LOW    = 4
+};
+
+enum v4l2_triggersource
+{
+    V4L2_TRIGGER_SOURCE_SOFTWARE = 0,
+    V4L2_TRIGGER_SOURCE_LINE0    = 1,
+    V4L2_TRIGGER_SOURCE_LINE1    = 2,
+    V4L2_TRIGGER_SOURCE_LINE2    = 3,
+    V4L2_TRIGGER_SOURCE_LINE3    = 4,
+};
+
+////////////////////////////////////////////////////////////////////////////////
+// STRUCTS
+////////////////////////////////////////////////////////////////////////////////
+struct v4l2_i2c
+{
+    __u32       register_address;       // Register
+    __u32       timeout;                // Timeout value
+    const char* ptr_buffer;             // I/O buffer
+    __u32       register_size;          // Register address size (must be 2 for AVT Alvium 1500 and 1800)
+    __u32       num_bytes;              // Bytes to read or write
+};
+
+struct v4l2_dma_mem
+{
+    __u32       index;                  // index of the buffer
+    __u32       type;                   // enum v4l2_buf_type
+    __u32       memory;                 // enum v4l2_memory
+};
+
+struct v4l2_statistics_capabilities
+{
+    __u64 statistics_capability;        // Bitmask with statistics capabilities enum (v4l2_statistics_capability)
+};
+
+struct v4l2_min_announced_frames
+{
+    __u32 min_announced_frames;         // Minimum number of announced frames
+};
+
+struct v4l2_range
+{
+    __u8  is_valid;                     // Indicates, if values are valid (1) or invalid (0)
+    __u32 min;                          // Minimum allowed value
+    __u32 max;                          // Maximum allowed value
+};
+
+struct v4l2_csi_host_clock_freq_ranges
+{
+    struct v4l2_range lane_range_1;     // Min and max value for 1 lane
+    struct v4l2_range lane_range_2;     // Min and max value for 2 lanes
+    struct v4l2_range lane_range_3;     // Min and max value for 3 lanes
+    struct v4l2_range lane_range_4;     // Min and max value for 4 lanes
+};
+
+struct v4l2_supported_lane_counts
+{
+    __u32 supported_lane_counts;        // Bitfield with the supported lane counts from v4l2_lane_counts
+};
+
+struct v4l2_restriction
+{
+    __u8  is_valid;                     // Indicates, if values are valid (1) or invalid (0)
+    __u32 min;                          // Minimum value
+    __u32 max;                          // Maximum value
+    __u32 inc;                          // Increment value
+};
+
+struct v4l2_ipu_restrictions
+{
+    struct v4l2_restriction ipu_x;      // X restriction
+    struct v4l2_restriction ipu_y;      // Y restriction
+};
+
+struct v4l2_streamoff_ex
+{
+    __u32 timeout;                      // Timeout value in ms
+};
+
+struct v4l2_gencp_buffer_sizes
+{
+    __u32 gencp_in_buffer_size;         // Size in bytes of the GenCP In buffer
+    __u32 gencp_out_buffer_size;        // Size in bytes of the GenCP Out buffer
+};
+
+struct v4l2_csi_data_identifiers_inq
+{
+    __u64 data_identifiers_inq_1;       // Inquiry for data identifiers 0-63
+    __u64 data_identifiers_inq_2;       // Inquiry for data identifiers 64-127
+    __u64 data_identifiers_inq_3;       // Inquiry for data identifiers 128-191
+    __u64 data_identifiers_inq_4;       // Inquiry for data identifiers 192-255
+};
+
+struct v4l2_stats_t
+{
+    __u64 frames_count;                 // Total number of frames received
+    __u64 packet_crc_error;             // Number of packets with CRC errors
+    __u64 frames_underrun;              // Number of frames dropped because of buffer underrun
+    __u64 frames_incomplete;            // Number of frames that were not completed
+    __u64 current_frame_count;          // Number of frames received within CurrentFrameInterval (nec. to calculate fps value)
+    __u64 current_frame_interval;       // Time interval between frames in s
+};
+
+struct v4l2_csi_driver_info
+{
+    union _id
+    {
+        __u32 board_id;                 // 32 Bit board id
+        struct 
+        {
+            __u8 manufacturer_id;       // 0x00 = Boundary Devices, 0x01= NVIDIA
+            __u8 soc_family_id;         // 0x00 = i.MX6, 0x01=TEGRA, 0x02=i.MX8, 0x03=i.MX8X
+            __u8 driver_id;             // Driver identifier for a certain soc family 
+            __u8 reserved;              //
+        };
+    }id;
+    __u32 driver_version;               // Driver version
+    __u32 driver_interface_version;     // Used driver specification version
+    __u32 driver_caps;                  // Driver capabilities flags
+    __u32 usrptr_alignment;             // Buffer alignment for user pointer mode in bytes
+};
+
+struct v4l2_csi_config
+{
+    __u8  lane_count;                   // Number of lanes
+    __u32 csi_clock;                    // CSI clock in Hz
+};
+
+struct v4l2_trigger_status
+{
+    __u8 trigger_source;                // v4l2_triggersource enum value    
+    __u8 trigger_activation;            // v4l2_triggeractivation enum value  
+    __u8 trigger_mode_enabled;          // Enable (1) or disable (0) trigger mode
+};
+
+struct v4l2_trigger_rate
+{
+	__u64 frames_per_period;		    // Number of frames per period
+	__u64 period_sec;				    // Period in seconds
+};
+
+////////////////////////////////////////////////////////////////////////////////
+// DEFINES
+////////////////////////////////////////////////////////////////////////////////
+// Custom ioctl definitions
+/* i2c read */
+#define VIDIOC_R_I2C                        _IOWR('V', BASE_VIDIOC_PRIVATE + 0, struct v4l2_i2c)
+
+/* i2c write */
+#define VIDIOC_W_I2C                        _IOWR('V', BASE_VIDIOC_PRIVATE + 1, struct v4l2_i2c)
+
+/* Memory alloc for a frame */
+#define VIDIOC_MEM_ALLOC                    _IOWR('V', BASE_VIDIOC_PRIVATE + 2, struct v4l2_dma_mem)
+
+/* Memory free for a frame */
+#define VIDIOC_MEM_FREE                     _IOWR('V', BASE_VIDIOC_PRIVATE + 3, struct v4l2_dma_mem)
+
+/* Flush frames */
+#define VIDIOC_FLUSH_FRAMES                 _IO('V', BASE_VIDIOC_PRIVATE + 4)
+
+/* Stream statistics */
+#define VIDIOC_STREAMSTAT                   _IOR('V', BASE_VIDIOC_PRIVATE + 5, struct v4l2_stats_t)
+
+/* Reset Stream statistics */
+#define VIDIOC_RESET_STREAMSTAT             _IO('V', BASE_VIDIOC_PRIVATE + 6)
+
+/* Custom streamon */
+#define VIDIOC_STREAMON_EX                  _IO('V', BASE_VIDIOC_PRIVATE + 7)
+
+/* Custom streamoff */
+#define VIDIOC_STREAMOFF_EX                 _IOW('V', BASE_VIDIOC_PRIVATE + 8, struct v4l2_streamoff_ex)
+
+/* Get statistics capability */
+#define VIDIOC_G_STATISTICS_CAPABILITIES    _IOR('V', BASE_VIDIOC_PRIVATE + 9, struct v4l2_statistics_capabilities)
+
+/* Get min number of announced frames*/
+#define VIDIOC_G_MIN_ANNOUNCED_FRAMES       _IOR('V', BASE_VIDIOC_PRIVATE + 10, struct v4l2_min_announced_frames)
+
+/* Get supported lane value */
+#define VIDIOC_G_SUPPORTED_LANE_COUNTS      _IOR('V', BASE_VIDIOC_PRIVATE + 11, struct v4l2_supported_lane_counts)
+
+/* Get CSI Host clock frequencies */
+#define VIDIOC_G_CSI_HOST_CLK_FREQ          _IOR('V', BASE_VIDIOC_PRIVATE + 12, struct v4l2_csi_host_clock_freq_ranges)
+
+/* Get IPU restrictions */
+#define VIDIOC_G_IPU_RESTRICTIONS           _IOR('V', BASE_VIDIOC_PRIVATE + 13, struct v4l2_ipu_restrictions)
+
+/* Get GenCPIn and GenCPOut buffer sizes */
+#define VIDIOC_G_GENCP_BUFFER_SIZES         _IOWR('V', BASE_VIDIOC_PRIVATE + 14, struct v4l2_gencp_buffer_sizes)
+
+/* Retrieving the MIPI Data Identifier */
+#define VIDIOC_G_SUPPORTED_DATA_IDENTIFIERS _IOWR('V', BASE_VIDIOC_PRIVATE + 15, struct v4l2_csi_data_identifiers_inq)
+
+/* Retrieving i2c clock frequency */
+#define VIDIOC_G_I2C_CLOCK_FREQ             _IOWR('V', BASE_VIDIOC_PRIVATE + 16, int)
+
+/* Retrieving extended driver information */
+#define VIDIOC_G_DRIVER_INFO                _IOR('V', BASE_VIDIOC_PRIVATE + 17, struct v4l2_csi_driver_info)
+
+/* Get CSI configuration */
+#define VIDIOC_G_CSI_CONFIG                 _IOR('V', BASE_VIDIOC_PRIVATE + 18, struct v4l2_csi_config)
+
+/* Set CSI configuration */
+#define VIDIOC_S_CSI_CONFIG                 _IOWR('V', BASE_VIDIOC_PRIVATE + 19, struct v4l2_csi_config)
+
+/* Set the Trigger mode to OFF */
+#define VIDIOC_TRIGGER_MODE_OFF             _IO('V', BASE_VIDIOC_PRIVATE + 20)
+
+/* Set the Trigger mode to ON */
+#define VIDIOC_TRIGGER_MODE_ON              _IO('V', BASE_VIDIOC_PRIVATE + 21)
+
+/* Set the trigger activation */
+#define VIDIOC_S_TRIGGER_ACTIVATION         _IOW('V', BASE_VIDIOC_PRIVATE + 22, int)
+
+/* Get the trigger activation */
+#define VIDIOC_G_TRIGGER_ACTIVATION         _IOR('V', BASE_VIDIOC_PRIVATE + 23, int)
+
+/* Set the trigger source */
+#define VIDIOC_S_TRIGGER_SOURCE             _IOW('V', BASE_VIDIOC_PRIVATE + 24, int)
+
+/* Get the trigger source */
+#define VIDIOC_G_TRIGGER_SOURCE             _IOR('V', BASE_VIDIOC_PRIVATE + 25, int)
+
+/* Execute a software trigger */
+#define VIDIOC_TRIGGER_SOFTWARE             _IO('V', BASE_VIDIOC_PRIVATE + 26)
+
+
+#endif /* LIBCSI_IOCTL_H */
diff --git a/include/media/tc358743.h b/include/media/tc358743.h
new file mode 100644
index 0000000..787878e
--- /dev/null
+++ b/include/media/tc358743.h
@@ -0,0 +1,150 @@
+/*
+ * tc358743 - Toshiba HDMI to CSI-2 bridge
+ *
+ * Copyright 2015 Cisco Systems, Inc. and/or its affiliates. All rights
+ * reserved.
+ *
+ * This program is free software; you may redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ */
+
+/*
+ * References (c = chapter, p = page):
+ * REF_01 - Toshiba, TC358743XBG (H2C), Functional Specification, Rev 0.60
+ * REF_02 - Toshiba, TC358743XBG_HDMI-CSI_Tv11p_nm.xls
+ */
+
+#ifndef _TC358743_
+#define _TC358743_
+//#include <media/v4l2-of.h>
+#include <media/v4l2-fwnode.h>
+
+#include "tc358743_regs.h"
+
+enum tc358743_csi_port { CSI_TX_NONE = 0, CSI_TX_0, CSI_TX_1, CSI_TX_BOTH };
+
+enum tc358743_ddc5v_delays {
+  DDC5V_DELAY_0_MS,
+  DDC5V_DELAY_50_MS,
+  DDC5V_DELAY_100_MS,
+  DDC5V_DELAY_200_MS,
+  DDC5V_DELAY_MAX = DDC5V_DELAY_200_MS,
+};
+
+enum tc358743_hdmi_detection_delay {
+  HDMI_MODE_DELAY_0_MS,
+  HDMI_MODE_DELAY_25_MS,
+  HDMI_MODE_DELAY_50_MS,
+  HDMI_MODE_DELAY_100_MS,
+};
+
+struct tc358743_platform_data {
+  /* GPIOs */
+  int reset_gpio;
+
+#ifdef CONFIG_V4L2_FWNODE
+  struct v4l2_fwnode_endpoint endpoint;
+#else
+  struct v4l2_of_endpoint endpoint;
+#endif
+
+  /* System clock connected to REFCLK (pin H5) */
+  u32 refclk_hz; /* 26 MHz, 27 MHz or 42 MHz */
+
+  /* DDC +5V debounce delay to avoid spurious interrupts when the cable
+   * is connected.
+   * Sets DDC5V_MODE in register DDC_CTL.
+   * Default: DDC5V_DELAY_0_MS
+   */
+  enum tc358743_ddc5v_delays ddc5v_delay;
+
+  bool enable_hdcp;
+
+  /* CSI Output */
+  enum tc358743_csi_port csi_port;  // TODO: Should this be port-index?
+
+  /*
+   * The FIFO size is 512x32, so Toshiba recommend to set the default FIFO
+   * level to somewhere in the middle (e.g. 300), so it can cover speed
+   * mismatches in input and output ports.
+   */
+  u16 fifo_level;
+
+  /*  Bps pr lane is (refclk_hz / pll_prd) * pll_fbd */
+  u16 pll_prd;
+  u16 pll_fbd;
+
+  /* CSI
+   * Calculate CSI parameters with REF_02 for the highest resolution your
+   * CSI interface can handle. The driver will adjust the number of CSI
+   * lanes in use according to the pixel clock.
+   *
+   * The values in brackets are calculated with REF_02 when the number of
+   * bps pr lane is 823.5 MHz, and can serve as a starting point.
+   */
+  u32 lineinitcnt;    /* (0x00001770) */
+  u32 lptxtimecnt;    /* (0x00000005) */
+  u32 tclk_headercnt; /* (0x00001d04) */
+  u32 tclk_trailcnt;  /* (0x00000000) */
+  u32 ths_headercnt;  /* (0x00000505) */
+  u32 twakeup;        /* (0x00004650) */
+  u32 tclk_postcnt;   /* (0x00000000) */
+  u32 ths_trailcnt;   /* (0x00000004) */
+  u32 hstxvregcnt;    /* (0x00000005) */
+
+  /* DVI->HDMI detection delay to avoid unnecessary switching between DVI
+   * and HDMI mode.
+   * Sets HDMI_DET_V in register HDMI_DET.
+   * Default: HDMI_MODE_DELAY_0_MS
+   */
+  enum tc358743_hdmi_detection_delay hdmi_detection_delay;
+
+  /* Reset PHY automatically when TMDS clock goes from DC to AC.
+   * Sets PHY_AUTO_RST2 in register PHY_CTL2.
+   * Default: false
+   */
+  bool hdmi_phy_auto_reset_tmds_detected;
+
+  /* Reset PHY automatically when TMDS clock passes 21 MHz.
+   * Sets PHY_AUTO_RST3 in register PHY_CTL2.
+   * Default: false
+   */
+  bool hdmi_phy_auto_reset_tmds_in_range;
+
+  /* Reset PHY automatically when TMDS clock is detected.
+   * Sets PHY_AUTO_RST4 in register PHY_CTL2.
+   * Default: false
+   */
+  bool hdmi_phy_auto_reset_tmds_valid;
+
+  /* Reset HDMI PHY automatically when hsync period is out of range.
+   * Sets H_PI_RST in register HV_RST.
+   * Default: false
+   */
+  bool hdmi_phy_auto_reset_hsync_out_of_range;
+
+  /* Reset HDMI PHY automatically when vsync period is out of range.
+   * Sets V_PI_RST in register HV_RST.
+   * Default: false
+   */
+  bool hdmi_phy_auto_reset_vsync_out_of_range;
+};
+
+/* custom controls */
+/* Audio sample rate in Hz */
+#define TC358743_CID_AUDIO_SAMPLING_RATE (V4L2_CID_USER_TC358743_BASE + 0)
+/* Audio present status */
+#define TC358743_CID_AUDIO_PRESENT (V4L2_CID_USER_TC358743_BASE + 1)
+
+#endif
\ No newline at end of file
diff --git a/include/media/tc358743_regs.h b/include/media/tc358743_regs.h
new file mode 100644
index 0000000..665c3d3
--- /dev/null
+++ b/include/media/tc358743_regs.h
@@ -0,0 +1,681 @@
+/*
+  * tc358743 - Toshiba HDMI to CSI-2 bridge - register names and bit masks
+ *
+ * Copyright 2015 Cisco Systems, Inc. and/or its affiliates. All rights
+ * reserved.
+ *
+ * This program is free software; you may redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ */
+
+/*
+ * References (c = chapter, p = page):
+ * REF_01 - Toshiba, TC358743XBG (H2C), Functional Specification, Rev 0.60
+ */
+
+/* Bit masks has prefix 'MASK_' and options after '_'. */
+
+#ifndef __TC358743_REGS_H
+#define __TC358743_REGS_H
+
+#define CHIPID                                0x0000
+#define MASK_CHIPID                           0xff00
+#define MASK_REVID                            0x00ff
+
+#define SYSCTL                                0x0002
+#define MASK_IRRST                            0x0800
+#define MASK_CECRST                           0x0400
+#define MASK_CTXRST                           0x0200
+#define MASK_HDMIRST                          0x0100
+#define MASK_SLEEP                            0x0001
+
+#define CONFCTL                               0x0004
+#define MASK_PWRISO                           0x8000
+#define MASK_ACLKOPT                          0x1000
+#define MASK_AUDCHNUM                         0x0c00
+#define MASK_AUDCHNUM_8                       0x0000
+#define MASK_AUDCHNUM_6                       0x0400
+#define MASK_AUDCHNUM_4                       0x0800
+#define MASK_AUDCHNUM_2                       0x0c00
+#define MASK_AUDCHSEL                         0x0200
+#define MASK_I2SDLYOPT                        0x0100
+#define MASK_YCBCRFMT                         0x00c0
+#define MASK_YCBCRFMT_444                     0x0000
+#define MASK_YCBCRFMT_422_12_BIT              0x0040
+#define MASK_YCBCRFMT_COLORBAR                0x0080
+#define MASK_YCBCRFMT_422_8_BIT               0x00c0
+#define MASK_INFRMEN                          0x0020
+#define MASK_AUDOUTSEL                        0x0018
+#define MASK_AUDOUTSEL_CSI                    0x0000
+#define MASK_AUDOUTSEL_I2S                    0x0010
+#define MASK_AUDOUTSEL_TDM                    0x0018
+#define MASK_AUTOINDEX                        0x0004
+#define MASK_ABUFEN                           0x0002
+#define MASK_VBUFEN                           0x0001
+
+#define FIFOCTL                               0x0006
+
+#define INTSTATUS                             0x0014
+#define MASK_AMUTE_INT                        0x0400
+#define MASK_HDMI_INT                         0x0200
+#define MASK_CSI_INT                          0x0100
+#define MASK_SYS_INT                          0x0020
+#define MASK_CEC_EINT                         0x0010
+#define MASK_CEC_TINT                         0x0008
+#define MASK_CEC_RINT                         0x0004
+#define MASK_IR_EINT                          0x0002
+#define MASK_IR_DINT                          0x0001
+
+#define INTMASK                               0x0016
+#define MASK_AMUTE_MSK                        0x0400
+#define MASK_HDMI_MSK                         0x0200
+#define MASK_CSI_MSK                          0x0100
+#define MASK_SYS_MSK                          0x0020
+#define MASK_CEC_EMSK                         0x0010
+#define MASK_CEC_TMSK                         0x0008
+#define MASK_CEC_RMSK                         0x0004
+#define MASK_IR_EMSK                          0x0002
+#define MASK_IR_DMSK                          0x0001
+
+#define INTFLAG                               0x0018
+#define INTSYSSTATUS                          0x001A
+
+#define PLLCTL0                               0x0020
+#define MASK_PLL_PRD                          0xf000
+#define SET_PLL_PRD(prd)                      ((((prd) - 1) << 12) &\
+						MASK_PLL_PRD)
+#define MASK_PLL_FBD                          0x01ff
+#define SET_PLL_FBD(fbd)                      (((fbd) - 1) & MASK_PLL_FBD)
+
+#define PLLCTL1                               0x0022
+#define MASK_PLL_FRS                          0x0c00
+#define SET_PLL_FRS(frs)                      (((frs) << 10) & MASK_PLL_FRS)
+#define MASK_PLL_LBWS                         0x0300
+#define MASK_LFBREN                           0x0040
+#define MASK_BYPCKEN                          0x0020
+#define MASK_CKEN                             0x0010
+#define MASK_RESETB                           0x0002
+#define MASK_PLL_EN                           0x0001
+
+#define CLW_CNTRL                             0x0140
+#define MASK_CLW_LANEDISABLE                  0x0001
+
+#define D0W_CNTRL                             0x0144
+#define MASK_D0W_LANEDISABLE                  0x0001
+
+#define D1W_CNTRL                             0x0148
+#define MASK_D1W_LANEDISABLE                  0x0001
+
+#define D2W_CNTRL                             0x014C
+#define MASK_D2W_LANEDISABLE                  0x0001
+
+#define D3W_CNTRL                             0x0150
+#define MASK_D3W_LANEDISABLE                  0x0001
+
+#define STARTCNTRL                            0x0204
+#define MASK_START                            0x00000001
+
+#define LINEINITCNT                           0x0210
+#define LPTXTIMECNT                           0x0214
+#define TCLK_HEADERCNT                        0x0218
+#define TCLK_TRAILCNT                         0x021C
+#define THS_HEADERCNT                         0x0220
+#define TWAKEUP                               0x0224
+#define TCLK_POSTCNT                          0x0228
+#define THS_TRAILCNT                          0x022C
+#define HSTXVREGCNT                           0x0230
+
+#define HSTXVREGEN                            0x0234
+#define MASK_D3M_HSTXVREGEN                   0x0010
+#define MASK_D2M_HSTXVREGEN                   0x0008
+#define MASK_D1M_HSTXVREGEN                   0x0004
+#define MASK_D0M_HSTXVREGEN                   0x0002
+#define MASK_CLM_HSTXVREGEN                   0x0001
+
+
+#define TXOPTIONCNTRL                         0x0238
+#define MASK_CONTCLKMODE                      0x00000001
+
+#define CSI_CONTROL                           0x040C
+#define MASK_CSI_MODE                         0x8000
+#define MASK_HTXTOEN                          0x0400
+#define MASK_TXHSMD                           0x0080
+#define MASK_HSCKMD                           0x0020
+#define MASK_NOL                              0x0006
+#define MASK_NOL_1                            0x0000
+#define MASK_NOL_2                            0x0002
+#define MASK_NOL_3                            0x0004
+#define MASK_NOL_4                            0x0006
+#define MASK_EOTDIS                           0x0001
+
+#define CSI_INT                               0x0414
+#define MASK_INTHLT                           0x00000008
+#define MASK_INTER                            0x00000004
+
+#define CSI_INT_ENA                           0x0418
+#define MASK_IENHLT                           0x00000008
+#define MASK_IENER                            0x00000004
+
+#define CSI_ERR                               0x044C
+#define MASK_INER                             0x00000200
+#define MASK_WCER                             0x00000100
+#define MASK_QUNK                             0x00000010
+#define MASK_TXBRK                            0x00000002
+
+#define CSI_ERR_INTENA                        0x0450
+#define CSI_ERR_HALT                          0x0454
+
+#define CSI_CONFW                             0x0500
+#define MASK_MODE                             0xe0000000
+#define MASK_MODE_SET                         0xa0000000
+#define MASK_MODE_CLEAR                       0xc0000000
+#define MASK_ADDRESS                          0x1f000000
+#define MASK_ADDRESS_CSI_CONTROL              0x03000000
+#define MASK_ADDRESS_CSI_INT_ENA              0x06000000
+#define MASK_ADDRESS_CSI_ERR_INTENA           0x14000000
+#define MASK_ADDRESS_CSI_ERR_HALT             0x15000000
+#define MASK_DATA                             0x0000ffff
+
+#define CSI_INT_CLR                           0x050C
+#define MASK_ICRER                            0x00000004
+
+#define CSI_START                             0x0518
+#define MASK_STRT                             0x00000001
+
+#define CECEN                                 0x0600
+#define MASK_CECEN                            0x0001
+
+#define HDMI_INT0                             0x8500
+#define MASK_I_KEY                            0x80
+#define MASK_I_MISC                           0x02
+#define MASK_I_PHYERR                         0x01
+
+#define HDMI_INT1                             0x8501
+#define MASK_I_GBD                            0x80
+#define MASK_I_HDCP                           0x40
+#define MASK_I_ERR                            0x20
+#define MASK_I_AUD                            0x10
+#define MASK_I_CBIT                           0x08
+#define MASK_I_PACKET                         0x04
+#define MASK_I_CLK                            0x02
+#define MASK_I_SYS                            0x01
+
+#define SYS_INT                               0x8502
+#define MASK_I_ACR_CTS                        0x80
+#define MASK_I_ACRN                           0x40
+#define MASK_I_DVI                            0x20
+#define MASK_I_HDMI                           0x10
+#define MASK_I_NOPMBDET                       0x08
+#define MASK_I_DPMBDET                        0x04
+#define MASK_I_TMDS                           0x02
+#define MASK_I_DDC                            0x01
+
+#define CLK_INT                               0x8503
+#define MASK_I_OUT_H_CHG                      0x40
+#define MASK_I_IN_DE_CHG                      0x20
+#define MASK_I_IN_HV_CHG                      0x10
+#define MASK_I_DC_CHG                         0x08
+#define MASK_I_PXCLK_CHG                      0x04
+#define MASK_I_PHYCLK_CHG                     0x02
+#define MASK_I_TMDSCLK_CHG                    0x01
+
+#define CBIT_INT                              0x8505
+#define MASK_I_AF_LOCK                        0x80
+#define MASK_I_AF_UNLOCK                      0x40
+#define MASK_I_CBIT_FS                        0x02
+
+#define AUDIO_INT                             0x8506
+
+#define ERR_INT                               0x8507
+#define MASK_I_EESS_ERR                       0x80
+
+#define HDCP_INT                              0x8508
+#define MASK_I_AVM_SET                        0x80
+#define MASK_I_AVM_CLR                        0x40
+#define MASK_I_LINKERR                        0x20
+#define MASK_I_SHA_END                        0x10
+#define MASK_I_R0_END                         0x08
+#define MASK_I_KM_END                         0x04
+#define MASK_I_AKSV_END                       0x02
+#define MASK_I_AN_END                         0x01
+
+#define MISC_INT                              0x850B
+#define MASK_I_AS_LAYOUT                      0x10
+#define MASK_I_NO_SPD                         0x08
+#define MASK_I_NO_VS                          0x03
+#define MASK_I_SYNC_CHG                       0x02
+#define MASK_I_AUDIO_MUTE                     0x01
+
+#define KEY_INT                               0x850F
+
+#define SYS_INTM                              0x8512
+#define MASK_M_ACR_CTS                        0x80
+#define MASK_M_ACR_N                          0x40
+#define MASK_M_DVI_DET                        0x20
+#define MASK_M_HDMI_DET                       0x10
+#define MASK_M_NOPMBDET                       0x08
+#define MASK_M_BPMBDET                        0x04
+#define MASK_M_TMDS                           0x02
+#define MASK_M_DDC                            0x01
+
+#define CLK_INTM                              0x8513
+#define MASK_M_OUT_H_CHG                      0x40
+#define MASK_M_IN_DE_CHG                      0x20
+#define MASK_M_IN_HV_CHG                      0x10
+#define MASK_M_DC_CHG                         0x08
+#define MASK_M_PXCLK_CHG                      0x04
+#define MASK_M_PHYCLK_CHG                     0x02
+#define MASK_M_TMDS_CHG                       0x01
+
+#define PACKET_INTM                           0x8514
+
+#define CBIT_INTM                             0x8515
+#define MASK_M_AF_LOCK                        0x80
+#define MASK_M_AF_UNLOCK                      0x40
+#define MASK_M_CBIT_FS                        0x02
+
+#define AUDIO_INTM                            0x8516
+#define MASK_M_BUFINIT_END                    0x01
+
+#define ERR_INTM                              0x8517
+#define MASK_M_EESS_ERR                       0x80
+
+#define HDCP_INTM                             0x8518
+#define MASK_M_AVM_SET                        0x80
+#define MASK_M_AVM_CLR                        0x40
+#define MASK_M_LINKERR                        0x20
+#define MASK_M_SHA_END                        0x10
+#define MASK_M_R0_END                         0x08
+#define MASK_M_KM_END                         0x04
+#define MASK_M_AKSV_END                       0x02
+#define MASK_M_AN_END                         0x01
+
+#define MISC_INTM                             0x851B
+#define MASK_M_AS_LAYOUT                      0x10
+#define MASK_M_NO_SPD                         0x08
+#define MASK_M_NO_VS                          0x03
+#define MASK_M_SYNC_CHG                       0x02
+#define MASK_M_AUDIO_MUTE                     0x01
+
+#define KEY_INTM                              0x851F
+
+#define SYS_STATUS                            0x8520
+#define MASK_S_SYNC                           0x80
+#define MASK_S_AVMUTE                         0x40
+#define MASK_S_HDCP                           0x20
+#define MASK_S_HDMI                           0x10
+#define MASK_S_PHY_SCDT                       0x08
+#define MASK_S_PHY_PLL                        0x04
+#define MASK_S_TMDS                           0x02
+#define MASK_S_DDC5V                          0x01
+
+#define CSI_STATUS                            0x0410
+#define MASK_S_WSYNC                          0x0400
+#define MASK_S_TXACT                          0x0200
+#define MASK_S_RXACT                          0x0100
+#define MASK_S_HLT                            0x0001
+
+#define VI_STATUS1                            0x8522
+#define MASK_S_V_GBD                          0x08
+#define MASK_S_DEEPCOLOR                      0x0c
+#define MASK_S_V_422                          0x02
+#define MASK_S_V_INTERLACE                    0x01
+
+#define AU_STATUS0                            0x8523
+#define MASK_S_A_SAMPLE                       0x01
+
+#define VI_STATUS3                            0x8528
+#define MASK_S_V_COLOR                        0x1e
+#define MASK_LIMITED                          0x01
+
+#define PHY_CTL0                              0x8531
+#define MASK_PHY_SYSCLK_IND                   0x02
+#define MASK_PHY_CTL                          0x01
+
+
+#define PHY_CTL1                              0x8532 /* Not in REF_01 */
+#define MASK_PHY_AUTO_RST1                    0xf0
+#define MASK_PHY_AUTO_RST1_OFF                0x00
+#define SET_PHY_AUTO_RST1_US(us)             ((((us) / 200) << 4) & \
+						MASK_PHY_AUTO_RST1)
+#define MASK_FREQ_RANGE_MODE                  0x0f
+#define SET_FREQ_RANGE_MODE_CYCLES(cycles)   (((cycles) - 1) & \
+						MASK_FREQ_RANGE_MODE)
+
+#define PHY_CTL2                              0x8533 /* Not in REF_01 */
+#define MASK_PHY_AUTO_RST4                    0x04
+#define MASK_PHY_AUTO_RST3                    0x02
+#define MASK_PHY_AUTO_RST2                    0x01
+#define MASK_PHY_AUTO_RSTn                    (MASK_PHY_AUTO_RST4 | \
+						MASK_PHY_AUTO_RST3 | \
+						MASK_PHY_AUTO_RST2)
+
+#define PHY_EN                                0x8534
+#define MASK_ENABLE_PHY                       0x01
+
+#define PHY_RST                               0x8535
+#define MASK_RESET_CTRL                       0x01   /* Reset active low */
+
+#define PHY_BIAS                              0x8536 /* Not in REF_01 */
+
+#define PHY_CSQ                               0x853F /* Not in REF_01 */
+#define MASK_CSQ_CNT                          0x0f
+#define SET_CSQ_CNT_LEVEL(n)                 (n & MASK_CSQ_CNT)
+
+#define SYS_FREQ0                             0x8540
+#define SYS_FREQ1                             0x8541
+
+#define SYS_CLK                               0x8542 /* Not in REF_01 */
+#define MASK_CLK_DIFF                         0x0C
+#define MASK_CLK_DIV                          0x03
+
+#define DDC_CTL                               0x8543
+#define MASK_DDC_ACK_POL                      0x08
+#define MASK_DDC_ACTION                       0x04
+#define MASK_DDC5V_MODE                       0x03
+#define MASK_DDC5V_MODE_0MS                   0x00
+#define MASK_DDC5V_MODE_50MS                  0x01
+#define MASK_DDC5V_MODE_100MS                 0x02
+#define MASK_DDC5V_MODE_200MS                 0x03
+
+#define HPD_CTL                               0x8544
+#define MASK_HPD_CTL0                         0x10
+#define MASK_HPD_OUT0                         0x01
+
+#define ANA_CTL                               0x8545
+#define MASK_APPL_PCSX                        0x30
+#define MASK_APPL_PCSX_HIZ                    0x00
+#define MASK_APPL_PCSX_L_FIX                  0x10
+#define MASK_APPL_PCSX_H_FIX                  0x20
+#define MASK_APPL_PCSX_NORMAL                 0x30
+#define MASK_ANALOG_ON                        0x01
+
+#define AVM_CTL                               0x8546
+
+#define INIT_END                              0x854A
+#define MASK_INIT_END                         0x01
+
+#define HDMI_DET                              0x8552 /* Not in REF_01 */
+#define MASK_HDMI_DET_MOD1                    0x80
+#define MASK_HDMI_DET_MOD0                    0x40
+#define MASK_HDMI_DET_V                       0x30
+#define MASK_HDMI_DET_V_SYNC                  0x00
+#define MASK_HDMI_DET_V_ASYNC_25MS            0x10
+#define MASK_HDMI_DET_V_ASYNC_50MS            0x20
+#define MASK_HDMI_DET_V_ASYNC_100MS           0x30
+#define MASK_HDMI_DET_NUM                     0x0f
+
+#define HDCP_MODE                             0x8560
+#define MASK_MODE_RST_TN                      0x20
+#define MASK_LINE_REKEY                       0x10
+#define MASK_AUTO_CLR                         0x04
+
+#define HDCP_REG1                             0x8563 /* Not in REF_01 */
+#define MASK_AUTH_UNAUTH_SEL                  0x70
+#define MASK_AUTH_UNAUTH_SEL_12_FRAMES        0x70
+#define MASK_AUTH_UNAUTH_SEL_8_FRAMES         0x60
+#define MASK_AUTH_UNAUTH_SEL_4_FRAMES         0x50
+#define MASK_AUTH_UNAUTH_SEL_2_FRAMES         0x40
+#define MASK_AUTH_UNAUTH_SEL_64_FRAMES        0x30
+#define MASK_AUTH_UNAUTH_SEL_32_FRAMES        0x20
+#define MASK_AUTH_UNAUTH_SEL_16_FRAMES        0x10
+#define MASK_AUTH_UNAUTH_SEL_ONCE             0x00
+#define MASK_AUTH_UNAUTH                      0x01
+#define MASK_AUTH_UNAUTH_AUTO                 0x01
+
+#define HDCP_REG2                             0x8564 /* Not in REF_01 */
+#define MASK_AUTO_P3_RESET                    0x0F
+#define SET_AUTO_P3_RESET_FRAMES(n)          (n & MASK_AUTO_P3_RESET)
+#define MASK_AUTO_P3_RESET_OFF                0x00
+
+#define VI_MODE                               0x8570
+#define MASK_RGB_DVI                          0x08 /* Not in REF_01 */
+
+#define VOUT_SET2                             0x8573
+#define MASK_SEL422                           0x80
+#define MASK_VOUT_422FIL_100                  0x40
+#define MASK_VOUTCOLORMODE                    0x03
+#define MASK_VOUTCOLORMODE_THROUGH            0x00
+#define MASK_VOUTCOLORMODE_AUTO               0x01
+#define MASK_VOUTCOLORMODE_MANUAL             0x03
+
+#define VOUT_SET3                             0x8574
+#define MASK_VOUT_EXTCNT                      0x08
+
+#define VI_REP                                0x8576
+#define MASK_VOUT_COLOR_SEL                   0xe0
+#define MASK_VOUT_COLOR_RGB_FULL              0x00
+#define MASK_VOUT_COLOR_RGB_LIMITED           0x20
+#define MASK_VOUT_COLOR_601_YCBCR_FULL        0x40
+#define MASK_VOUT_COLOR_601_YCBCR_LIMITED     0x60
+#define MASK_VOUT_COLOR_709_YCBCR_FULL        0x80
+#define MASK_VOUT_COLOR_709_YCBCR_LIMITED     0xa0
+#define MASK_VOUT_COLOR_FULL_TO_LIMITED       0xc0
+#define MASK_VOUT_COLOR_LIMITED_TO_FULL       0xe0
+#define MASK_IN_REP_HEN                       0x10
+#define MASK_IN_REP                           0x0f
+
+#define VI_MUTE                               0x857F
+#define MASK_AUTO_MUTE                        0xc0
+#define MASK_VI_MUTE                          0x10
+
+#define DE_WIDTH_H_LO                         0x8582 /* Not in REF_01 */
+#define DE_WIDTH_H_HI                         0x8583 /* Not in REF_01 */
+#define DE_WIDTH_V_LO                         0x8588 /* Not in REF_01 */
+#define DE_WIDTH_V_HI                         0x8589 /* Not in REF_01 */
+#define H_SIZE_LO                             0x858A /* Not in REF_01 */
+#define H_SIZE_HI                             0x858B /* Not in REF_01 */
+#define V_SIZE_LO                             0x858C /* Not in REF_01 */
+#define V_SIZE_HI                             0x858D /* Not in REF_01 */
+#define FV_CNT_LO                             0x85A1 /* Not in REF_01 */
+#define FV_CNT_HI                             0x85A2 /* Not in REF_01 */
+
+#define FH_MIN0                               0x85AA /* Not in REF_01 */
+#define FH_MIN1                               0x85AB /* Not in REF_01 */
+#define FH_MAX0                               0x85AC /* Not in REF_01 */
+#define FH_MAX1                               0x85AD /* Not in REF_01 */
+
+#define HV_RST                                0x85AF /* Not in REF_01 */
+#define MASK_H_PI_RST                         0x20
+#define MASK_V_PI_RST                         0x10
+
+#define EDID_MODE                             0x85C7
+#define MASK_EDID_SPEED                       0x40
+#define MASK_EDID_MODE                        0x03
+#define MASK_EDID_MODE_DISABLE                0x00
+#define MASK_EDID_MODE_DDC2B                  0x01
+#define MASK_EDID_MODE_E_DDC                  0x02
+
+#define EDID_LEN1                             0x85CA
+#define EDID_LEN2                             0x85CB
+
+#define HDCP_REG3                             0x85D1 /* Not in REF_01 */
+#define KEY_RD_CMD                            0x01
+
+#define FORCE_MUTE                            0x8600
+#define MASK_FORCE_AMUTE                      0x10
+#define MASK_FORCE_DMUTE                      0x01
+
+#define CMD_AUD                               0x8601
+#define MASK_CMD_BUFINIT                      0x04
+#define MASK_CMD_LOCKDET                      0x02
+#define MASK_CMD_MUTE                         0x01
+
+#define AUTO_CMD0                             0x8602
+#define MASK_AUTO_MUTE7                       0x80
+#define MASK_AUTO_MUTE6                       0x40
+#define MASK_AUTO_MUTE5                       0x20
+#define MASK_AUTO_MUTE4                       0x10
+#define MASK_AUTO_MUTE3                       0x08
+#define MASK_AUTO_MUTE2                       0x04
+#define MASK_AUTO_MUTE1                       0x02
+#define MASK_AUTO_MUTE0                       0x01
+
+#define AUTO_CMD1                             0x8603
+#define MASK_AUTO_MUTE10                      0x04
+#define MASK_AUTO_MUTE9                       0x02
+#define MASK_AUTO_MUTE8                       0x01
+
+#define AUTO_CMD2                             0x8604
+#define MASK_AUTO_PLAY3                       0x08
+#define MASK_AUTO_PLAY2                       0x04
+
+#define BUFINIT_START                         0x8606
+#define SET_BUFINIT_START_MS(milliseconds)   ((milliseconds) / 100)
+
+#define FS_MUTE                               0x8607
+#define MASK_FS_ELSE_MUTE                     0x80
+#define MASK_FS22_MUTE                        0x40
+#define MASK_FS24_MUTE                        0x20
+#define MASK_FS88_MUTE                        0x10
+#define MASK_FS96_MUTE                        0x08
+#define MASK_FS176_MUTE                       0x04
+#define MASK_FS192_MUTE                       0x02
+#define MASK_FS_NO_MUTE                       0x01
+
+#define FS_IMODE                              0x8620
+#define MASK_NLPCM_HMODE                      0x40
+#define MASK_NLPCM_SMODE                      0x20
+#define MASK_NLPCM_IMODE                      0x10
+#define MASK_FS_HMODE                         0x08
+#define MASK_FS_AMODE                         0x04
+#define MASK_FS_SMODE                         0x02
+#define MASK_FS_IMODE                         0x01
+
+#define FS_SET                                0x8621
+#define MASK_FS                               0x0f
+
+#define LOCKDET_REF0                          0x8630
+#define LOCKDET_REF1                          0x8631
+#define LOCKDET_REF2                          0x8632
+
+#define ACR_MODE                              0x8640
+#define MASK_ACR_LOAD                         0x10
+#define MASK_N_MODE                           0x04
+#define MASK_CTS_MODE                         0x01
+
+#define ACR_MDF0                              0x8641
+#define MASK_ACR_L2MDF                        0x70
+#define MASK_ACR_L2MDF_0_PPM                  0x00
+#define MASK_ACR_L2MDF_61_PPM                 0x10
+#define MASK_ACR_L2MDF_122_PPM                0x20
+#define MASK_ACR_L2MDF_244_PPM                0x30
+#define MASK_ACR_L2MDF_488_PPM                0x40
+#define MASK_ACR_L2MDF_976_PPM                0x50
+#define MASK_ACR_L2MDF_1976_PPM               0x60
+#define MASK_ACR_L2MDF_3906_PPM               0x70
+#define MASK_ACR_L1MDF                        0x07
+#define MASK_ACR_L1MDF_0_PPM                  0x00
+#define MASK_ACR_L1MDF_61_PPM                 0x01
+#define MASK_ACR_L1MDF_122_PPM                0x02
+#define MASK_ACR_L1MDF_244_PPM                0x03
+#define MASK_ACR_L1MDF_488_PPM                0x04
+#define MASK_ACR_L1MDF_976_PPM                0x05
+#define MASK_ACR_L1MDF_1976_PPM               0x06
+#define MASK_ACR_L1MDF_3906_PPM               0x07
+
+#define ACR_MDF1                              0x8642
+#define MASK_ACR_L3MDF                        0x07
+#define MASK_ACR_L3MDF_0_PPM                  0x00
+#define MASK_ACR_L3MDF_61_PPM                 0x01
+#define MASK_ACR_L3MDF_122_PPM                0x02
+#define MASK_ACR_L3MDF_244_PPM                0x03
+#define MASK_ACR_L3MDF_488_PPM                0x04
+#define MASK_ACR_L3MDF_976_PPM                0x05
+#define MASK_ACR_L3MDF_1976_PPM               0x06
+#define MASK_ACR_L3MDF_3906_PPM               0x07
+
+#define SDO_MODE1                             0x8652
+#define MASK_SDO_BIT_LENG                     0x70
+#define MASK_SDO_FMT                          0x03
+#define MASK_SDO_FMT_RIGHT                    0x00
+#define MASK_SDO_FMT_LEFT                     0x01
+#define MASK_SDO_FMT_I2S                      0x02
+
+#define DIV_MODE                              0x8665 /* Not in REF_01 */
+#define MASK_DIV_DLY                          0xf0
+#define SET_DIV_DLY_MS(milliseconds)         ((((milliseconds) / 100) << 4) & \
+						MASK_DIV_DLY)
+#define MASK_DIV_MODE                         0x01
+
+#define NCO_F0_MOD                            0x8670
+#define MASK_NCO_F0_MOD                       0x03
+#define MASK_NCO_F0_MOD_42MHZ                 0x00
+#define MASK_NCO_F0_MOD_27MHZ                 0x01
+
+#define PK_INT_MODE                           0x8709
+#define MASK_ISRC2_INT_MODE                   0x80
+#define MASK_ISRC_INT_MODE                    0x40
+#define MASK_ACP_INT_MODE                     0x20
+#define MASK_VS_INT_MODE                      0x10
+#define MASK_SPD_INT_MODE                     0x08
+#define MASK_MS_INT_MODE                      0x04
+#define MASK_AUD_INT_MODE                     0x02
+#define MASK_AVI_INT_MODE                     0x01
+
+#define NO_PKT_LIMIT                          0x870B
+#define MASK_NO_ACP_LIMIT                     0xf0
+#define SET_NO_ACP_LIMIT_MS(milliseconds)    ((((milliseconds) / 80) << 4) & \
+						MASK_NO_ACP_LIMIT)
+#define MASK_NO_AVI_LIMIT                     0x0f
+#define SET_NO_AVI_LIMIT_MS(milliseconds)    (((milliseconds) / 80) & \
+						MASK_NO_AVI_LIMIT)
+
+#define NO_PKT_CLR                            0x870C
+#define MASK_NO_VS_CLR                        0x40
+#define MASK_NO_SPD_CLR                       0x20
+#define MASK_NO_ACP_CLR                       0x10
+#define MASK_NO_AVI_CLR1                      0x02
+#define MASK_NO_AVI_CLR0                      0x01
+
+#define ERR_PK_LIMIT                          0x870D
+#define NO_PKT_LIMIT2                         0x870E
+#define PK_AVI_0HEAD                          0x8710
+#define PK_AVI_1HEAD                          0x8711
+#define PK_AVI_2HEAD                          0x8712
+#define PK_AVI_0BYTE                          0x8713
+#define PK_AVI_1BYTE                          0x8714
+#define PK_AVI_2BYTE                          0x8715
+#define PK_AVI_3BYTE                          0x8716
+#define PK_AVI_4BYTE                          0x8717
+#define PK_AVI_5BYTE                          0x8718
+#define PK_AVI_6BYTE                          0x8719
+#define PK_AVI_7BYTE                          0x871A
+#define PK_AVI_8BYTE                          0x871B
+#define PK_AVI_9BYTE                          0x871C
+#define PK_AVI_10BYTE                         0x871D
+#define PK_AVI_11BYTE                         0x871E
+#define PK_AVI_12BYTE                         0x871F
+#define PK_AVI_13BYTE                         0x8720
+#define PK_AVI_14BYTE                         0x8721
+#define PK_AVI_15BYTE                         0x8722
+#define PK_AVI_16BYTE                         0x8723
+
+#define BKSV                                  0x8800
+
+#define BCAPS                                 0x8840
+#define MASK_HDMI_RSVD                        0x80
+#define MASK_REPEATER                         0x40
+#define MASK_READY                            0x20
+#define MASK_FASTI2C                          0x10
+#define MASK_1_1_FEA                          0x02
+#define MASK_FAST_REAU                        0x01
+
+#define BSTATUS1                              0x8842
+#define MASK_MAX_EXCED                        0x08
+
+#define EDID_RAM                              0x8C00
+#define NO_GDB_LIMIT                          0x9007
+
+#endif
\ No newline at end of file
diff --git a/include/media/tegra_camera_core.h b/include/media/tegra_camera_core.h
new file mode 100644
index 0000000..0371e07
--- /dev/null
+++ b/include/media/tegra_camera_core.h
@@ -0,0 +1,135 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * NVIDIA Tegra Video Input Device Driver Core Helpers
+ *
+ * Copyright (c) 2015-2022, NVIDIA CORPORATION.  All rights reserved.
+ */
+
+#ifndef __TEGRA_CORE_H__
+#define __TEGRA_CORE_H__
+
+#include <media/v4l2-subdev.h>
+
+/* Minimum and maximum width and height common to Tegra video input device. */
+#define TEGRA_MIN_WIDTH		32U
+#define TEGRA_MAX_WIDTH		32768U
+#define TEGRA_MIN_HEIGHT	32U
+#define TEGRA_MAX_HEIGHT	32768U
+/* Width alignment */
+#define TEGRA_WIDTH_ALIGNMENT	1
+/* Stride alignment */
+#define TEGRA_STRIDE_ALIGNMENT	64
+/* Height alignment */
+#define TEGRA_HEIGHT_ALIGNMENT	1
+/* Size alignment */
+#define TEGRA_SIZE_ALIGNMENT	0
+
+/* 1080p resolution as default resolution for test pattern generator */
+#define TEGRA_DEF_WIDTH		1920
+#define TEGRA_DEF_HEIGHT	1080
+
+#define TEGRA_VF_DEF		MEDIA_BUS_FMT_SRGGB10_1X10
+#define TEGRA_IMAGE_FORMAT_DEF	32
+
+#ifndef V4L2_PIX_FMT_AVT_G4C2
+#define V4L2_PIX_FMT_AVT_G4C2    v4l2_fourcc('T', 'P', '3', '1') /* 0x31 mipi datatype  */
+#endif
+
+#ifndef MEDIA_BUS_FMT_AVT_G4C2_1X8
+#define MEDIA_BUS_FMT_AVT_G4C2_1X8	0x5002
+#endif
+
+
+enum tegra_image_dt {
+	TEGRA_IMAGE_DT_YUV420_8 = 24,
+	TEGRA_IMAGE_DT_YUV420_10,
+
+	TEGRA_IMAGE_DT_YUV420CSPS_8 = 28,
+	TEGRA_IMAGE_DT_YUV420CSPS_10,
+	TEGRA_IMAGE_DT_YUV422_8,
+	TEGRA_IMAGE_DT_YUV422_10,
+	TEGRA_IMAGE_DT_RGB444,
+	TEGRA_IMAGE_DT_RGB555,
+	TEGRA_IMAGE_DT_RGB565,
+	TEGRA_IMAGE_DT_RGB666,
+	TEGRA_IMAGE_DT_RGB888,
+
+	TEGRA_IMAGE_DT_RAW6 = 40,
+	TEGRA_IMAGE_DT_RAW7,
+	TEGRA_IMAGE_DT_RAW8,
+	TEGRA_IMAGE_DT_RAW10,
+	TEGRA_IMAGE_DT_RAW12,
+	TEGRA_IMAGE_DT_RAW14,
+};
+
+/* Supported CSI to VI Data Formats */
+enum tegra_vf_code {
+	TEGRA_VF_RAW6 = 0,
+	TEGRA_VF_RAW7,
+	TEGRA_VF_RAW8,
+	TEGRA_VF_RAW10,
+	TEGRA_VF_RAW12,
+	TEGRA_VF_RAW14,
+	TEGRA_VF_EMBEDDED8,
+	TEGRA_VF_RGB565,
+	TEGRA_VF_RGB555,
+	TEGRA_VF_RGB888,
+	TEGRA_VF_RGB444,
+	TEGRA_VF_RGB666,
+	TEGRA_VF_YUV422,
+	TEGRA_VF_YUV420,
+	TEGRA_VF_YUV420_CSPS,
+};
+
+/**
+ * struct tegra_frac
+ * @numerator: numerator of the fraction
+ * @denominator: denominator of the fraction
+ */
+struct tegra_frac {
+	unsigned int numerator;
+	unsigned int denominator;
+};
+
+/**
+ * struct tegra_video_format - Tegra video format description
+ * @vf_code: video format code
+ * @width: format width in bits per component
+ * @code: media bus format code
+ * @bpp: bytes per pixel fraction (when stored in memory)
+ * @img_fmt: image format
+ * @img_dt: image data type
+ * @fourcc: V4L2 pixel format FCC identifier
+ * @description: format description, suitable for userspace
+ */
+struct tegra_video_format {
+	enum tegra_vf_code vf_code;
+	unsigned int width;
+	unsigned int code;
+	struct tegra_frac bpp;
+	u32 img_fmt;
+	enum tegra_image_dt img_dt;
+	u32 fourcc;
+	__u8 description[32];
+};
+
+#define	TEGRA_VIDEO_FORMAT(VF_CODE, BPP, MBUS_CODE, FRAC_BPP_NUM,	\
+	FRAC_BPP_DEN, FORMAT, DATA_TYPE, FOURCC, DESCRIPTION)		\
+{									\
+	TEGRA_VF_##VF_CODE,						\
+	BPP,								\
+	MEDIA_BUS_FMT_##MBUS_CODE,					\
+	{FRAC_BPP_NUM, FRAC_BPP_DEN},					\
+	TEGRA_IMAGE_FORMAT_##FORMAT,					\
+	TEGRA_IMAGE_DT_##DATA_TYPE,					\
+	V4L2_PIX_FMT_##FOURCC,						\
+	DESCRIPTION,							\
+}
+
+u32 tegra_core_get_word_count(unsigned int frame_width,
+		const struct tegra_video_format *fmt);
+u32 tegra_core_bytes_per_line(unsigned int width, unsigned int align,
+		const struct tegra_video_format *fmt);
+const struct tegra_video_format *tegra_core_get_default_format(void);
+
+#endif
diff --git a/include/uapi/linux/avt-csi2.h b/include/uapi/linux/avt-csi2.h
new file mode 100644
index 0000000..6379649
--- /dev/null
+++ b/include/uapi/linux/avt-csi2.h
@@ -0,0 +1,100 @@
+// SPDX-License-Identifier: GPL-2.0-or-later WITH Linux-syscall-note
+/* 
+ * Allied Vision Alvium camera driver
+ * 
+ * Copyright (C) 2024 Allied Vision Technologies GmbH
+ */
+
+
+#ifndef LINUX_AVT_CSI_H
+#define LINUX_AVT_CSI_H
+
+#include <linux/videodev2.h>
+
+// TODO: Maybe define a more suitable base address like e.g. 0xf000
+#define AVT_CID_CAMERA_BASE V4L2_CID_CAMERA_CLASS_BASE + 40
+
+#define AVT_CID_EXPOSURE_AUTO_MIN		 (AVT_CID_CAMERA_BASE + 0)
+#define AVT_CID_EXPOSURE_AUTO_MAX		 (AVT_CID_CAMERA_BASE + 1)
+#define AVT_CID_GAIN_AUTO_MIN			 (AVT_CID_CAMERA_BASE + 2)
+#define AVT_CID_GAIN_AUTO_MAX			 (AVT_CID_CAMERA_BASE + 3)
+#define AVT_CID_EXPOSURE_ACTIVE_LINE_MODE	 (AVT_CID_CAMERA_BASE + 4)
+#define AVT_CID_EXPOSURE_ACTIVE_LINE_SELECTOR	 (AVT_CID_CAMERA_BASE + 5)
+enum avt_exposure_active_line {
+	AVT_EXPOSURE_ACTIVE_LINE0 = 0,
+	AVT_EXPOSURE_ACTIVE_LINE1 = 1,
+	AVT_EXPOSURE_ACTIVE_LINE2 = 2,
+	AVT_EXPOSURE_ACTIVE_LINE3 = 3,
+};
+#define AVT_CID_EXPOSURE_ACTIVE_INVERT		 (AVT_CID_CAMERA_BASE + 6)
+#define AVT_CID_TRIGGER_MODE			 (AVT_CID_CAMERA_BASE + 7)
+#define AVT_CID_TRIGGER_ACTIVATION		 (AVT_CID_CAMERA_BASE + 8)
+enum avt_trigger_activation {
+	AVT_TRIGGER_ACTIVATION_RISING_EDGE	= 0,
+	AVT_TRIGGER_ACTIVATION_FALLING_EDGE	= 1,
+	AVT_TRIGGER_ACTIVATION_ANY_EDGE		= 2,
+	AVT_TRIGGER_ACTIVATION_LEVEL_HIGH	= 3,
+	AVT_TRIGGER_ACTIVATION_LEVEL_LOW	= 4,
+};
+#define AVT_CID_TRIGGER_SOURCE			 (AVT_CID_CAMERA_BASE + 9)
+enum avt_trigger_source {
+	AVT_TRIGGER_SOURCE_LINE0 	= 0,
+	AVT_TRIGGER_SOURCE_LINE1 	= 1,
+	AVT_TRIGGER_SOURCE_LINE2 	= 2,
+	AVT_TRIGGER_SOURCE_LINE3 	= 3,
+	AVT_TRIGGER_SOURCE_SOFTWARE 	= 4,
+};
+#define AVT_CID_TRIGGER_SOFTWARE		 (AVT_CID_CAMERA_BASE + 10)
+#define AVT_CID_DEVICE_TEMPERATURE		 (AVT_CID_CAMERA_BASE + 11)
+#define AVT_CID_BINNING_MODE			 (AVT_CID_CAMERA_BASE + 12)
+enum avt_binning_mode {
+	AVT_BINNING_MODE_AVG = 0,
+	AVT_BINNING_MODE_SUM = 1,
+};
+#define AVT_CID_BINNING_SETTING			 (AVT_CID_CAMERA_BASE + 13)
+#define AVT_CID_FIRMWARE_VERSION		 (AVT_CID_CAMERA_BASE + 14)
+#define AVT_CID_CAMERA_NAME			 (AVT_CID_CAMERA_BASE + 15)
+#define AVT_CID_SERIAL_NUMBER			 (AVT_CID_CAMERA_BASE + 16)
+#define AVT_CID_ACQUISITION_STATUS		 (AVT_CID_CAMERA_BASE + 17)
+#define AVT_CID_BINNING_SELECTOR		 (AVT_CID_CAMERA_BASE + 18)
+enum avt_binning_selector {
+	AVT_BINNING_DIGITAL = 0,
+	AVT_BINNING_SENSOR  = 1,
+};
+#define AVT_CID_INTENSITY_AUTO_PRECEDENCE	 (AVT_CID_CAMERA_BASE + 19)
+enum avt_intensity_auto_precedence {
+	AVT_INTENSITY_AUTO_PRECEDENCE_MINIMIZE_NOISE	= 0,
+	AVT_INTENSITY_AUTO_PRECEDENCE_MINIMIZE_BLUR	= 1,
+	AVT_INTENSITY_AUTO_PRECEDENCE_MAXIMIZE_DOF	= 2,
+};
+#define AVT_CID_INTENSITY_AUTO_PRECEDENCE_TARGET (AVT_CID_CAMERA_BASE + 20)
+#define AVT_CID_TEST_PATTERN			 (AVT_CID_CAMERA_BASE + 21)
+enum avt_test_pattern {
+	AVT_TEST_PATTERN_OFF			= 0,
+	AVT_TEST_PATTERN_BLACK			= 1,
+	AVT_TEST_PATTERN_WHITE			= 2,
+	AVT_TEST_PATTERN_GREY			= 3,
+	AVT_TEST_PATTERN_RED			= 4,
+	AVT_TEST_PATTERN_GREEN			= 5,
+	AVT_TEST_PATTERN_BLUE			= 6,
+	AVT_TEST_PATTERN_COLOR_HBAR		= 7,
+	AVT_TEST_PATTERN_COLOR_VBAR		= 8,
+	AVT_TEST_PATTERN_COLOR_VBAR_FADE_GREY	= 9,
+	AVT_TEST_PATTERN_GREY_ALT_STRIPE	= 10,
+	AVT_TEST_PATTERN_GREY_ALT_PIXEL		= 11,
+	AVT_TEST_PATTERN_GREY_VBAR1		= 12,
+	AVT_TEST_PATTERN_GREY_VBAR2		= 13,
+	AVT_TEST_PATTERN_GREY_HRAMP		= 14,
+	AVT_TEST_PATTERN_GREY_DRAMP		= 15,
+	AVT_TEST_PATTERN_GREY_DRAMP_MOVING	= 16,
+};
+#define AVT_CID_DO_AUTO_EXPOSURE		 (AVT_CID_CAMERA_BASE + 22)
+
+struct avt_i2c_xfer {
+    __u16 addr;
+    __u16 len;
+    __u8  rd;
+    __u8  reserved[3];
+} __attribute__((packed));
+
+#endif /* LINUX_AVT_CSI_H */
diff --git a/nvidia-oot/drivers/media/i2c/Makefile b/nvidia-oot/drivers/media/i2c/Makefile
index a85d6e8..17c6078 100644
--- a/nvidia-oot/drivers/media/i2c/Makefile
+++ b/nvidia-oot/drivers/media/i2c/Makefile
@@ -21,6 +21,7 @@ obj-m += nv_ov5693.o
 obj-m += nv_ar0234.o
 obj-m += nv_hawk_owl.o
 obj-m += max929x.o
+obj-m += tc358743.o
 endif
 
 obj-m += pca9570.o
diff --git a/nvidia-oot/drivers/media/i2c/tc358743.c b/nvidia-oot/drivers/media/i2c/tc358743.c
new file mode 100644
index 0000000..1ddc140
--- /dev/null
+++ b/nvidia-oot/drivers/media/i2c/tc358743.c
@@ -0,0 +1,2383 @@
+/*
+ * References (c = chapter, p = page):
+ * REF_01 - Toshiba, TC358743XBG (H2C), Functional Specification, Rev 0.60
+ * REF_02 - Toshiba, TC358743XBG_HDMI-CSI_Tv11p_nm.xls
+ */
+#define DEBUG
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/hdmi.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/v4l2-dv-timings.h>
+#include <linux/videodev2.h>
+#include <linux/workqueue.h>
+#include <linux/gpio.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/of_graph.h>
+#include <linux/seq_file.h>
+#include <linux/fs.h>
+#include <linux/i2c-dev.h>
+
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-dv-timings.h>
+#include <media/v4l2-event.h>
+
+// OOT
+#include <media/camera_common.h>
+#include <media/tegra-v4l2-camera.h>
+
+#include <dt-bindings/gpio/tegra-gpio.h>
+
+#include <media/tc358743.h>
+
+/* RGB ouput selection */
+// #define TC358743_VOUT_RGB
+
+static int debug = 3;
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "debug level (0-3)");
+
+MODULE_DESCRIPTION("Toshiba TC358743 HDMI to CSI-2 bridge driver");
+MODULE_AUTHOR("Ramakrishnan Muthukrishnan <ram@rkrishnan.org>");
+MODULE_AUTHOR("Mikhail Khelik <mkhelik@cisco.com>");
+MODULE_AUTHOR("Mats Randgaard <matrandg@cisco.com>");
+MODULE_LICENSE("GPL");
+
+#define DELAY_ENABLE_INTERRUPT_MS 2000
+
+/* mode */
+enum {
+  tc358743_MODE_1280X720,
+  tc358743_MODE_1920X1080,
+};
+
+/* frame rate */
+static const int tc358743_30_60fps[] = {
+    30,
+    50,
+    60,
+};
+
+/* frame format */
+static const struct camera_common_frmfmt tc358743_frmfmt[] = {
+    {{1280, 720}, tc358743_30_60fps, 3, 0, tc358743_MODE_1280X720},
+    {{1920, 1080}, tc358743_30_60fps, 3, 0, tc358743_MODE_1920X1080},
+};
+
+// static const struct camera_common_colorfmt tc358743_color_fmts[] = {
+// 	{
+// 		MEDIA_BUS_FMT_SRGGB12_1X12,
+// 		V4L2_COLORSPACE_SRGB,
+// 		V4L2_PIX_FMT_SRGGB12,
+// 	},
+// 	{
+// 		MEDIA_BUS_FMT_UYVY8_1X16,
+// 		V4L2_COLORSPACE_SRGB,
+// 		V4L2_PIX_FMT_UYVY,
+// 	},
+// };
+
+#define EDID_NUM_BLOCKS_MAX 8
+#define EDID_BLOCK_SIZE 128
+static u8 edid[] = {
+
+    // #ifdef TC358743_VOUT_RGB
+    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x50, 0x21, 0x9C, 0x27,
+    0x00, 0x00, 0x00, 0x00, 0x19, 0x12, 0x01, 0x03, 0x80, 0x00, 0x00, 0x78,
+    0x0E, 0x00, 0xB2, 0xA0, 0x57, 0x49, 0x9B, 0x26, 0x10, 0x48, 0x4F, 0x2F,
+    0xCF, 0x00, 0x31, 0x59, 0x45, 0x59, 0x61, 0x59, 0x81, 0x99, 0x01, 0x01,
+    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x3A, 0x80, 0x18, 0x71, 0x38,
+    0x2D, 0x40, 0x58, 0x2C, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1E,
+    0x00, 0x00, 0x00, 0xFD, 0x00, 0x31, 0x55, 0x18, 0x5E, 0x11, 0x00, 0x0A,
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x54,
+    0x6F, 0x73, 0x68, 0x69, 0x62, 0x61, 0x2D, 0x48, 0x32, 0x43, 0x0A, 0x20,
+    0x00, 0x00, 0x00, 0xFD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc3, 0x02, 0x03, 0x1a, 0xc0,
+    0x48, 0xa2, 0x10, 0x04, 0x02, 0x01, 0x21, 0x14, 0x13, 0x23, 0x09, 0x07,
+    0x07, 0x65, 0x03, 0x0c, 0x00, 0x10, 0x00, 0xe2, 0x00, 0x2a, 0x01, 0x1d,
+    0x00, 0x80, 0x51, 0xd0, 0x1c, 0x20, 0x40, 0x80, 0x35, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x1e, 0x8c, 0x0a, 0xd0, 0x8a, 0x20, 0xe0, 0x2d, 0x10,
+    0x10, 0x3e, 0x96, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0xd7
+    // #else
+    // 0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,
+    // 0x52,0x62,0x88,0x88,0x00,0x88,0x88,0x88,
+    // 0x1C,0x15,0x01,0x03,0x80,0x00,0x00,0x78,
+    // 0x0A,0x0D,0xC9,0xA0,0x57,0x47,0x98,0x27,
+    // 0x12,0x48,0x4C,0x00,0x00,0x00,0x01,0x01,
+    // 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
+    // 0x01,0x01,0x01,0x01,0x01,0x01,0x02,0x3A,
+    // 0x80,0xD0,0x72,0x38,0x2D,0x40,0x10,0x2C,
+    // 0x45,0x80,0x66,0x4C,0x00,0x00,0x00,0x1E,
+    // 0x01,0x1D,0x00,0xBC,0x52,0xD0,0x1E,0x20,
+    // 0xB8,0x28,0x55,0x40,0x66,0x4C,0x00,0x00,
+    // 0x00,0x1E,0x00,0x00,0x00,0xFC,0x00,0x54,
+    // 0x6F,0x73,0x68,0x69,0x62,0x61,0x2D,0x48,
+    // 0x32,0x43,0x0A,0x20,0x00,0x00,0x00,0xFD,
+    // 0x00,0x14,0x78,0x01,0xFF,0x10,0x00,0x0A,
+    // 0x20,0x20,0x20,0x20,0x20,0x20,0x00,0xBA,
+    // 0x02,0x03,0x1A,0x71,0x47,0x9F,0x13,0x22,
+    // 0x1F,0x02,0x11,0x1F,0x23,0x09,0x07,0x01,
+    // 0x83,0x01,0x00,0x00,0x65,0x03,0x0C,0x00,
+    // 0x10,0x00,0x01,0x1D,0x80,0x18,0x71,0x38,
+    // 0x2D,0x40,0x58,0x2C,0x45,0x00,0x66,0x4C,
+    // 0x00,0x00,0x00,0x1E,0x02,0x3A,0x80,0xD0,
+    // 0x72,0x38,0x2D,0x40,0x10,0x2C,0x45,0x80,
+    // 0x66,0x4C,0x00,0x00,0x00,0x1E,0x8C,0x0A,
+    // 0xD0,0x8A,0x20,0xE0,0x2D,0x10,0x10,0x3E,
+    // 0x96,0x00,0x66,0x4C,0x00,0x00,0x00,0x18,
+    // 0x8C,0x0A,0xD0,0x90,0x20,0x40,0x31,0x20,
+    // 0x0C,0x40,0x55,0x00,0x66,0x4C,0x00,0x00,
+    // 0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00,
+    // 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    // 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    // 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,
+    // #endif
+};
+/* Max transfer size done by I2C transfer functions */
+#define MAX_XFER_SIZE (EDID_NUM_BLOCKS_MAX * EDID_BLOCK_SIZE + 2)
+
+static const struct v4l2_dv_timings_cap tc358743_timings_cap = {
+    .type = V4L2_DV_BT_656_1120,
+    /* keep this initialization for compatibility with GCC < 4.4.6 */
+    .reserved = {0},
+    /* Pixel clock from REF_01 p. 20. Min/max height/width are unknown */
+    V4L2_INIT_BT_TIMINGS(1, 10000, 1, 10000, 0, 165000000,
+                         V4L2_DV_BT_STD_CEA861 | V4L2_DV_BT_STD_DMT |
+                             V4L2_DV_BT_STD_GTF | V4L2_DV_BT_STD_CVT,
+                         V4L2_DV_BT_CAP_PROGRESSIVE |
+                             V4L2_DV_BT_CAP_REDUCED_BLANKING |
+                             V4L2_DV_BT_CAP_CUSTOM)};
+
+struct tc358743_state {
+  struct tc358743_platform_data pdata;
+  // struct v4l2_of_bus_mipi_csi2 bus;
+  struct v4l2_subdev sd;
+  struct media_pad pad;
+  struct v4l2_ctrl_handler hdl;
+  struct i2c_client *i2c_client;
+  struct regmap *regmap;
+  /* CONFCTL is modified in ops and tc358743_hdmi_sys_int_handler */
+  struct mutex confctl_mutex;
+
+  /* controls */
+  struct v4l2_ctrl *detect_tx_5v_ctrl;
+  struct v4l2_ctrl *audio_sampling_rate_ctrl;
+  struct v4l2_ctrl *audio_present_ctrl;
+
+  /* work queues */
+  struct workqueue_struct *work_queues;
+  struct delayed_work delayed_work_enable_hotplug;
+  struct delayed_work delayed_work_enable_interrupt;
+  struct work_struct process_isr;
+  struct mutex isr_lock;
+
+  /* edid  */
+  u8 edid_blocks_written;
+
+  /* used by i2c_wr() */
+  u8 wr_data[MAX_XFER_SIZE];
+
+  struct v4l2_dv_timings timings;
+  u32 mbus_fmt_code;
+
+  struct gpio_desc *reset_gpio;
+};
+
+static inline struct tc358743_state *to_state(struct v4l2_subdev *sd) {
+  return container_of(sd, struct tc358743_state, sd);
+}
+/*
+static char * sdo_bit_len [] = {
+    [0b000] = "16bit (lower 8bit discarded)",
+    [0b001] = "16bit (lower 8bit + 1 discarded)",
+    [0b010] = "18bit (lower 6bit discarded)",
+    [0b011] = "18bit (lower 6bit + 1 discarded)",
+    [0b100] = "20bit (lower 4bit discarded)",
+    [0b101] = "20bit (lower 4bit + 1 discarded)",
+    [0b110] = "24bit no rounding",
+    [0b111] = "Output OFF (Mute)",
+};
+
+static char * sdo_fmt [] = {
+    [MASK_SDO_FMT_RIGHT] = "Right justified",
+    [MASK_SDO_FMT_LEFT] = "Left justified",
+    [MASK_SDO_FMT_I2S] = "I2S",
+    [0b011] = "I2S",
+};
+
+static char * no_yes [] = {
+    [0] = "No",
+    [1] = "Yes",
+};
+
+static char * no_with [] = {
+    [0] = "No",
+    [1] = "With",
+};
+
+static char * off_on [] = {
+    [0b000] = "Off",
+    [0b001] = "On",
+};
+
+static char * audout_sel [] = {
+    [0b00] = "CSI2-TX",
+    [0b01] = "Reseved",
+    [0b10] = "I2S",
+    [0b11] = "TDM",
+};
+*/
+/* --------------- I2C --------------- */
+static int i2c_rd(struct v4l2_subdev *sd, u16 reg, u8 *values, u32 n) {
+  struct tc358743_state *state = to_state(sd);
+  struct i2c_client *client = state->i2c_client;
+  int err;
+  u8 buf[2] = {reg >> 8, reg & 0xff};
+  struct i2c_msg msgs[] = {
+      {
+          .addr = client->addr,
+          .flags = 0,
+          .len = 2,
+          .buf = buf,
+      },
+      {
+          .addr = client->addr,
+          .flags = I2C_M_RD,
+          .len = n,
+          .buf = values,
+      },
+  };
+
+  err = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
+  if (err != ARRAY_SIZE(msgs)) {
+    v4l2_err(sd, "%s: #### reading register0x%x from0x%x failed\n", __func__,
+             reg, client->addr);
+    return -1;
+  }
+  // udelay(10);
+  return 0;
+}
+
+static int i2c_wr(struct v4l2_subdev *sd, u16 reg, u8 *values, u32 n) {
+  struct tc358743_state *state = to_state(sd);
+  struct i2c_client *client = state->i2c_client;
+  u8 *data = state->wr_data;
+  int err, i;
+  struct i2c_msg msg;
+
+  if ((2 + n) > sizeof(state->wr_data)) {
+    v4l2_warn(sd, "i2c wr reg=%04x: len=%d is too big!\n", reg, 2 + n);
+    return -1;
+  }
+
+  msg.addr = client->addr;
+  msg.buf = data;
+  msg.len = 2 + n;
+  msg.flags = 0;
+
+  data[0] = reg >> 8;
+  data[1] = reg & 0xff;
+
+  for (i = 0; i < n; i++) data[2 + i] = values[i];
+
+  err = i2c_transfer(client->adapter, &msg, 1);
+  if (err != 1) {
+    v4l2_err(sd, "%s: writing register0x%x from0x%x failed\n", __func__, reg,
+             client->addr);
+    return -1;
+  }
+  return 0;
+}
+
+static u8 i2c_rd8(struct v4l2_subdev *sd, u16 reg) {
+  u8 val;
+
+  i2c_rd(sd, reg, &val, 1);
+
+  return val;
+}
+
+static void i2c_wr8(struct v4l2_subdev *sd, u16 reg, u8 val) {
+  i2c_wr(sd, reg, &val, 1);
+}
+
+static void i2c_wr8_and_or(struct v4l2_subdev *sd, u16 reg, u8 mask, u8 val) {
+  i2c_wr8(sd, reg, (i2c_rd8(sd, reg) & mask) | val);
+}
+
+static u16 i2c_rd16(struct v4l2_subdev *sd, u16 reg) {
+  u16 val;
+  int ret;
+  // v4l2_info(sd, "Reading i2c_rd16\n");
+
+  ret = i2c_rd(sd, reg, (u8 *)&val, 2);
+  // v4l2_info(sd, "RET %d\n", ret);
+
+  if (ret == -1) {
+    // Read failed
+    return 99;  // TODO. Make this better!
+  }
+
+  return val;
+}
+
+static void i2c_wr16(struct v4l2_subdev *sd, u16 reg, u16 val) {
+  i2c_wr(sd, reg, (u8 *)&val, 2);
+}
+
+static void i2c_wr16_and_or(struct v4l2_subdev *sd, u16 reg, u16 mask,
+                            u16 val) {
+  i2c_wr16(sd, reg, (i2c_rd16(sd, reg) & mask) | val);
+}
+
+static u32 i2c_rd32(struct v4l2_subdev *sd, u16 reg) {
+  u32 val;
+
+  i2c_rd(sd, reg, (u8 *)&val, 4);
+
+  return val;
+}
+
+static void i2c_wr32(struct v4l2_subdev *sd, u16 reg, u32 val) {
+  i2c_wr(sd, reg, (u8 *)&val, 4);
+}
+/* --------------- STATUS --------------- */
+
+static inline bool is_hdmi(struct v4l2_subdev *sd) {
+  v4l2_info(sd, "function %s\n", __func__);
+
+  return i2c_rd8(sd, SYS_STATUS) & MASK_S_HDMI;
+}
+
+static inline bool tx_5v_power_present(struct v4l2_subdev *sd) {
+  v4l2_info(sd, "function %s\n", __func__);
+  return i2c_rd8(sd, SYS_STATUS) & MASK_S_DDC5V;
+}
+
+static inline bool no_signal(struct v4l2_subdev *sd) {
+  v4l2_info(sd, "function %s\n", __func__);
+  return !(i2c_rd8(sd, SYS_STATUS) & MASK_S_TMDS);
+}
+
+static inline bool no_sync(struct v4l2_subdev *sd) {
+  v4l2_info(sd, "function %s\n", __func__);
+  return !(i2c_rd8(sd, SYS_STATUS) & MASK_S_SYNC);
+}
+
+static inline bool audio_present(struct v4l2_subdev *sd) {
+  v4l2_info(sd, "function %s\n", __func__);
+  return i2c_rd8(sd, AU_STATUS0) & MASK_S_A_SAMPLE;
+}
+
+static int get_audio_sampling_rate(struct v4l2_subdev *sd) {
+  static const int code_to_rate[] = {
+      44100, 0,      48000, 32000,  22050,  384000, 24000,  352800,
+      88200, 768000, 96000, 705600, 176400, 0,      192000, 0};
+  v4l2_info(sd, "function %s\n", __func__);
+  /* Register FS_SET is not cleared when the cable is disconnected */
+  if (no_signal(sd)) return 0;
+
+  return code_to_rate[i2c_rd8(sd, FS_SET) & MASK_FS];
+}
+
+static unsigned tc358743_num_csi_lanes_in_use(struct v4l2_subdev *sd) {
+  v4l2_info(sd, "function %s\n", __func__);
+  return ((i2c_rd32(sd, CSI_CONTROL) & MASK_NOL) >> 1) + 1;
+}
+
+/* --------------- TIMINGS --------------- */
+
+static inline unsigned fps(const struct v4l2_bt_timings *t) {
+  if (!V4L2_DV_BT_FRAME_HEIGHT(t) || !V4L2_DV_BT_FRAME_WIDTH(t)) return 0;
+
+  return DIV_ROUND_CLOSEST(
+      (unsigned)t->pixelclock,
+      V4L2_DV_BT_FRAME_HEIGHT(t) * V4L2_DV_BT_FRAME_WIDTH(t));
+}
+
+static int tc358743_get_detected_timings(struct v4l2_subdev *sd,
+                                         struct v4l2_dv_timings *timings) {
+  struct v4l2_bt_timings *bt = &timings->bt;
+  unsigned width, height, frame_width, frame_height, frame_interval, fps;
+
+  memset(timings, 0, sizeof(struct v4l2_dv_timings));
+
+  if (no_signal(sd)) {
+    v4l2_info(sd, "%s: no valid signal\n", __func__);
+    return -ENOLINK;
+  }
+  if (no_sync(sd)) {
+    v4l2_info(sd, "%s: no sync on signal\n", __func__);
+    return -ENOLCK;
+  }
+
+  timings->type = V4L2_DV_BT_656_1120;
+  bt->interlaced = i2c_rd8(sd, VI_STATUS1) & MASK_S_V_INTERLACE
+                       ? V4L2_DV_INTERLACED
+                       : V4L2_DV_PROGRESSIVE;
+
+  width =
+      ((i2c_rd8(sd, DE_WIDTH_H_HI) & 0x1f) << 8) + i2c_rd8(sd, DE_WIDTH_H_LO);
+  height =
+      ((i2c_rd8(sd, DE_WIDTH_V_HI) & 0x1f) << 8) + i2c_rd8(sd, DE_WIDTH_V_LO);
+  frame_width = ((i2c_rd8(sd, H_SIZE_HI) & 0x1f) << 8) + i2c_rd8(sd, H_SIZE_LO);
+  frame_height =
+      (((i2c_rd8(sd, V_SIZE_HI) & 0x3f) << 8) + i2c_rd8(sd, V_SIZE_LO)) / 2;
+  /* frame interval in milliseconds * 10
+   * Require SYS_FREQ0 and SYS_FREQ1 are precisely set */
+  frame_interval =
+      ((i2c_rd8(sd, FV_CNT_HI) & 0x3) << 8) + i2c_rd8(sd, FV_CNT_LO);
+  fps = (frame_interval > 0) ? DIV_ROUND_CLOSEST(10000, frame_interval) : 0;
+
+  bt->width = width;
+  bt->height = height;
+  bt->vsync = frame_height - height;
+  bt->hsync = frame_width - width;
+  bt->pixelclock = frame_width * frame_height * fps;
+  if (bt->interlaced == V4L2_DV_INTERLACED) {
+    bt->height *= 2;
+    bt->il_vsync = bt->vsync + 1;
+    bt->pixelclock /= 2;
+  }
+  v4l2_info(sd, "%d:%s: width %d heigh %d interlaced %d\n", __LINE__,
+            __FUNCTION__, bt->width, bt->height, bt->interlaced);
+  return 0;
+}
+/* --------------- HOTPLUG / HDCP / EDID --------------- */
+
+static void tc358743_delayed_work_enable_hotplug(struct work_struct *work) {
+  struct delayed_work *dwork = to_delayed_work(work);
+  struct tc358743_state *state =
+      container_of(dwork, struct tc358743_state, delayed_work_enable_hotplug);
+  struct v4l2_subdev *sd = &state->sd;
+
+  v4l2_info(sd, "%s:\n", __func__);
+
+  i2c_wr8_and_or(sd, HPD_CTL, ~MASK_HPD_OUT0, MASK_HPD_OUT0);
+  /*hainh
+  i2c_wr8_and_or(sd, HPD_CTL, ~MASK_HPD_CTL0, MASK_HPD_CTL0);
+  */
+}
+
+static void tc358743_set_hdmi_hdcp(struct v4l2_subdev *sd, bool enable) {
+  v4l2_info(sd, "%s: %s\n", __func__, enable ? "enable" : "disable");
+
+  i2c_wr8_and_or(sd, HDCP_REG1, ~(MASK_AUTH_UNAUTH_SEL | MASK_AUTH_UNAUTH),
+                 MASK_AUTH_UNAUTH_SEL_16_FRAMES | MASK_AUTH_UNAUTH_AUTO);
+
+  i2c_wr8_and_or(sd, HDCP_REG2, ~MASK_AUTO_P3_RESET,
+                 SET_AUTO_P3_RESET_FRAMES(0x0f));
+
+  /* HDCP is disabled by configuring the receiver as HDCP repeater. The
+   * repeater mode require software support to work, so HDCP
+   * authentication will fail. */
+  i2c_wr8_and_or(sd, HDCP_REG3, ~KEY_RD_CMD, enable ? KEY_RD_CMD : 0);
+  i2c_wr8_and_or(sd, HDCP_MODE, ~(MASK_AUTO_CLR | MASK_MODE_RST_TN),
+                 enable ? (MASK_AUTO_CLR | MASK_MODE_RST_TN) : 0);
+
+  /* Apple MacBook Pro gen.8 has a bug that makes it freeze every fifth
+   * second when HDCP is disabled, but the MAX_EXCED bit is handled
+   * correctly and HDCP is disabled on the HDMI output. */
+  i2c_wr8_and_or(sd, BSTATUS1, ~MASK_MAX_EXCED, enable ? 0 : MASK_MAX_EXCED);
+  i2c_wr8_and_or(sd, BCAPS, ~(MASK_REPEATER | MASK_READY),
+                 enable ? 0 : MASK_REPEATER | MASK_READY);
+}
+
+static void tc358743_disable_edid(struct v4l2_subdev *sd) {
+  struct tc358743_state *state = to_state(sd);
+
+  v4l2_info(sd, "%s:\n", __func__);
+
+  cancel_delayed_work_sync(&state->delayed_work_enable_hotplug);
+
+  /* DDC access to EDID is also disabled when hotplug is disabled. See
+   * register DDC_CTL */
+  i2c_wr8_and_or(sd, HPD_CTL, ~MASK_HPD_OUT0, 0x0);
+}
+
+static void tc358743_erase_bksv(struct v4l2_subdev *sd) {
+  int i;
+  v4l2_info(sd, "function %s\n", __func__);
+  for (i = 0; i < 5; i++) i2c_wr8(sd, BKSV + i, 0);
+}
+
+/* --------------- AVI infoframe --------------- */
+
+static void print_avi_infoframe(struct v4l2_subdev *sd) {
+  struct i2c_client *client = v4l2_get_subdevdata(sd);
+  struct device *dev = &client->dev;
+  union hdmi_infoframe frame;
+  u8 buffer[HDMI_INFOFRAME_SIZE(AVI)];
+  v4l2_info(sd, "function %s\n", __func__);
+  if (!is_hdmi(sd)) {
+    v4l2_info(sd, "DVI-D signal - AVI infoframe not supported\n");
+    return;
+  }
+
+  i2c_rd(sd, PK_AVI_0HEAD, buffer, HDMI_INFOFRAME_SIZE(AVI));
+
+  if (hdmi_infoframe_unpack(&frame, buffer, sizeof(buffer)) < 0) {
+    v4l2_err(sd, "%s: unpack of AVI infoframe failed\n", __func__);
+    return;
+  }
+
+  hdmi_infoframe_log(KERN_INFO, dev, &frame);
+}
+
+/* --------------- CTRLS --------------- */
+
+static int tc358743_s_ctrl_detect_tx_5v(struct v4l2_subdev *sd) {
+  struct tc358743_state *state = to_state(sd);
+  v4l2_info(sd, "function %s\n", __func__);
+  return v4l2_ctrl_s_ctrl(state->detect_tx_5v_ctrl, tx_5v_power_present(sd));
+}
+
+static int tc358743_s_ctrl_audio_sampling_rate(struct v4l2_subdev *sd) {
+  struct tc358743_state *state = to_state(sd);
+  v4l2_info(sd, "function %s\n", __func__);
+  return v4l2_ctrl_s_ctrl(state->audio_sampling_rate_ctrl,
+                          get_audio_sampling_rate(sd));
+}
+
+static int tc358743_s_ctrl_audio_present(struct v4l2_subdev *sd) {
+  struct tc358743_state *state = to_state(sd);
+  v4l2_info(sd, "function %s\n", __func__);
+  return v4l2_ctrl_s_ctrl(state->audio_present_ctrl, audio_present(sd));
+}
+
+static int tc358743_update_controls(struct v4l2_subdev *sd) {
+  int ret = 0;
+  v4l2_info(sd, "function %s\n", __func__);
+
+  ret |= tc358743_s_ctrl_detect_tx_5v(sd);
+  ret |= tc358743_s_ctrl_audio_sampling_rate(sd);
+  ret |= tc358743_s_ctrl_audio_present(sd);
+
+  return ret;
+}
+
+static unsigned tc358743_num_csi_lanes_needed(struct v4l2_subdev *sd) {
+  // return 2;
+  struct tc358743_state *state = to_state(sd);
+  struct v4l2_bt_timings *bt = &state->timings.bt;
+  struct tc358743_platform_data *pdata = &state->pdata;
+  u32 bits_pr_pixel =
+      (state->mbus_fmt_code == MEDIA_BUS_FMT_UYVY8_1X16) ? 16 : 24;
+  u32 bps = bt->width * bt->height * fps(bt) * bits_pr_pixel;
+  u32 bps_pr_lane = (pdata->refclk_hz / pdata->pll_prd) * pdata->pll_fbd;
+  v4l2_info(sd, "function %s bps %d bps_pr_lane%d \n", __func__, bps,
+            bps_pr_lane);
+  return DIV_ROUND_UP(bps, bps_pr_lane);
+}
+
+static int tc358743_get_edid(struct v4l2_subdev *sd) {
+  u8 edid_read[256];
+  int result = 0;
+  u32 n = sizeof(edid_read);
+
+  result = i2c_rd(sd, EDID_RAM, edid_read, n);
+  v4l2_info(sd, "%s i2c_rd return %d\r\n", __func__, result);
+  v4l2_info(sd, "%s done\r\n", __func__);
+  return 0;
+}
+
+static int tc358743_log_status(struct v4l2_subdev *sd) {
+  struct tc358743_state *state = to_state(sd);
+  struct v4l2_dv_timings timings;
+  uint8_t hdmi_sys_status = i2c_rd8(sd, SYS_STATUS);
+  uint16_t sysctl = i2c_rd16(sd, SYSCTL);
+  u8 vi_status3 = i2c_rd8(sd, VI_STATUS3);
+  const int deep_color_mode[4] = {8, 10, 12, 16};
+  static const char *const input_color_space[] = {
+      "RGB",       "YCbCr 601", "Adobe RGB", "YCbCr 709",    "NA (4)",
+      "xvYCC 601", "NA(6)",     "xvYCC 709", "NA(8)",        "sYCC601",
+      "NA(10)",    "NA(11)",    "NA(12)",    "Adobe YCC 601"};
+  tc358743_get_edid(sd);
+  v4l2_info(sd, "-----Chip status-----\n");
+  v4l2_info(sd, "Chip ID:0x%02x\n", (i2c_rd16(sd, CHIPID) & MASK_CHIPID) >> 8);
+  v4l2_info(sd, "Chip revision:0x%02x\n", i2c_rd16(sd, CHIPID) & MASK_REVID);
+  v4l2_info(sd, "Reset: IR: %d, CEC: %d, CSI TX: %d, HDMI: %d\n",
+            !!(sysctl & MASK_IRRST), !!(sysctl & MASK_CECRST),
+            !!(sysctl & MASK_CTXRST), !!(sysctl & MASK_HDMIRST));
+  v4l2_info(sd, "Sleep mode: %s\n", sysctl & MASK_SLEEP ? "on" : "off");
+  v4l2_info(sd, "Cable detected (+5V power): %s\n",
+            hdmi_sys_status & MASK_S_DDC5V ? "yes" : "no");
+  v4l2_info(sd, "DDC lines enabled: %s\n",
+            (i2c_rd8(sd, EDID_MODE) & MASK_EDID_MODE_E_DDC) ? "yes" : "no");
+  v4l2_info(sd, "Hotplug enabled: %s\n",
+            (i2c_rd8(sd, HPD_CTL) & MASK_HPD_OUT0) ? "yes" : "no");
+  v4l2_info(sd, "CEC enabled: %s\n",
+            (i2c_rd16(sd, CECEN) & MASK_CECEN) ? "yes" : "no");
+  v4l2_info(sd, "-----Signal status-----\n");
+  v4l2_info(sd, "TMDS signal detected: %s\n",
+            hdmi_sys_status & MASK_S_TMDS ? "yes" : "no");
+  v4l2_info(sd, "Stable sync signal: %s\n",
+            hdmi_sys_status & MASK_S_SYNC ? "yes" : "no");
+  v4l2_info(sd, "PHY PLL locked: %s\n",
+            hdmi_sys_status & MASK_S_PHY_PLL ? "yes" : "no");
+  v4l2_info(sd, "PHY DE detected: %s\n",
+            hdmi_sys_status & MASK_S_PHY_SCDT ? "yes" : "no");
+
+  if (tc358743_get_detected_timings(sd, &timings)) {
+    v4l2_info(sd, "No video detected\n");
+  } else {
+    v4l2_print_dv_timings(sd->name, "Detected format: ", &timings, true);
+  }
+  v4l2_print_dv_timings(sd->name, "Configured format: ", &state->timings, true);
+
+  v4l2_info(sd, "-----CSI-TX status-----\n");
+  v4l2_info(sd, "Lanes needed: %d\n", tc358743_num_csi_lanes_needed(sd));
+  v4l2_info(sd, "Lanes in use: %d\n", tc358743_num_csi_lanes_in_use(sd));
+  v4l2_info(sd, "Waiting for particular sync signal: %s\n",
+            (i2c_rd16(sd, CSI_STATUS) & MASK_S_WSYNC) ? "yes" : "no");
+  v4l2_info(sd, "Transmit mode: %s\n",
+            (i2c_rd16(sd, CSI_STATUS) & MASK_S_TXACT) ? "yes" : "no");
+  v4l2_info(sd, "Receive mode: %s\n",
+            (i2c_rd16(sd, CSI_STATUS) & MASK_S_RXACT) ? "yes" : "no");
+  v4l2_info(sd, "Stopped: %s\n",
+            (i2c_rd16(sd, CSI_STATUS) & MASK_S_HLT) ? "yes" : "no");
+  v4l2_info(sd, "Color space: %s\n",
+            state->mbus_fmt_code == MEDIA_BUS_FMT_UYVY8_1X16
+                ? "YCbCr 422 16-bit"
+                : state->mbus_fmt_code == MEDIA_BUS_FMT_RGB888_1X24
+                      ? "RGB 888 24-bit"
+                      : "Unsupported");
+
+  v4l2_info(sd, "-----%s status-----\n", is_hdmi(sd) ? "HDMI" : "DVI-D");
+  v4l2_info(sd, "HDCP encrypted content: %s\n",
+            hdmi_sys_status & MASK_S_HDCP ? "yes" : "no");
+  v4l2_info(sd, "Input color space: %s %s range\n",
+            input_color_space[(vi_status3 & MASK_S_V_COLOR) >> 1],
+            (vi_status3 & MASK_LIMITED) ? "limited" : "full");
+  if (!is_hdmi(sd)) return 0;
+  v4l2_info(sd, "AV Mute: %s\n",
+            hdmi_sys_status & MASK_S_AVMUTE ? "on" : "off");
+  v4l2_info(sd, "Deep color mode: %d-bits per channel\n",
+            deep_color_mode[(i2c_rd8(sd, VI_STATUS1) & MASK_S_DEEPCOLOR) >> 2]);
+  print_avi_infoframe(sd);
+
+  return 0;
+}
+
+/* --------------- INIT --------------- */
+
+static void tc358743_reset_phy(struct v4l2_subdev *sd) {
+  v4l2_info(sd, "%s:\n", __func__);
+
+  i2c_wr8_and_or(sd, PHY_RST, ~MASK_RESET_CTRL, 0);
+  i2c_wr8_and_or(sd, PHY_RST, ~MASK_RESET_CTRL, MASK_RESET_CTRL);
+}
+
+static void tc358743_reset(struct v4l2_subdev *sd, uint16_t mask) {
+  u16 sysctl = i2c_rd16(sd, SYSCTL);
+  v4l2_info(sd, "function %s\n", __func__);
+
+  i2c_wr16(sd, SYSCTL, sysctl | mask);
+  i2c_wr16(sd, SYSCTL, sysctl & ~mask);
+}
+
+static inline void tc358743_sleep_mode(struct v4l2_subdev *sd, bool enable) {
+  v4l2_info(sd, "function %s\n", __func__);
+
+  i2c_wr16_and_or(sd, SYSCTL, ~MASK_SLEEP, enable ? MASK_SLEEP : 0);
+}
+
+static inline void enable_stream(struct v4l2_subdev *sd, bool enable) {
+  struct tc358743_state *state = to_state(sd);
+
+  v4l2_info(sd, "LDS> Transmit mode: %s\n",
+            (i2c_rd16(sd, CSI_STATUS) & MASK_S_TXACT) ? "yes" : "no");
+  v4l2_info(sd, "LDS> %s: %sable\n", __func__, enable ? "en" : "dis");
+
+  if (enable) {
+    /* It is critical for CSI receiver to see lane transition
+     * LP11->HS. Set to non-continuous mode to enable clock lane
+     * LP11 state. */
+    i2c_wr32(sd, TXOPTIONCNTRL, 0);
+    /* Set to continuous mode to trigger LP11->HS transition */
+    i2c_wr32(sd, TXOPTIONCNTRL, MASK_CONTCLKMODE);
+    /* Unmute video */
+    i2c_wr8(sd, VI_MUTE, MASK_AUTO_MUTE);
+  } else {
+    /* Mute video so that all data lanes go to LSP11 state.
+     * No data is output to CSI Tx block. */
+    i2c_wr8(sd, VI_MUTE, MASK_AUTO_MUTE | MASK_VI_MUTE);
+  }
+
+  mutex_lock(&state->confctl_mutex);
+  i2c_wr16_and_or(sd, CONFCTL, ~(MASK_VBUFEN | MASK_ABUFEN),
+                  enable ? (MASK_VBUFEN | MASK_ABUFEN) : 0x0);
+  mutex_unlock(&state->confctl_mutex);
+  v4l2_info(sd, "%d:%s: end\n", __LINE__, __FUNCTION__);
+}
+
+static void tc358743_set_pll(struct v4l2_subdev *sd) {
+  struct tc358743_state *state = to_state(sd);
+  struct tc358743_platform_data *pdata = &state->pdata;
+  u16 pllctl0 = i2c_rd16(sd, PLLCTL0);
+  u16 pllctl1 = i2c_rd16(sd, PLLCTL1);
+  u16 pllctl0_new = SET_PLL_PRD(pdata->pll_prd) | SET_PLL_FBD(pdata->pll_fbd);
+  u32 hsck = (pdata->refclk_hz / pdata->pll_prd) * pdata->pll_fbd;
+
+  v4l2_info(sd, "%s:\n", __func__);
+
+  /* Only rewrite when needed (new value or disabled), since rewriting
+   * triggers another format change event. */
+  if ((pllctl0 != pllctl0_new) || ((pllctl1 & MASK_PLL_EN) == 0)) {
+    u16 pll_frs;
+
+    if (hsck > 500000000)
+      pll_frs = 0x0;
+    else if (hsck > 250000000)
+      pll_frs = 0x1;
+    else if (hsck > 125000000)
+      pll_frs = 0x2;
+    else
+      pll_frs = 0x3;
+    v4l2_info(sd, "%s: updating PLL clock\n", __func__);
+    tc358743_sleep_mode(sd, true);
+    i2c_wr16(sd, PLLCTL0, pllctl0_new);
+    i2c_wr16_and_or(sd, PLLCTL1, ~(MASK_PLL_FRS | MASK_RESETB | MASK_PLL_EN),
+                    (SET_PLL_FRS(pll_frs) | MASK_RESETB | MASK_PLL_EN));
+    udelay(10); /* REF_02, Sheet "Source HDMI" */
+    i2c_wr16_and_or(sd, PLLCTL1, ~MASK_CKEN, MASK_CKEN);
+    tc358743_sleep_mode(sd, false);
+  }
+}
+
+static void tc358743_set_ref_clk(struct v4l2_subdev *sd) {
+  struct tc358743_state *state = to_state(sd);
+  struct tc358743_platform_data *pdata = &state->pdata;
+  u32 sys_freq;
+  u32 lockdet_ref;
+  u16 fh_min;
+  u16 fh_max;
+  v4l2_info(sd, "function %s\n", __func__);
+
+  sys_freq = pdata->refclk_hz / 10000;
+  i2c_wr8(sd, SYS_FREQ0, sys_freq & 0x00ff);
+  i2c_wr8(sd, SYS_FREQ1, (sys_freq & 0xff00) >> 8);
+
+  i2c_wr8_and_or(sd, PHY_CTL0, ~MASK_PHY_SYSCLK_IND,
+                 (pdata->refclk_hz == 42000000) ? MASK_PHY_SYSCLK_IND : 0x0);
+
+  fh_min = pdata->refclk_hz / 100000;
+  i2c_wr8(sd, FH_MIN0, fh_min & 0x00ff);
+  i2c_wr8(sd, FH_MIN1, (fh_min & 0xff00) >> 8);
+
+  fh_max = (fh_min * 66) / 10;
+  i2c_wr8(sd, FH_MAX0, fh_max & 0x00ff);
+  i2c_wr8(sd, FH_MAX1, (fh_max & 0xff00) >> 8);
+
+  lockdet_ref = pdata->refclk_hz / 100;
+  i2c_wr8(sd, LOCKDET_REF0, lockdet_ref & 0x0000ff);
+  i2c_wr8(sd, LOCKDET_REF1, (lockdet_ref & 0x00ff00) >> 8);
+  i2c_wr8(sd, LOCKDET_REF2, (lockdet_ref & 0x0f0000) >> 16);
+
+  i2c_wr8_and_or(sd, NCO_F0_MOD, ~MASK_NCO_F0_MOD,
+                 (pdata->refclk_hz == 27000000) ? MASK_NCO_F0_MOD_27MHZ : 0x0);
+}
+
+static void tc358743_set_csi_color_space(struct v4l2_subdev *sd) {
+  struct tc358743_state *state = to_state(sd);
+  v4l2_info(sd, "function %s\n", __func__);
+
+  switch (state->mbus_fmt_code) {
+    case MEDIA_BUS_FMT_UYVY8_1X16:
+      v4l2_info(sd, "%s: YCbCr 422 16-bit\n", __func__);
+      i2c_wr8_and_or(sd, VOUT_SET2,
+                     ~(MASK_SEL422 | MASK_VOUT_422FIL_100) & 0xff,
+                     MASK_SEL422 | MASK_VOUT_422FIL_100);
+      i2c_wr8_and_or(sd, VI_REP, ~MASK_VOUT_COLOR_SEL & 0xff,
+                     MASK_VOUT_COLOR_601_YCBCR_LIMITED);
+      mutex_lock(&state->confctl_mutex);
+      i2c_wr16_and_or(sd, CONFCTL, ~MASK_YCBCRFMT, MASK_YCBCRFMT_422_8_BIT);
+      mutex_unlock(&state->confctl_mutex);
+      break;
+
+      // v4l2_info(sd, "LDS> %s: TEST pattern\n", __func__);
+      // i2c_wr8_and_or(sd, VOUT_SET2, ~(MASK_SEL422 | MASK_VOUT_422FIL_100) & 0xff, MASK_SEL422 | MASK_VOUT_422FIL_100);
+      // i2c_wr8_and_or(sd, VI_REP, ~MASK_VOUT_COLOR_SEL & 0xff, MASK_VOUT_COLOR_601_YCBCR_LIMITED);
+      // mutex_lock(&state->confctl_mutex);
+      // i2c_wr16_and_or(sd, CONFCTL, ~MASK_YCBCRFMT, MASK_YCBCRFMT_COLORBAR);
+      // mutex_unlock(&state->confctl_mutex);
+      // break;
+
+    case MEDIA_BUS_FMT_RGB888_1X24:
+      v4l2_info(sd, "%s: RGB 888 24-bit\n", __func__);
+      i2c_wr8_and_or(sd, VOUT_SET2,
+                     ~(MASK_SEL422 | MASK_VOUT_422FIL_100) & 0xff, 0x00);
+      i2c_wr8_and_or(sd, VI_REP, ~MASK_VOUT_COLOR_SEL & 0xff,
+                     MASK_VOUT_COLOR_RGB_FULL);
+      mutex_lock(&state->confctl_mutex);
+      i2c_wr16_and_or(sd, CONFCTL, ~MASK_YCBCRFMT, 0);
+      mutex_unlock(&state->confctl_mutex);
+      break;
+    default:
+      v4l2_dbg(2, debug, sd, "%s: Unsupported format code 0x%x\n", __func__,
+               state->mbus_fmt_code);
+      break;
+  }
+
+  // enable_stream(sd, true);  // Just put here for testing
+}
+
+static void tc358743_set_csi(struct v4l2_subdev *sd) {
+  struct tc358743_state *state = to_state(sd);
+  struct tc358743_platform_data *pdata = &state->pdata;
+  unsigned lanes = tc358743_num_csi_lanes_needed(sd);
+
+  v4l2_info(sd, "%s:\n", __func__);
+
+  tc358743_reset(sd, MASK_CTXRST);
+
+  if (lanes < 1) i2c_wr32(sd, CLW_CNTRL, MASK_CLW_LANEDISABLE);
+  if (lanes < 1) i2c_wr32(sd, D0W_CNTRL, MASK_D0W_LANEDISABLE);
+  if (lanes < 2) i2c_wr32(sd, D1W_CNTRL, MASK_D1W_LANEDISABLE);
+  if (lanes < 3) i2c_wr32(sd, D2W_CNTRL, MASK_D2W_LANEDISABLE);
+  if (lanes < 4) i2c_wr32(sd, D3W_CNTRL, MASK_D3W_LANEDISABLE);
+
+  i2c_wr32(sd, LINEINITCNT, pdata->lineinitcnt);
+  i2c_wr32(sd, LPTXTIMECNT, pdata->lptxtimecnt);
+  i2c_wr32(sd, TCLK_HEADERCNT, pdata->tclk_headercnt);
+  i2c_wr32(sd, TCLK_TRAILCNT, pdata->tclk_trailcnt);
+  i2c_wr32(sd, THS_HEADERCNT, pdata->ths_headercnt);
+  i2c_wr32(sd, TWAKEUP, pdata->twakeup);
+  i2c_wr32(sd, TCLK_POSTCNT, pdata->tclk_postcnt);
+  i2c_wr32(sd, THS_TRAILCNT, pdata->ths_trailcnt);
+  i2c_wr32(sd, HSTXVREGCNT, pdata->hstxvregcnt);
+
+  i2c_wr32(sd, HSTXVREGEN,
+           ((lanes > 0) ? MASK_CLM_HSTXVREGEN : 0x0) |
+               ((lanes > 0) ? MASK_D0M_HSTXVREGEN : 0x0) |
+               ((lanes > 1) ? MASK_D1M_HSTXVREGEN : 0x0) |
+               ((lanes > 2) ? MASK_D2M_HSTXVREGEN : 0x0) |
+               ((lanes > 3) ? MASK_D3M_HSTXVREGEN : 0x0));
+
+  i2c_wr32(
+      sd, TXOPTIONCNTRL,
+      (pdata->endpoint.bus.mipi_csi2.flags & V4L2_MBUS_CSI2_CONTINUOUS_CLOCK)
+          ? MASK_CONTCLKMODE
+          : 0);
+  i2c_wr32(sd, STARTCNTRL, MASK_START);
+  i2c_wr32(sd, CSI_START, MASK_STRT);
+
+  i2c_wr32(sd, CSI_CONFW,
+           MASK_MODE_SET | MASK_ADDRESS_CSI_CONTROL | MASK_CSI_MODE |
+               MASK_TXHSMD |
+               ((lanes == 4)
+                    ? MASK_NOL_4
+                    : (lanes == 3) ? MASK_NOL_3
+                                   : (lanes == 2) ? MASK_NOL_2 : MASK_NOL_1));
+
+  i2c_wr32(sd, CSI_CONFW,
+           MASK_MODE_SET | MASK_ADDRESS_CSI_ERR_INTENA | MASK_TXBRK |
+               MASK_QUNK | MASK_WCER | MASK_INER);
+
+  i2c_wr32(
+      sd, CSI_CONFW,
+      MASK_MODE_CLEAR | MASK_ADDRESS_CSI_ERR_HALT | MASK_TXBRK | MASK_QUNK);
+
+  i2c_wr32(sd, CSI_CONFW,
+           MASK_MODE_SET | MASK_ADDRESS_CSI_INT_ENA | MASK_INTER);
+}
+
+static void tc358743_set_hdmi_phy(struct v4l2_subdev *sd) {
+  struct tc358743_state *state = to_state(sd);
+  struct tc358743_platform_data *pdata = &state->pdata;
+  v4l2_info(sd, "function %s\n", __func__);
+
+  /* Default settings from REF_02, sheet "Source HDMI"
+   * and custom settings as platform data */
+  // turn of physics
+  i2c_wr8_and_or(sd, PHY_EN, ~MASK_ENABLE_PHY, 0x0);
+  i2c_wr8(sd, PHY_CTL1,
+          SET_PHY_AUTO_RST1_US(1600) | SET_FREQ_RANGE_MODE_CYCLES(1));
+  i2c_wr8_and_or(
+      sd, PHY_CTL2, ~MASK_PHY_AUTO_RSTn,
+      (pdata->hdmi_phy_auto_reset_tmds_detected ? MASK_PHY_AUTO_RST2 : 0) |
+          (pdata->hdmi_phy_auto_reset_tmds_in_range ? MASK_PHY_AUTO_RST3 : 0) |
+          (pdata->hdmi_phy_auto_reset_tmds_valid ? MASK_PHY_AUTO_RST4 : 0));
+  i2c_wr8(sd, PHY_BIAS, 0x40);
+  i2c_wr8(sd, PHY_CSQ, SET_CSQ_CNT_LEVEL(0x0a));
+  i2c_wr8(sd, AVM_CTL, 45);
+  i2c_wr8_and_or(sd, HDMI_DET, ~MASK_HDMI_DET_V,
+                 pdata->hdmi_detection_delay << 4);
+
+  i2c_wr8_and_or(
+      sd, HV_RST, ~(MASK_H_PI_RST | MASK_V_PI_RST),
+      (pdata->hdmi_phy_auto_reset_hsync_out_of_range ? MASK_H_PI_RST : 0) |
+          (pdata->hdmi_phy_auto_reset_vsync_out_of_range ? MASK_V_PI_RST : 0));
+  // turn on physics
+  i2c_wr8_and_or(sd, PHY_EN, ~MASK_ENABLE_PHY, MASK_ENABLE_PHY);
+}
+
+static void tc358743_set_hdmi_audio(struct v4l2_subdev *sd) {
+  struct tc358743_state *state = to_state(sd);
+  v4l2_info(sd, "function %s\n", __func__);
+
+  /* Default settings from REF_02, sheet "Source HDMI" */
+  i2c_wr8(sd, FORCE_MUTE, 0x00);
+  i2c_wr8(sd, AUTO_CMD0,
+          MASK_AUTO_MUTE7 | MASK_AUTO_MUTE6 | MASK_AUTO_MUTE5 |
+              MASK_AUTO_MUTE4 | MASK_AUTO_MUTE1 | MASK_AUTO_MUTE0);
+  i2c_wr8(sd, AUTO_CMD1, MASK_AUTO_MUTE9);
+  i2c_wr8(sd, AUTO_CMD2, MASK_AUTO_PLAY3 | MASK_AUTO_PLAY2);
+  i2c_wr8(sd, BUFINIT_START, SET_BUFINIT_START_MS(500));
+  i2c_wr8(sd, FS_MUTE, 0x00);
+  i2c_wr8(sd, FS_IMODE, MASK_NLPCM_SMODE | MASK_FS_SMODE);
+  i2c_wr8(sd, ACR_MODE, MASK_CTS_MODE);
+  i2c_wr8(sd, ACR_MDF0, MASK_ACR_L2MDF_1976_PPM | MASK_ACR_L1MDF_976_PPM);
+  i2c_wr8(sd, ACR_MDF1, MASK_ACR_L3MDF_3906_PPM);
+  i2c_wr8(sd, SDO_MODE1, MASK_SDO_FMT_I2S);
+  i2c_wr8(sd, DIV_MODE, SET_DIV_DLY_MS(100));
+
+  mutex_lock(&state->confctl_mutex);
+  i2c_wr16_and_or(sd, CONFCTL, 0xffff,
+                  MASK_AUDCHNUM_2 | MASK_AUDOUTSEL_I2S | MASK_AUTOINDEX);
+  mutex_unlock(&state->confctl_mutex);
+}
+
+static void tc358743_set_hdmi_info_frame_mode(struct v4l2_subdev *sd) {
+  /* Default settings from REF_02, sheet "Source HDMI" */
+  v4l2_info(sd, "function %s\n", __func__);
+
+  i2c_wr8(sd, PK_INT_MODE,
+          MASK_ISRC2_INT_MODE | MASK_ISRC_INT_MODE | MASK_ACP_INT_MODE |
+              MASK_VS_INT_MODE | MASK_SPD_INT_MODE | MASK_MS_INT_MODE |
+              MASK_AUD_INT_MODE | MASK_AVI_INT_MODE);
+  i2c_wr8(sd, NO_PKT_LIMIT, 0x2c);
+  i2c_wr8(sd, NO_PKT_CLR, 0x53);
+  i2c_wr8(sd, ERR_PK_LIMIT, 0x01);
+  i2c_wr8(sd, NO_PKT_LIMIT2, 0x30);
+  i2c_wr8(sd, NO_GDB_LIMIT, 0x10);
+}
+
+static void tc358743_initial_setup(struct v4l2_subdev *sd) {
+  struct tc358743_state *state = to_state(sd);
+  struct tc358743_platform_data *pdata = &state->pdata;
+  v4l2_info(sd, "function %s\n", __func__);
+
+  /* CEC and IR are not supported by this driver */
+  i2c_wr16_and_or(sd, SYSCTL, ~(MASK_CECRST | MASK_IRRST),
+                  (MASK_CECRST | MASK_IRRST));
+
+  tc358743_reset(sd, MASK_CTXRST | MASK_HDMIRST);
+  tc358743_sleep_mode(sd, false);
+
+  i2c_wr16(sd, FIFOCTL, pdata->fifo_level);
+
+  tc358743_set_ref_clk(sd);
+
+  i2c_wr8_and_or(sd, DDC_CTL, ~MASK_DDC5V_MODE,
+                 pdata->ddc5v_delay & MASK_DDC5V_MODE);
+
+  i2c_wr8_and_or(sd, EDID_MODE, ~MASK_EDID_MODE, MASK_EDID_MODE_E_DDC);
+
+  tc358743_set_hdmi_phy(sd);
+  tc358743_set_hdmi_hdcp(sd, pdata->enable_hdcp);
+  tc358743_set_hdmi_audio(sd);
+  tc358743_set_hdmi_info_frame_mode(sd);
+
+  /* All CE and IT formats are detected as RGB full range in DVI mode */
+  i2c_wr8_and_or(sd, VI_MODE, ~MASK_RGB_DVI, 0);
+
+  i2c_wr8_and_or(sd, VOUT_SET2, ~MASK_VOUTCOLORMODE, MASK_VOUTCOLORMODE_AUTO);
+  i2c_wr8(sd, VOUT_SET3, MASK_VOUT_EXTCNT);
+}
+
+/* --------------- IRQ --------------- */
+
+static void tc358743_format_change(struct v4l2_subdev *sd) {
+  struct tc358743_state *state = to_state(sd);
+  struct v4l2_dv_timings timings;
+  const struct v4l2_event tc358743_ev_fmt = {
+      .type = V4L2_EVENT_SOURCE_CHANGE,
+      .u.src_change.changes = V4L2_EVENT_SRC_CH_RESOLUTION,
+  };
+
+  v4l2_info(sd, "%s: Format changed\n", __func__);
+
+  if (tc358743_get_detected_timings(sd, &timings)) {
+    enable_stream(sd, false);
+
+    v4l2_info(sd, "%s: Format changed. No signal\n", __func__);
+  } else {
+    if (!v4l2_match_dv_timings(&state->timings, &timings, 0, false))
+      enable_stream(sd, false);
+
+    v4l2_print_dv_timings(
+        sd->name,
+        "tc358743_format_change: Format change`d. New format: ", &timings,
+        false);
+  }
+
+  if (sd->devnode) v4l2_subdev_notify_event(sd, &tc358743_ev_fmt);
+}
+
+static void tc358743_init_interrupts(struct v4l2_subdev *sd) {
+  u16 i;
+  v4l2_info(sd, "function %s\n", __func__);
+
+  /* clear interrupt status registers */
+  for (i = SYS_INT; i <= KEY_INT; i++) i2c_wr8(sd, i, 0xff);
+
+  i2c_wr16(sd, INTSTATUS, 0xffff);
+}
+
+static void tc358743_enable_interrupts(struct v4l2_subdev *sd,
+                                       bool cable_connected) {
+  v4l2_info(sd, "%s: cable connected = %d\n", __func__, cable_connected);
+
+  if (cable_connected) {
+    i2c_wr8(sd, SYS_INTM,
+            ~(MASK_M_DDC | MASK_M_DVI_DET | MASK_M_HDMI_DET) & 0xff);
+    i2c_wr8(sd, CLK_INTM, ~MASK_M_IN_DE_CHG);
+    i2c_wr8(sd, CBIT_INTM,
+            ~(MASK_M_CBIT_FS | MASK_M_AF_LOCK | MASK_M_AF_UNLOCK) & 0xff);
+    i2c_wr8(sd, AUDIO_INTM, ~MASK_M_BUFINIT_END);
+    i2c_wr8(sd, MISC_INTM, ~MASK_M_SYNC_CHG);
+  } else {
+    i2c_wr8(sd, SYS_INTM, ~MASK_M_DDC & 0xff);
+    i2c_wr8(sd, CLK_INTM, 0xff);
+    i2c_wr8(sd, CBIT_INTM, 0xff);
+    i2c_wr8(sd, AUDIO_INTM, 0xff);
+    i2c_wr8(sd, MISC_INTM, 0xff);
+  }
+}
+
+static void tc358743_hdmi_audio_int_handler(struct v4l2_subdev *sd,
+                                            bool *handled) {
+  u8 audio_int_mask = i2c_rd8(sd, AUDIO_INTM);
+  u8 audio_int = i2c_rd8(sd, AUDIO_INT) & ~audio_int_mask;
+
+  i2c_wr8(sd, AUDIO_INT, audio_int);
+
+  v4l2_info(sd, "%s: AUDIO_INT =0x%02x\n", __func__, audio_int);
+
+  tc358743_s_ctrl_audio_sampling_rate(sd);
+  tc358743_s_ctrl_audio_present(sd);
+}
+
+static void tc358743_csi_err_int_handler(struct v4l2_subdev *sd,
+                                         bool *handled) {
+  v4l2_err(sd, "%s: CSI_ERR =0x%x\n", __func__, i2c_rd32(sd, CSI_ERR));
+
+  i2c_wr32(sd, CSI_INT_CLR, MASK_ICRER);
+}
+
+static void tc358743_hdmi_misc_int_handler(struct v4l2_subdev *sd,
+                                           bool *handled) {
+  u8 misc_int_mask = i2c_rd8(sd, MISC_INTM);
+  u8 misc_int = i2c_rd8(sd, MISC_INT) & ~misc_int_mask;
+
+  i2c_wr8(sd, MISC_INT, misc_int);
+
+  v4l2_info(sd, "%s: MISC_INT =0x%02x\n", __func__, misc_int);
+
+  if (misc_int & MASK_I_SYNC_CHG) {
+    /* Reset the HDMI PHY to try to trigger proper lock on the
+     * incoming video format. Erase BKSV to prevent that old keys
+     * are used when a new source is connected. */
+    if (no_sync(sd) || no_signal(sd)) {
+      tc358743_reset_phy(sd);
+      tc358743_erase_bksv(sd);
+    }
+
+    tc358743_format_change(sd);
+
+    misc_int &= ~MASK_I_SYNC_CHG;
+    if (handled) *handled = true;
+  }
+
+  if (misc_int) {
+    v4l2_err(sd, "%s: Unhandled MISC_INT interrupts:0x%02x\n", __func__,
+             misc_int);
+  }
+}
+
+static void tc358743_hdmi_cbit_int_handler(struct v4l2_subdev *sd,
+                                           bool *handled) {
+  u8 cbit_int_mask = i2c_rd8(sd, CBIT_INTM);
+  u8 cbit_int = i2c_rd8(sd, CBIT_INT) & ~cbit_int_mask;
+
+  i2c_wr8(sd, CBIT_INT, cbit_int);
+
+  v4l2_info(sd, "%s: CBIT_INT =0x%02x\n", __func__, cbit_int);
+
+  if (cbit_int & MASK_I_CBIT_FS) {
+    v4l2_info(sd, "%s: Audio sample rate changed\n", __func__);
+    tc358743_s_ctrl_audio_sampling_rate(sd);
+
+    cbit_int &= ~MASK_I_CBIT_FS;
+    if (handled) *handled = true;
+  }
+
+  if (cbit_int & (MASK_I_AF_LOCK | MASK_I_AF_UNLOCK)) {
+    v4l2_info(sd, "%s: Audio present changed\n", __func__);
+    tc358743_s_ctrl_audio_present(sd);
+
+    cbit_int &= ~(MASK_I_AF_LOCK | MASK_I_AF_UNLOCK);
+    if (handled) *handled = true;
+  }
+
+  if (cbit_int) {
+    v4l2_err(sd, "%s: Unhandled CBIT_INT interrupts:0x%02x\n", __func__,
+             cbit_int);
+  }
+}
+
+static void tc358743_hdmi_clk_int_handler(struct v4l2_subdev *sd,
+                                          bool *handled) {
+  u8 clk_int_mask = i2c_rd8(sd, CLK_INTM);
+  u8 clk_int = i2c_rd8(sd, CLK_INT) & ~clk_int_mask;
+
+  /* Bit 7 and bit 6 are set even when they are masked */
+  i2c_wr8(sd, CLK_INT, clk_int | 0x80 | MASK_I_OUT_H_CHG);
+
+  v4l2_info(sd, "%s: CLK_INT =0x%02x\n", __func__, clk_int);
+
+  if (clk_int & (MASK_I_IN_DE_CHG)) {
+    v4l2_info(sd, "%s: DE size or position has changed\n", __func__);
+
+    /* If the source switch to a new resolution with the same pixel
+     * frequency as the existing (e.g. 1080p25 -> 720p50), the
+     * I_SYNC_CHG interrupt is not always triggered, while the
+     * I_IN_DE_CHG interrupt seems to work fine. Format change
+     * notifications are only sent when the signal is stable to
+     * reduce the number of notifications. */
+    if (!no_signal(sd) && !no_sync(sd)) tc358743_format_change(sd);
+
+    clk_int &= ~(MASK_I_IN_DE_CHG);
+    if (handled) *handled = true;
+  }
+
+  if (clk_int) {
+    v4l2_err(sd, "%s: Unhandled CLK_INT interrupts:0x%02x\n", __func__,
+             clk_int);
+  }
+}
+
+static void tc358743_enable_edid(struct v4l2_subdev *sd) {
+  struct tc358743_state *state = to_state(sd);
+
+  v4l2_info(sd, "%s\n", __func__);
+  if (state->edid_blocks_written == 0) {
+    v4l2_info(sd, "%s: no EDID -> no hotplug\n", __func__);
+    return;
+  }
+
+  v4l2_info(sd, "%s:\n", __func__);
+
+  /* Enable hotplug after 100 ms. DDC access to EDID is also enabled when
+   * hotplug is enabled. See register DDC_CTL */
+  queue_delayed_work(state->work_queues, &state->delayed_work_enable_hotplug,
+                     HZ / 10);
+
+  tc358743_enable_interrupts(sd, true);
+  tc358743_s_ctrl_detect_tx_5v(sd);
+  v4l2_info(sd, "%s completed successfully", __FUNCTION__);
+}
+
+static void tc358743_delayed_work_enable_interrupt(struct work_struct *work) {
+  struct delayed_work *dwork = to_delayed_work(work);
+  struct tc358743_state *state =
+      container_of(dwork, struct tc358743_state, delayed_work_enable_interrupt);
+  struct v4l2_subdev *sd = &state->sd;
+
+  v4l2_dbg(2, debug, sd, "%s:\n", __func__);
+
+  tc358743_enable_interrupts(sd, tx_5v_power_present(sd));
+
+  // /* Temporary EDID. Should be set by userspace */
+  // tc358743_s_edid(sd, &sd_edid);
+}
+
+static void tc358743_hdmi_sys_int_handler(struct v4l2_subdev *sd,
+                                          bool *handled) {
+  struct tc358743_state *state = to_state(sd);
+  u8 sys_int_mask = i2c_rd8(sd, SYS_INTM);
+  u8 sys_int = i2c_rd8(sd, SYS_INT) & ~sys_int_mask;
+
+  i2c_wr8(sd, SYS_INT, sys_int);
+
+  v4l2_info(sd, "%s: SYS_INT =0x%02x\n", __func__, sys_int);
+
+  if (sys_int & MASK_I_DDC) {
+    bool tx_5v = tx_5v_power_present(sd);
+
+    v4l2_info(sd, "%s: Tx 5V power present: %s\n", __func__,
+              tx_5v ? "yes" : "no");
+
+    if (tx_5v) {
+      tc358743_enable_edid(sd);
+    } else {
+      tc358743_enable_interrupts(sd, false);
+      tc358743_disable_edid(sd);
+      memset(&state->timings, 0, sizeof(state->timings));
+      tc358743_erase_bksv(sd);
+      tc358743_update_controls(sd);
+    }
+
+    sys_int &= ~MASK_I_DDC;
+    if (handled) *handled = true;
+  }
+
+  if (sys_int & MASK_I_DVI) {
+    v4l2_info(sd, "%s: HDMI->DVI change detected\n", __func__);
+
+    /* Reset the HDMI PHY to try to trigger proper lock on the
+     * incoming video format. Erase BKSV to prevent that old keys
+     * are used when a new source is connected. */
+    if (no_sync(sd) || no_signal(sd)) {
+      tc358743_reset_phy(sd);
+      tc358743_erase_bksv(sd);
+    }
+
+    sys_int &= ~MASK_I_DVI;
+    if (handled) *handled = true;
+  }
+
+  if (sys_int & MASK_I_HDMI) {
+    v4l2_info(sd, "%s: DVI->HDMI change detected\n", __func__);
+
+    /* Register is reset in DVI mode (REF_01, c. 6.6.41) */
+    i2c_wr8(sd, ANA_CTL, MASK_APPL_PCSX_NORMAL | MASK_ANALOG_ON);
+
+    sys_int &= ~MASK_I_HDMI;
+    if (handled) *handled = true;
+  }
+
+  if (sys_int) {
+    v4l2_err(sd, "%s: Unhandled SYS_INT interrupts:0x%02x\n", __func__,
+             sys_int);
+  }
+}
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+static void tc358743_print_register_map(struct v4l2_subdev *sd) {
+  v4l2_info(sd, "0x00000x00FF: Global Control Register\n");
+  v4l2_info(sd, "0x01000x01FF: CSI2-TX PHY Register\n");
+  v4l2_info(sd, "0x02000x03FF: CSI2-TX PPI Register\n");
+  v4l2_info(sd, "0x04000x05FF: Reserved\n");
+  v4l2_info(sd, "0x06000x06FF: CEC Register\n");
+  v4l2_info(sd, "0x07000x84FF: Reserved\n");
+  v4l2_info(sd, "0x85000x85FF: HDMIRX System Control Register\n");
+  v4l2_info(sd, "0x86000x86FF: HDMIRX Audio Control Register\n");
+  v4l2_info(sd, "0x87000x87FF: HDMIRX InfoFrame packet data Register\n");
+  v4l2_info(sd, "0x88000x88FF: HDMIRX HDCP Port Register\n");
+  v4l2_info(sd, "0x89000x89FF: HDMIRX Video Output Port & 3D Register\n");
+  v4l2_info(sd, "0x8A000x8BFF: Reserved\n");
+  v4l2_info(sd, "0x8C000x8FFF: HDMIRX EDID-RAM (1024bytes)\n");
+  v4l2_info(sd, "0x90000x90FF: HDMIRX GBD Extraction Control\n");
+  v4l2_info(sd, "0x91000x92FF: HDMIRX GBD RAM read\n");
+  v4l2_info(sd, "0x9300-      : Reserved\n");
+}
+
+static int tc358743_get_reg_size(u16 address) {
+  /* REF_01 p. 66-72 */
+  if (address <= 0x00ff)
+    return 2;
+  else if ((address >= 0x0100) && (address <= 0x06FF))
+    return 4;
+  else if ((address >= 0x0700) && (address <= 0x84ff))
+    return 2;
+  else
+    return 1;
+}
+
+static int tc358743_g_register(struct v4l2_subdev *sd,
+                               struct v4l2_dbg_register *reg) {
+  if (reg->reg > 0xffff) {
+    tc358743_print_register_map(sd);
+    return -EINVAL;
+  }
+
+  reg->size = tc358743_get_reg_size(reg->reg);
+
+  i2c_rd(sd, reg->reg, (u8 *)&reg->val, reg->size);
+
+  return 0;
+}
+
+static int tc358743_s_register(struct v4l2_subdev *sd,
+                               const struct v4l2_dbg_register *reg) {
+  if (reg->reg > 0xffff) {
+    tc358743_print_register_map(sd);
+    return -EINVAL;
+  }
+
+  /* It should not be possible for the user to enable HDCP with a simple
+   * v4l2-dbg command.
+   *
+   * DO NOT REMOVE THIS unless all other issues with HDCP have been
+   * resolved.
+   */
+  if (reg->reg == HDCP_MODE || reg->reg == HDCP_REG1 || reg->reg == HDCP_REG2 ||
+      reg->reg == HDCP_REG3 || reg->reg == BCAPS)
+    return 0;
+
+  i2c_wr(sd, (u16)reg->reg, (u8 *)&reg->val, tc358743_get_reg_size(reg->reg));
+
+  return 0;
+}
+#endif
+
+static int tc358743_isr(struct v4l2_subdev *sd, u32 status, bool *handled) {
+  u16 intstatus = i2c_rd16(sd, INTSTATUS);
+
+  if (intstatus & MASK_HDMI_INT) {
+    u8 hdmi_int0 = i2c_rd8(sd, HDMI_INT0);
+    u8 hdmi_int1 = i2c_rd8(sd, HDMI_INT1);
+
+    if (hdmi_int0 & MASK_I_MISC) tc358743_hdmi_misc_int_handler(sd, handled);
+    if (hdmi_int1 & MASK_I_CBIT) tc358743_hdmi_cbit_int_handler(sd, handled);
+    if (hdmi_int1 & MASK_I_CLK) tc358743_hdmi_clk_int_handler(sd, handled);
+    if (hdmi_int1 & MASK_I_SYS) tc358743_hdmi_sys_int_handler(sd, handled);
+    if (hdmi_int1 & MASK_I_AUD) tc358743_hdmi_audio_int_handler(sd, handled);
+
+    i2c_wr16(sd, INTSTATUS, MASK_HDMI_INT);
+    intstatus &= ~MASK_HDMI_INT;
+  }
+
+  if (intstatus & MASK_CSI_INT) {
+    u32 csi_int = i2c_rd32(sd, CSI_INT);
+
+    if (csi_int & MASK_INTER) tc358743_csi_err_int_handler(sd, handled);
+
+    i2c_wr16(sd, INTSTATUS, MASK_CSI_INT);
+    intstatus &= ~MASK_CSI_INT;
+  }
+
+  intstatus = i2c_rd16(sd, INTSTATUS);
+  if (intstatus) {
+    v4l2_info(sd, "%s: Unhandled IntStatus interrupts:0x%02x\n", __func__,
+              intstatus);
+  }
+
+  return 0;
+}
+
+static void tc358743_process_isr(struct work_struct *work) {
+  struct tc358743_state *state =
+      container_of(work, struct tc358743_state, process_isr);
+  struct v4l2_subdev *sd = &state->sd;
+  bool handled;
+
+  v4l2_dbg(2, debug, sd, "%s:\n", __func__);
+
+  mutex_lock(&state->isr_lock);
+  tc358743_isr(sd, 0, &handled);
+  mutex_unlock(&state->isr_lock);
+}
+
+static irqreturn_t tc358743_irq_handler(int irq, void *dev_id) {
+  struct tc358743_state *state = dev_id;
+
+  queue_work(state->work_queues, &state->process_isr);
+
+  return IRQ_HANDLED;
+}
+
+static int tc358743_subscribe_event(struct v4l2_subdev *sd, struct v4l2_fh *fh,
+                                    struct v4l2_event_subscription *sub) {
+  v4l2_info(sd, "Calling %s\n", __FUNCTION__);
+  switch (sub->type) {
+    case V4L2_EVENT_SOURCE_CHANGE:
+      return v4l2_src_change_event_subdev_subscribe(sd, fh, sub);
+    case V4L2_EVENT_CTRL:
+      return v4l2_ctrl_subdev_subscribe_event(sd, fh, sub);
+    default:
+      return -EINVAL;
+  }
+}
+
+/* --------------- VIDEO OPS --------------- */
+
+static int tc358743_s_dv_timings(struct v4l2_subdev *sd,
+                                 struct v4l2_dv_timings *timings) {
+  struct tc358743_state *state = to_state(sd);
+  v4l2_info(sd, "1111 %s\n", __func__);
+  if (!timings) return -EINVAL;
+
+  if (v4l2_match_dv_timings(&state->timings, timings, 0, false)) {
+    v4l2_info(sd, "%s: no change\n", __func__);
+    return 0;
+  }
+
+  if (!v4l2_valid_dv_timings(timings, &tc358743_timings_cap, NULL, NULL)) {
+    v4l2_err(sd, "%s: timings out of range\n", __func__);
+    return -ERANGE;
+  }
+
+  state->timings = *timings;
+
+  enable_stream(sd, false);
+  tc358743_set_pll(sd);
+  tc358743_set_csi(sd);
+  v4l2_info(sd, "2222 %s\n", __func__);
+  return 0;
+}
+
+static int tc358743_g_dv_timings(struct v4l2_subdev *sd,
+                                 struct v4l2_dv_timings *timings) {
+  struct tc358743_state *state = to_state(sd);
+  v4l2_info(sd, "Calling %s\n", __FUNCTION__);
+  if (state) {
+    *timings = state->timings;
+    return 0;
+  }
+  return -EINVAL;
+}
+
+static int tc358743_enum_dv_timings(struct v4l2_subdev *sd,
+                                    struct v4l2_enum_dv_timings *timings) {
+  v4l2_info(sd, "Calling %s\n", __FUNCTION__);
+  if (timings && timings->pad != 0) {
+    v4l2_err(sd, "%s: failed %d\n", __func__, EINVAL);
+    return -EINVAL;
+  }
+
+  return v4l2_enum_dv_timings_cap(timings, &tc358743_timings_cap, NULL, NULL);
+}
+
+static int tc358743_query_dv_timings(struct v4l2_subdev *sd,
+                                     struct v4l2_dv_timings *timings) {
+  int ret;
+  v4l2_info(sd, "Calling %s\n", __FUNCTION__);
+
+  ret = tc358743_get_detected_timings(sd, timings);
+  if (ret) {
+    v4l2_err(sd, "%s: @@@@@ timings detected error\n", __func__);
+    return ret;
+  }
+
+  if (debug)
+    v4l2_print_dv_timings(sd->name, "tc358743_query_dv_timings: ", timings,
+                          false);
+
+  if (!v4l2_valid_dv_timings(timings, &tc358743_timings_cap, NULL, NULL)) {
+    v4l2_err(sd, "%s: @@@@@ timings out of range\n", __func__);
+    return -ERANGE;
+  }
+
+  return 0;
+}
+
+static int tc358743_g_input_status(struct v4l2_subdev *sd, u32 *status) {
+  struct tc358743_state *state = to_state(sd);
+  struct v4l2_dv_timings *timings = &(state->timings);
+
+  v4l2_info(sd, "Calling %s\n", __FUNCTION__);
+  *status = 0;
+  *status |= no_signal(sd) ? V4L2_IN_ST_NO_SIGNAL : 0;
+  *status |= no_sync(sd) ? V4L2_IN_ST_NO_SYNC : 0;
+
+  v4l2_info(sd, "%s: status =0x%x\n", __func__, *status);
+
+  v4l2_info(sd, "Now getting and setting dv timings");
+  tc358743_query_dv_timings(sd, timings);
+  tc358743_s_dv_timings(sd, timings);
+
+  return 0;
+}
+
+static int tc358743_dv_timings_cap(struct v4l2_subdev *sd,
+                                   struct v4l2_dv_timings_cap *cap) {
+  v4l2_info(sd, "Calling %s\n", __FUNCTION__);
+  if (cap && cap->pad != 0) return -EINVAL;
+
+  *cap = tc358743_timings_cap;
+
+  return 0;
+}
+
+static int tc358743_g_mbus_config(struct v4l2_subdev *sd,
+                                  unsigned int pad,
+                                  struct v4l2_mbus_config *cfg) {
+  v4l2_info(sd, "Calling %s\n", __FUNCTION__);
+//  cfg->type = V4L2_MBUS_CSI2;
+  cfg->type = V4L2_MBUS_CSI2_DPHY;
+
+  /* Support for non-continuous CSI-2 clock is missing in the driver */
+  cfg->flags = V4L2_MBUS_CSI2_CONTINUOUS_CLOCK;
+
+  switch (tc358743_num_csi_lanes_in_use(sd)) {
+    case 1:
+      cfg->flags |= V4L2_MBUS_CSI2_1_LANE;
+      break;
+    case 2:
+      cfg->flags |= V4L2_MBUS_CSI2_2_LANE;
+      break;
+    case 3:
+      cfg->flags |= V4L2_MBUS_CSI2_3_LANE;
+      break;
+    case 4:
+      cfg->flags |= V4L2_MBUS_CSI2_4_LANE;
+      break;
+    default:
+      return -EINVAL;
+  }
+
+  return 0;
+}
+
+static int tc358743_s_stream(struct v4l2_subdev *sd, int enable) {
+  v4l2_info(sd, "Calling %s\n", __FUNCTION__);
+  enable_stream(sd, true);
+  return 0;
+}
+
+/* --------------- PAD OPS --------------- */
+
+static int tc358743_get_fmt(struct v4l2_subdev *sd,
+                            struct v4l2_subdev_state *sd_state,
+                            struct v4l2_subdev_format *format) {
+  struct tc358743_state *state = to_state(sd);
+  u8 vi_rep = i2c_rd8(sd, VI_REP);
+  v4l2_info(sd, "Calling %s\n", __FUNCTION__);
+
+  if (format->pad != 0) {
+    v4l2_err(sd, "%s Error\n", __FUNCTION__);
+    return -EINVAL;
+  }
+
+  format->format.code = state->mbus_fmt_code;
+  format->format.width = state->timings.bt.width;
+  format->format.height = state->timings.bt.height;
+  format->format.field = V4L2_FIELD_NONE;
+
+  switch (vi_rep & MASK_VOUT_COLOR_SEL) {
+    case MASK_VOUT_COLOR_RGB_FULL:
+    case MASK_VOUT_COLOR_RGB_LIMITED:
+      format->format.colorspace = V4L2_COLORSPACE_SRGB;
+      break;
+    case MASK_VOUT_COLOR_601_YCBCR_LIMITED:
+    case MASK_VOUT_COLOR_601_YCBCR_FULL:
+      v4l2_info(sd, "Here 6b, colorspace: %d\n", V4L2_COLORSPACE_SMPTE170M);
+      format->format.colorspace = V4L2_COLORSPACE_SMPTE170M;
+      break;
+    case MASK_VOUT_COLOR_709_YCBCR_FULL:
+    case MASK_VOUT_COLOR_709_YCBCR_LIMITED:
+      format->format.colorspace = V4L2_COLORSPACE_REC709;
+      break;
+    default:
+      format->format.colorspace = 0;
+      v4l2_info(sd, "%d:%s colorspace = 0\n", __LINE__, __FUNCTION__);
+      break;
+  }
+
+  v4l2_info(sd, "get fmt complete\n");
+  v4l2_info(sd, "format width %d\n", format->format.width);
+  v4l2_info(sd, "format height %d\n", format->format.height);
+
+  v4l2_info(sd, "fmt_code: %d\n", format->format.code);
+  v4l2_info(sd, "RGB888 code: %d\n", MEDIA_BUS_FMT_RGB888_1X24);
+  v4l2_info(sd, "UYVY8 code: %d\n", MEDIA_BUS_FMT_UYVY8_1X16);
+  return 0;
+}
+
+static int tc358743_set_fmt(struct v4l2_subdev *sd,
+                            struct v4l2_subdev_state *sd_state,
+                            struct v4l2_subdev_format *format) {
+  struct tc358743_state *state = to_state(sd);
+  u32 code = format->format.code;
+  int ret = tc358743_get_fmt(sd, sd_state, format);
+
+  v4l2_dbg(3, debug, sd, "%s(), ret: %d\n", __func__, ret);
+  v4l2_dbg(3, debug, sd, "Set format code: %d\n", code);
+
+  format->format.code = code;
+
+  if (ret) return ret;
+
+  switch (code) {
+    case MEDIA_BUS_FMT_RGB888_1X24:
+    case MEDIA_BUS_FMT_UYVY8_1X16:
+      v4l2_dbg(3, debug, sd, "Good code %d\n", code);
+      break;
+    default:
+      v4l2_err(sd, "Bad code %d\n", code);
+      return -EINVAL;
+  }
+
+  if (format->which == V4L2_SUBDEV_FORMAT_TRY) return 0;
+
+  state->mbus_fmt_code = format->format.code;
+
+  enable_stream(sd, false);
+  tc358743_set_pll(sd);
+  tc358743_set_csi(sd);
+  tc358743_set_csi_color_space(sd);
+  v4l2_info(sd, "Called %s, completed successfully\n", __FUNCTION__);
+  return 0;
+}
+
+static int tc358743_g_edid(struct v4l2_subdev *sd,
+                           struct v4l2_subdev_edid *edid) {
+  struct tc358743_state *state = to_state(sd);
+  // int i=0;
+  v4l2_info(sd, "Calling %s\n", __FUNCTION__);
+
+  if (edid->pad != 0) return -EINVAL;
+
+  if (edid->start_block == 0 && edid->blocks == 0) {
+    edid->blocks = state->edid_blocks_written;
+    return 0;
+  }
+
+  if (state->edid_blocks_written == 0) return -ENODATA;
+
+  if (edid->start_block >= state->edid_blocks_written || edid->blocks == 0)
+    return -EINVAL;
+
+  if (edid->start_block + edid->blocks > state->edid_blocks_written)
+    edid->blocks = state->edid_blocks_written - edid->start_block;
+
+  i2c_rd(sd, EDID_RAM + (edid->start_block * EDID_BLOCK_SIZE), edid->edid,
+         edid->blocks * EDID_BLOCK_SIZE);
+  v4l2_info(sd, "EDID_RAM has %d byte from: 0x%04x to 0x%04x \r\n",
+            edid->blocks * EDID_BLOCK_SIZE,
+            EDID_RAM + (edid->start_block * EDID_BLOCK_SIZE),
+            EDID_RAM + (edid->start_block * EDID_BLOCK_SIZE) +
+                edid->blocks * EDID_BLOCK_SIZE);
+  // for(i=0;i<edid->blocks * EDID_BLOCK_SIZE;i++){
+  // 	printk("%02x ",edid->edid[i]);
+  // }
+  // v4l2_info(sd,"\r\n");
+  v4l2_info(sd, "%s completed successfully", __FUNCTION__);
+  return 0;
+}
+
+static int tc358743_s_edid(struct v4l2_subdev *sd,
+                           struct v4l2_subdev_edid *edid) {
+  struct tc358743_state *state = to_state(sd);
+  u16 edid_len = edid->blocks * EDID_BLOCK_SIZE;
+
+  v4l2_info(sd, "%s, pad %d, start block %d, blocks %d\n", __func__, edid->pad,
+            edid->start_block, edid->blocks);
+
+  if (edid->pad != 0) return -EINVAL;
+
+  if (edid->start_block != 0) return -EINVAL;
+
+  if (edid->blocks > EDID_NUM_BLOCKS_MAX) {
+    edid->blocks = EDID_NUM_BLOCKS_MAX;
+    return -E2BIG;
+  }
+
+  tc358743_disable_edid(sd);
+
+  i2c_wr8(sd, EDID_LEN1, edid_len & 0xff);
+  i2c_wr8(sd, EDID_LEN2, edid_len >> 8);
+
+  if (edid->blocks == 0) {
+    state->edid_blocks_written = 0;
+    return 0;
+  }
+  i2c_wr(sd, EDID_RAM, edid->edid, edid_len);
+  /* richardyou
+  for (i=0; i<edid_len; i++) {
+          i2c_wr8(sd, EDID_RAM + i, edid->edid[i]);
+  }
+  */
+  state->edid_blocks_written = edid->blocks;
+
+  //	if (tx_5v_power_present(sd))
+  tc358743_enable_edid(sd);
+
+  v4l2_info(sd, "%s completed successfully", __FUNCTION__);
+  return 0;
+}
+
+// static int tc358743_mbus_fmt(struct v4l2_subdev *sd,
+//                              struct v4l2_mbus_framefmt *mf) {
+//   struct tc358743_state *state = to_state(sd);
+//   u8 vi_rep = i2c_rd8(sd, VI_REP);
+
+//   mf->code = state->mbus_fmt_code;
+//   mf->width = state->timings.bt.width;
+//   mf->height = state->timings.bt.height;
+//   mf->field = V4L2_FIELD_NONE;
+//   switch (vi_rep & MASK_VOUT_COLOR_SEL) {
+//     case MASK_VOUT_COLOR_RGB_FULL:
+//     case MASK_VOUT_COLOR_RGB_LIMITED:
+//       mf->colorspace = V4L2_COLORSPACE_SRGB;
+//       break;
+//     case MASK_VOUT_COLOR_601_YCBCR_LIMITED:
+//     case MASK_VOUT_COLOR_601_YCBCR_FULL:
+//       mf->colorspace = V4L2_COLORSPACE_SMPTE170M;
+//       break;
+//     case MASK_VOUT_COLOR_709_YCBCR_FULL:
+//     case MASK_VOUT_COLOR_709_YCBCR_LIMITED:
+//       mf->colorspace = V4L2_COLORSPACE_REC709;
+//       break;
+//     default:
+//       mf->colorspace = 0;
+//       break;
+//   }
+//   return 0;
+// }
+
+static int tc358743_enum_mbus_code(struct v4l2_subdev *sd,
+                                   struct v4l2_subdev_state *sd_state,
+                                   struct v4l2_subdev_mbus_code_enum *code) {
+  v4l2_info(sd, "%s()\n", __func__);
+
+  //	if (code->index >= 2) {
+  //		v4l2_err(sd, "Error in %s\n", __FUNCTION__);
+  //		return -EINVAL;
+  //	}
+
+  switch (code->index) {
+    case 0:
+      code->code = MEDIA_BUS_FMT_RGB888_1X24;
+      break;
+    case 1:
+      code->code = MEDIA_BUS_FMT_UYVY8_1X16;
+      break;
+
+    default:
+      return -EINVAL;
+  }
+
+  v4l2_info(sd, "Mbus code found succsefully (%d: %d)", code->index,
+            code->code);
+
+  return 0;
+}
+
+static int tc358743_enum_frame_size(struct v4l2_subdev *sd,
+                                    struct v4l2_subdev_state *sd_state,
+                                    struct v4l2_subdev_frame_size_enum *fse) {
+  const struct camera_common_frmfmt *frmfmt = tc358743_frmfmt;
+  int num_frmfmt = ARRAY_SIZE(tc358743_frmfmt);
+
+  v4l2_info(sd, "%s()\n", __func__);
+  v4l2_info(sd, "fse->code %d, index %d\n", fse->code, fse->index);
+  v4l2_info(sd, "----------------------------------------\n");
+
+  // fse->min_width  = fse->max_width  = 1280;
+  // fse->min_height = fse->max_height = 720;
+
+  v4l2_info(sd,
+            "Trying to find frmfmt that matches fse->code, code: %d (UYVY: %d, "
+            "ARGB32: %d, MEDIA_BUS_FMT_UYVY8_1X16: %d, "
+            "MEDIA_BUS_FMT_RGB888_1X24: %d)\n",
+            fse->code, V4L2_PIX_FMT_UYVY, V4L2_PIX_FMT_ABGR32,
+            MEDIA_BUS_FMT_UYVY8_1X16, MEDIA_BUS_FMT_RGB888_1X24);
+
+  if (fse->code != MEDIA_BUS_FMT_UYVY8_1X16 &&
+      fse->code != V4L2_PIX_FMT_ABGR32 &&
+      fse->code != MEDIA_BUS_FMT_UYVY8_1X16) {
+    v4l2_err(sd, "Error in %s fse->code, code: %d, UYVY: %d, ARGB32: %d\n",
+             __FUNCTION__, fse->code, V4L2_PIX_FMT_UYVY, V4L2_PIX_FMT_ABGR32);
+    return -EINVAL;
+  }
+
+  v4l2_info(sd, "Code ok");
+
+  if (fse->index >= num_frmfmt) {
+    v4l2_err(sd, "Error in %s, %d outside of num_frmfmt (%d)", __FUNCTION__,
+             fse->index, num_frmfmt);
+    return -EINVAL;
+  }
+
+  v4l2_info(sd, "Index ok");
+
+  fse->min_width = fse->max_width = frmfmt[fse->index].size.width;
+  fse->min_height = fse->max_height = frmfmt[fse->index].size.height;
+  v4l2_info(sd, "!!!!!!!!! %s() complete successfully, width: %d, height: %d\n",
+            __func__, fse->min_width, fse->min_height);
+  return 0;
+}
+
+static int tc358743_enum_frame_interval(
+    struct v4l2_subdev *sd, struct v4l2_subdev_state *sd_state,
+    struct v4l2_subdev_frame_interval_enum *fie) {
+  const struct camera_common_frmfmt *frmfmt = tc358743_frmfmt;
+  int num_frmfmt = ARRAY_SIZE(tc358743_frmfmt);
+  int i;
+
+  v4l2_info(sd, "%s()\n", __func__);
+  v4l2_info(sd, "----------------------------------------\n");
+
+  v4l2_info(sd,
+            "Trying to find frame interfval that matches fie->code, code: %d "
+            "(UYVY: %d, ARGB32: %d, MEDIA_BUS_FMT_UYVY8_1X16: %d)\n",
+            fie->code, V4L2_PIX_FMT_UYVY, V4L2_PIX_FMT_ABGR32,
+            MEDIA_BUS_FMT_UYVY8_1X16);
+
+  if (fie->code != V4L2_PIX_FMT_UYVY && fie->code != V4L2_PIX_FMT_ABGR32 &&
+      fie->code != MEDIA_BUS_FMT_UYVY8_1X16) {
+    v4l2_err(sd, "Unexpected code (%d), UYUV: %d, ABGR32: %d\n", fie->code,
+             V4L2_PIX_FMT_UYVY, V4L2_PIX_FMT_ABGR32);
+    return -EINVAL;
+  }
+
+  v4l2_info(sd, "Code ok");
+
+  for (i = 0; i < num_frmfmt; i++) {
+    if (frmfmt[i].size.width == fie->width &&
+        frmfmt[i].size.height == fie->height) {
+      v4l2_info(sd, "Matched width %d and %d, height %d and %d",
+                frmfmt[i].size.width, fie->width, frmfmt[i].size.height,
+                fie->height);
+      break;
+    }
+  }
+
+  v4l2_info(sd, "w/h ok or end (i=%d, num=%d)", i, num_frmfmt);
+
+  if (i >= num_frmfmt) {
+    v4l2_err(sd, "Error in %s, num frmfmt\n", __FUNCTION__);
+    return -EINVAL;
+  }
+
+  v4l2_info(sd, "i ok");
+
+  if (fie->index >= frmfmt[i].num_framerates) {
+    v4l2_err(sd, "Error in %s num framerates (%d outside %d)\n", __FUNCTION__,
+             fie->index, frmfmt[i].num_framerates);
+    return -EINVAL;
+  }
+
+  v4l2_info(sd, "index ok");
+
+  fie->interval.numerator = 1;
+  fie->interval.denominator = frmfmt[i].framerates[fie->index];
+                                         
+  v4l2_info(sd, "!!!!!!!!!! %s() completed successfully, interval: 1/%d\n",
+            __func__, fie->interval.denominator);
+  return 0;
+}
+
+static int tc358743_s_power(struct v4l2_subdev *sd, int on) {
+  v4l2_info(sd, "function %s\n", __func__);
+
+  return 0;
+}
+
+static const struct v4l2_subdev_core_ops tc358743_core_ops = {
+    .s_power = tc358743_s_power,
+    .log_status = tc358743_log_status,
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+    .g_register = tc358743_g_register,
+    .s_register = tc358743_s_register,
+#endif
+    .interrupt_service_routine = tc358743_isr,
+    .subscribe_event = tc358743_subscribe_event,
+    .unsubscribe_event = v4l2_event_subdev_unsubscribe,
+};
+
+static const struct v4l2_subdev_video_ops tc358743_video_ops = {
+    .g_input_status = tc358743_g_input_status,
+    .s_dv_timings = tc358743_s_dv_timings,
+    .g_dv_timings = tc358743_g_dv_timings,
+    .s_stream = tc358743_s_stream,
+    // .mbus_fmt = tc358743_mbus_fmt,
+    //.g_mbus_config = tc358743_g_mbus_config,
+    .query_dv_timings = tc358743_query_dv_timings,
+};
+
+static const struct v4l2_subdev_pad_ops tc358743_pad_ops = {
+    .set_fmt = tc358743_set_fmt,
+    .get_fmt = tc358743_get_fmt,
+    .get_edid = tc358743_g_edid,
+    .set_edid = tc358743_s_edid,
+    .dv_timings_cap = tc358743_dv_timings_cap,
+    .get_mbus_config = tc358743_g_mbus_config,
+
+    .enum_dv_timings = tc358743_enum_dv_timings,
+    .enum_mbus_code = tc358743_enum_mbus_code,
+    .enum_frame_size = tc358743_enum_frame_size,
+    .enum_frame_interval = tc358743_enum_frame_interval,
+};
+
+static const struct v4l2_subdev_ops tc358743_ops = {
+    .core = &tc358743_core_ops,
+    .video = &tc358743_video_ops,
+    .pad = &tc358743_pad_ops,
+};
+/* --------------- CUSTOM CTRLS --------------- */
+
+static const struct v4l2_ctrl_config tc358743_ctrl_audio_sampling_rate = {
+    .id = TC358743_CID_AUDIO_SAMPLING_RATE,
+    .name = "Audio sampling rate",
+    .type = V4L2_CTRL_TYPE_INTEGER,
+    .min = 0,
+    .max = 768000,
+    .step = 1,
+    .def = 0,
+    .flags = V4L2_CTRL_FLAG_READ_ONLY,
+};
+
+static const struct v4l2_ctrl_config tc358743_ctrl_audio_present = {
+    .id = TC358743_CID_AUDIO_PRESENT,
+    .name = "Audio present",
+    .type = V4L2_CTRL_TYPE_BOOLEAN,
+    .min = 0,
+    .max = 1,
+    .step = 1,
+    .def = 0,
+    .flags = V4L2_CTRL_FLAG_READ_ONLY,
+};
+
+static bool tc358743_parse_dt(struct tc358743_platform_data *pdata,
+                              struct i2c_client *client) {
+  struct device_node *node = client->dev.of_node;
+  const u32 *property;
+  pr_info("%s\n", __FUNCTION__);
+  pr_info("Device Tree Parameters:\n");
+
+  pdata->reset_gpio = of_get_named_gpio(node, "reset-gpios", 0);
+  if (pdata->reset_gpio == 0) return false;
+  pr_info("reset_gpio = %d\n", pdata->reset_gpio);
+
+  property = of_get_property(node, "refclk_hz", NULL);
+  if (property == NULL) return false;
+  pdata->refclk_hz = be32_to_cpup(property);
+  pr_info("refclk_hz = %d\n", be32_to_cpup(property));
+
+  return true;
+}
+
+#ifdef CONFIG_OF
+static void tc358743_gpio_reset(struct tc358743_state *state) {
+  usleep_range(5000, 10000);
+  // TODO: Re-implement the reset GPIO!
+  gpiod_set_value(state->reset_gpio, 0);
+  // gpio_set_value((int)state->reset_gpio, 1);
+  usleep_range(1000, 2000);
+  // gpio_set_value((int)state->reset_gpio, 0);
+  gpiod_set_value(state->reset_gpio, 1);
+  msleep(20);
+}
+
+static int tc358743_probe_of(struct tc358743_state *state) {
+  struct device *dev = &state->i2c_client->dev;
+//  struct v4l2_of_endpoint *endpoint;
+  struct v4l2_fwnode_endpoint endpoint = { .bus_type = 0 };
+
+  struct device_node *ep;
+  u32 bps_pr_lane;
+  int ret = -EINVAL;
+  pr_info("%s\n", __FUNCTION__);
+
+  if ((state->pdata.refclk_hz != 26000000) &&
+      (state->pdata.refclk_hz != 27000000) &&
+      (state->pdata.refclk_hz != 42000000)) {
+    pr_info("refclk_hz error \n");
+    return ret;
+  }
+
+  ep = of_graph_get_next_endpoint(dev->of_node, NULL);
+  if (!ep) {
+    dev_err(dev, "missing endpoint node\n");
+    return -EINVAL;
+  }
+
+/*  endpoint = v4l2_of_alloc_parse_endpoint(ep);
+  if (IS_ERR(endpoint)) {
+    dev_err(dev, "failed to parse endpoint\n");
+    return PTR_ERR(endpoint);
+  }*/
+
+  ret = v4l2_fwnode_endpoint_alloc_parse(of_fwnode_handle(ep), &endpoint);
+  if (ret) {
+      dev_err(dev, "failed to parse endpoint\n");
+      goto put_node;
+  }
+
+
+//  if (endpoint->bus_type != V4L2_MBUS_CSI2 ||
+
+  if (endpoint.bus_type != V4L2_MBUS_CSI2_DPHY ||
+      endpoint.bus.mipi_csi2.num_data_lanes == 0 ||
+      endpoint.nr_of_link_frequencies == 0) {
+    dev_err(dev, "missing CSI-2 properties in endpoint\n");
+    goto free_endpoint;
+  }
+
+  pr_info("tc358743 endpoint.bus.mipi_csi2.flags %d\n",
+          endpoint.bus.mipi_csi2.flags);
+  pr_info("tc358743 endpoint.bus.mipi_csi2.clock_lane %d\n",
+          endpoint.bus.mipi_csi2.clock_lane);
+  pr_info("tc358743 endpoint.bus.mipi_csi2.num_data_lanes %d\n",
+          endpoint.bus.mipi_csi2.num_data_lanes);
+  pr_info("tc358743 endpoint.bus.mipi_csi2.data_lanes [%d-%d-%d-%d]\n",
+          endpoint.bus.mipi_csi2.data_lanes[0],
+          endpoint.bus.mipi_csi2.data_lanes[1],
+          endpoint.bus.mipi_csi2.data_lanes[2],
+          endpoint.bus.mipi_csi2.data_lanes[3]);
+  pr_info("tc358743 endpoint.nr_of_link_frequencies %d\n",
+          endpoint.nr_of_link_frequencies);
+
+  state->pdata.ddc5v_delay = DDC5V_DELAY_100_MS;
+  state->pdata.hdmi_detection_delay = HDMI_MODE_DELAY_100_MS;
+  state->pdata.enable_hdcp = false;
+  /* A FIFO level of 16 should be enough for 2-lane 720p60 at 594 MHz. */
+  state->pdata.fifo_level = 16;
+  /*
+   * The PLL input clock is obtained by dividing refclk by pll_prd.
+   * It must be between 6 MHz and 40 MHz, lower frequency is better.
+   */
+  switch (state->pdata.refclk_hz) {
+      //~ case 26322581:
+      //~ state->pdata.refclk_hz = 26322581;
+    case 26000000:
+    case 27000000:
+    //~ case 40800000: /* Tegra */
+    case 42000000:
+      state->pdata.pll_prd = state->pdata.refclk_hz / 6000000;
+      break;
+    default:
+      dev_err(dev,"Unsupported refclk rate: %u Hz\n", state->pdata.refclk_hz);
+      goto disable_clk;
+  }
+dev_err(dev, "HERE #1\n");
+  /*
+   * The CSI bps per lane must be between 62.5 Mbps and 1 Gbps.
+   * The default is 594 Mbps for 4-lane 1080p60 or 2-lane 720p60.
+   */
+  bps_pr_lane = 2 * endpoint.link_frequencies[0];
+  // if (bps_pr_lane < 62500000U || bps_pr_lane > 1000000000U) {
+  if (bps_pr_lane < 62500000U || bps_pr_lane > 1188000000U) {
+    dev_err(dev, "unsupported bps per lane: %u bps\n", bps_pr_lane);
+    goto disable_clk;
+  }
+dev_err(dev, "HERE #2\n");
+  /* The CSI speed per lane is refclk / pll_prd * pll_fbd */
+  state->pdata.pll_fbd =
+      bps_pr_lane / state->pdata.refclk_hz * state->pdata.pll_prd;
+
+  /*
+   * FIXME: These timings are from REF_02 for 594 Mbps per lane (297 MHz
+   * link frequency). In principle it should be possible to calculate
+   * them based on link frequency and resolution.
+   */
+  if (bps_pr_lane != 594000000U)
+    dev_warn(dev, "untested bps per lane: %u bps\n", bps_pr_lane);
+  pr_info("tc358743 state->pdata.pll_prd=%d\r\n", state->pdata.pll_prd);
+  pr_info("tc358743 state->pdata.pll_fbd=%d\r\n", state->pdata.pll_fbd);
+dev_err(dev, "HERE #3\n");
+  // freq = refclk / prd * fbd, default = 594 MHz
+//  state->pdata.lineinitcnt = 0xe80;
+//  state->pdata.lptxtimecnt = 0x003;
+//  /* tclk-preparecnt: 3, tclk-zerocnt: 20 */
+//  state->pdata.tclk_headercnt = 0x1403;
+//  state->pdata.tclk_trailcnt = 0x00;
+//  /* ths-preparecnt: 3, ths-zerocnt: 1 */
+//  state->pdata.ths_headercnt = 0x0103;
+//  state->pdata.twakeup = 0x4882;
+//  state->pdata.tclk_postcnt = 0x008;
+//  state->pdata.ths_trailcnt = 0x2;
+//  state->pdata.hstxvregcnt = 2;
+
+  state->pdata.lineinitcnt = 0x1d01;//
+  state->pdata.lptxtimecnt = 0x008;//
+      /* tclk-preparecnt: 6, tclk-zerocnt: 45 */
+  state->pdata.tclk_headercnt = 0x2D06;//0x0218
+  state->pdata.tclk_trailcnt = 0x09;//
+      /* ths-preparecnt: 7, ths-zerocnt: 17 */
+  state->pdata.ths_headercnt = 0xd06;//0x0220
+  state->pdata.twakeup = 0x4883;//
+  state->pdata.tclk_postcnt = 0x010;//
+  state->pdata.ths_trailcnt = 0xA;//
+  state->pdata.hstxvregcnt = 5;//5
+  state->reset_gpio = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_LOW);
+  if (IS_ERR(state->reset_gpio)) {
+      dev_err(dev, "failed to get reset gpio\n");
+      ret = PTR_ERR(state->reset_gpio);
+      goto disable_clk;
+  }
+  if(state->reset_gpio) {
+    pr_info("Calling reset GPIO but NOT IMPLEMENTED!");
+    tc358743_gpio_reset(state);
+  }
+  ret = 0;
+  goto free_endpoint;
+
+disable_clk:
+  // clk_disable_unprepare(refclk);
+free_endpoint:
+ // v4l2_of_free_endpoint(endpoint);
+  v4l2_fwnode_endpoint_free(&endpoint);
+put_node:
+    of_node_put(ep);
+
+  return ret;
+}
+#else
+static inline int tc358743_probe_of(struct tc358743_state *state) {
+  return -ENODEV;
+}
+#endif
+
+static int tc358743_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh) {
+  return 0;
+}
+
+static const struct v4l2_subdev_internal_ops tc358743_subdev_internal_ops = {
+    .open = tc358743_open,
+};
+
+static const struct media_entity_operations tc358743_media_ops = {
+    .link_validate = v4l2_subdev_link_validate,
+};
+
+static const struct regmap_config sensor_regmap_config = {
+    .reg_bits = 16,
+    .val_bits = 8,
+    .cache_type = REGCACHE_RBTREE,
+};
+
+static int tc358743_probe(struct i2c_client *client,
+                          const struct i2c_device_id *id) {
+  // static struct v4l2_dv_timings default_timing = V4L2_DV_BT_CEA_1280X720P30;
+  static struct v4l2_dv_timings default_timing = V4L2_DV_BT_CEA_1920X1080P50;
+  struct v4l2_subdev_edid sd_edid = {
+      .blocks = 2,
+      .edid = edid,
+  };
+  struct tc358743_state *state;
+  struct tc358743_platform_data *pdata = client->dev.platform_data;
+  struct v4l2_subdev *sd;
+  int err;
+  u16 chip_id_val;
+
+  pr_info("%s\n", __FUNCTION__);
+
+  if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {
+    pr_err("i2c check functionality failed addres %02X name %s", client->addr,
+           client->adapter->name);
+    return -EIO;
+  }
+
+  v4l2_info(sd, "chip found @0x%x (%s)\n", client->addr, client->adapter->name);
+
+  state = devm_kzalloc(&client->dev, sizeof(struct tc358743_state), GFP_KERNEL);
+  if (!state) {
+    pr_err("devm_kzalloc failed");
+    return -ENOMEM;
+  }
+  v4l2_info(sd, "dev of node %s\n", client->dev.of_node->full_name);
+  if (client->dev.of_node) {
+    if (!tc358743_parse_dt(&state->pdata, client)) {
+      pr_err("Couldn't parse device tree\n");
+      return -ENODEV;
+    }
+  }
+
+  state->i2c_client = client;
+
+  /* platform data */
+  if (pdata) {
+    state->pdata = *pdata;
+    pdata->endpoint.bus.mipi_csi2.flags = V4L2_MBUS_CSI2_CONTINUOUS_CLOCK;
+  } else {
+    err = tc358743_probe_of(state);
+    if (err == -ENODEV) {
+      v4l_err(client, "No platform data! err = %d\n", err);
+      return -ENODEV;
+    }
+  }
+
+  sd = &state->sd;
+  v4l2_i2c_subdev_init(sd, client, &tc358743_ops);
+  v4l2_info(sd, "Subdev init done\n");
+  sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE | V4L2_SUBDEV_FL_HAS_EVENTS;
+
+  /* i2c access */
+  chip_id_val = i2c_rd16(sd, CHIPID);
+  v4l2_info(sd, "Chip ID val: %d\n", chip_id_val);
+
+  if ((chip_id_val & MASK_CHIPID) != 0 || chip_id_val == 99) {
+    v4l2_info(sd, "tc358743: ERROR: not a TC358743 on address0x%x\n",
+              client->addr);
+    return -ENODEV;
+  }
+
+  /* control handlers */
+  v4l2_ctrl_handler_init(&state->hdl, 3);
+  v4l2_info(sd, "ctrl handler initied\n");
+
+  /* private controls */
+  state->detect_tx_5v_ctrl = v4l2_ctrl_new_std(
+      &state->hdl, NULL, V4L2_CID_DV_RX_POWER_PRESENT, 0, 1, 0, 0);
+
+  /* custom controls */
+  state->audio_sampling_rate_ctrl = v4l2_ctrl_new_custom(
+      &state->hdl, &tc358743_ctrl_audio_sampling_rate, NULL);
+
+  state->audio_present_ctrl =
+      v4l2_ctrl_new_custom(&state->hdl, &tc358743_ctrl_audio_present, NULL);
+
+  v4l2_info(sd, "A bunch of new cutoms done\n");
+
+  sd->ctrl_handler = &state->hdl;
+  if (state->hdl.error) {
+    err = state->hdl.error;
+    goto err_hdl;
+  }
+
+  if (tc358743_update_controls(sd)) {
+    err = -ENODEV;
+    goto err_hdl;
+  }
+
+  v4l2_info(sd, "Controls updated\n");
+
+  /* work queues */
+  state->work_queues = create_singlethread_workqueue(client->name);
+  if (!state->work_queues) {
+    v4l2_err(sd, "Could not create work queue\n");
+    err = -ENOMEM;
+    goto err_hdl;
+  }
+  v4l2_info(sd, "Work queue created\n");
+  // sd->entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
+  sd->entity.ops = &tc358743_media_ops;
+  state->pad.flags = MEDIA_PAD_FL_SOURCE;
+  v4l2_info(sd, "About to call tegra_media_entity_init\n");
+  err = tegra_media_entity_init(&sd->entity, 1, &state->pad, true, true);
+  if (err < 0) goto err_hdl;
+  v4l2_info(sd, "tegra_media_entity_init complete\n");
+
+#ifdef TC358743_VOUT_RGB
+  state->mbus_fmt_code = MEDIA_BUS_FMT_RGB888_1X24;
+#else
+  state->mbus_fmt_code = MEDIA_BUS_FMT_UYVY8_1X16;
+#endif
+
+  v4l2_info(sd, "Set mbus_fmt_code in probe to: %d\n", state->mbus_fmt_code);
+
+  sd->dev = &client->dev;
+  v4l2_info(sd, "About to register subdev\n");
+
+v4l2_info(sd, "HERE #4\n");
+
+  err = v4l2_async_register_subdev(sd);
+
+v4l2_info(sd, "HERE #5\n");
+
+  v4l2_info(sd, "Register subdev: %d\n", err);
+
+  if (err < 0) goto err_hdl;
+
+  mutex_init(&state->confctl_mutex);
+
+v4l2_info(sd, "HERE #6\n");
+
+  INIT_DELAYED_WORK(&state->delayed_work_enable_hotplug,
+                    tc358743_delayed_work_enable_hotplug);
+  INIT_DELAYED_WORK(&state->delayed_work_enable_interrupt,
+                    tc358743_delayed_work_enable_interrupt);
+  INIT_WORK(&state->process_isr, tc358743_process_isr);
+  mutex_init(&state->isr_lock);
+
+  v4l2_info(sd, "before tc358743_initial_setup\r\n");
+  tc358743_initial_setup(sd);
+  v4l2_info(sd, "after tc358743_initial_setup\r\n");
+
+  tc358743_set_csi_color_space(sd);
+  v4l2_info(sd, "before tc358743_s_dv_timings\r\n");
+  tc358743_s_dv_timings(sd, &default_timing);
+
+  v4l2_info(sd, "before tc358743_init_interrupts, irq: %d\r\n",
+            state->i2c_client->irq);
+  tc358743_init_interrupts(sd);
+  v4l2_info(sd, "after tc358743_init_interrupts, irq: %d\r\n",
+            state->i2c_client->irq);
+  if (state->i2c_client->irq) {
+    v4l2_info(sd, "IQR request\r\n");
+    err = devm_request_threaded_irq(
+        &client->dev, state->i2c_client->irq, NULL, tc358743_irq_handler,
+        IRQF_TRIGGER_RISING | IRQF_ONESHOT, "tc358743", state);
+    v4l2_err(sd, "err, %d\n", err);
+    if (err) goto err_work_queues;
+  }
+  queue_delayed_work(state->work_queues, &state->delayed_work_enable_interrupt,
+                     msecs_to_jiffies(DELAY_ENABLE_INTERRUPT_MS));
+
+  tc358743_enable_interrupts(sd, tx_5v_power_present(sd));
+  i2c_wr16(sd, INTMASK, ~(MASK_HDMI_MSK | MASK_CSI_MSK) & 0xffff);
+
+  err = v4l2_ctrl_handler_setup(sd->ctrl_handler);
+
+  if (err) goto err_work_queues;
+
+  v4l2_info(sd, "%s found @0x%x (%s)\n", client->name, client->addr,
+            client->adapter->name);
+  tc358743_s_edid(sd, &sd_edid);
+  tc358743_g_edid(sd, &sd_edid);
+
+  tc358743_log_status(sd);
+  v4l2_info(sd, "Probe complete\n");
+  return 0;
+
+err_work_queues:
+  cancel_delayed_work(&state->delayed_work_enable_hotplug);
+  destroy_workqueue(state->work_queues);
+  mutex_destroy(&state->confctl_mutex);
+err_hdl:
+  media_entity_cleanup(&sd->entity);
+  v4l2_ctrl_handler_free(&state->hdl);
+  return err;
+}
+
+static int tc358743_remove(struct i2c_client *client) {
+  struct v4l2_subdev *sd = i2c_get_clientdata(client);
+  struct tc358743_state *state = to_state(sd);
+
+  cancel_delayed_work(&state->delayed_work_enable_hotplug);
+  destroy_workqueue(state->work_queues);
+  v4l2_async_unregister_subdev(sd);
+  v4l2_device_unregister_subdev(sd);
+  mutex_destroy(&state->confctl_mutex);
+  media_entity_cleanup(&sd->entity);
+  v4l2_ctrl_handler_free(&state->hdl);
+
+  return 0;
+}
+
+static struct i2c_device_id tc358743_id[] = {{"tc358743", 0}, {}};
+
+MODULE_DEVICE_TABLE(i2c, tc358743_id);
+
+#ifdef CONFIG_OF
+static const struct of_device_id tc358743_of_table[] = {
+    {.compatible = "toshiba,tc358743"}, {}};
+MODULE_DEVICE_TABLE(of, tc358743_of_table);
+#endif
+
+static struct i2c_driver tc358743_driver = {
+    .driver =
+        {
+            .of_match_table = of_match_ptr(tc358743_of_table),
+            .name = "tc358743",
+            .owner = THIS_MODULE,
+        },
+    .probe = tc358743_probe,
+    .remove = tc358743_remove,
+    .id_table = tc358743_id,
+};
+
+module_i2c_driver(tc358743_driver);
\ No newline at end of file
diff --git a/nvidia-oot/include/media/tc358743.h b/nvidia-oot/include/media/tc358743.h
new file mode 100644
index 0000000..787878e
--- /dev/null
+++ b/nvidia-oot/include/media/tc358743.h
@@ -0,0 +1,150 @@
+/*
+ * tc358743 - Toshiba HDMI to CSI-2 bridge
+ *
+ * Copyright 2015 Cisco Systems, Inc. and/or its affiliates. All rights
+ * reserved.
+ *
+ * This program is free software; you may redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ */
+
+/*
+ * References (c = chapter, p = page):
+ * REF_01 - Toshiba, TC358743XBG (H2C), Functional Specification, Rev 0.60
+ * REF_02 - Toshiba, TC358743XBG_HDMI-CSI_Tv11p_nm.xls
+ */
+
+#ifndef _TC358743_
+#define _TC358743_
+//#include <media/v4l2-of.h>
+#include <media/v4l2-fwnode.h>
+
+#include "tc358743_regs.h"
+
+enum tc358743_csi_port { CSI_TX_NONE = 0, CSI_TX_0, CSI_TX_1, CSI_TX_BOTH };
+
+enum tc358743_ddc5v_delays {
+  DDC5V_DELAY_0_MS,
+  DDC5V_DELAY_50_MS,
+  DDC5V_DELAY_100_MS,
+  DDC5V_DELAY_200_MS,
+  DDC5V_DELAY_MAX = DDC5V_DELAY_200_MS,
+};
+
+enum tc358743_hdmi_detection_delay {
+  HDMI_MODE_DELAY_0_MS,
+  HDMI_MODE_DELAY_25_MS,
+  HDMI_MODE_DELAY_50_MS,
+  HDMI_MODE_DELAY_100_MS,
+};
+
+struct tc358743_platform_data {
+  /* GPIOs */
+  int reset_gpio;
+
+#ifdef CONFIG_V4L2_FWNODE
+  struct v4l2_fwnode_endpoint endpoint;
+#else
+  struct v4l2_of_endpoint endpoint;
+#endif
+
+  /* System clock connected to REFCLK (pin H5) */
+  u32 refclk_hz; /* 26 MHz, 27 MHz or 42 MHz */
+
+  /* DDC +5V debounce delay to avoid spurious interrupts when the cable
+   * is connected.
+   * Sets DDC5V_MODE in register DDC_CTL.
+   * Default: DDC5V_DELAY_0_MS
+   */
+  enum tc358743_ddc5v_delays ddc5v_delay;
+
+  bool enable_hdcp;
+
+  /* CSI Output */
+  enum tc358743_csi_port csi_port;  // TODO: Should this be port-index?
+
+  /*
+   * The FIFO size is 512x32, so Toshiba recommend to set the default FIFO
+   * level to somewhere in the middle (e.g. 300), so it can cover speed
+   * mismatches in input and output ports.
+   */
+  u16 fifo_level;
+
+  /*  Bps pr lane is (refclk_hz / pll_prd) * pll_fbd */
+  u16 pll_prd;
+  u16 pll_fbd;
+
+  /* CSI
+   * Calculate CSI parameters with REF_02 for the highest resolution your
+   * CSI interface can handle. The driver will adjust the number of CSI
+   * lanes in use according to the pixel clock.
+   *
+   * The values in brackets are calculated with REF_02 when the number of
+   * bps pr lane is 823.5 MHz, and can serve as a starting point.
+   */
+  u32 lineinitcnt;    /* (0x00001770) */
+  u32 lptxtimecnt;    /* (0x00000005) */
+  u32 tclk_headercnt; /* (0x00001d04) */
+  u32 tclk_trailcnt;  /* (0x00000000) */
+  u32 ths_headercnt;  /* (0x00000505) */
+  u32 twakeup;        /* (0x00004650) */
+  u32 tclk_postcnt;   /* (0x00000000) */
+  u32 ths_trailcnt;   /* (0x00000004) */
+  u32 hstxvregcnt;    /* (0x00000005) */
+
+  /* DVI->HDMI detection delay to avoid unnecessary switching between DVI
+   * and HDMI mode.
+   * Sets HDMI_DET_V in register HDMI_DET.
+   * Default: HDMI_MODE_DELAY_0_MS
+   */
+  enum tc358743_hdmi_detection_delay hdmi_detection_delay;
+
+  /* Reset PHY automatically when TMDS clock goes from DC to AC.
+   * Sets PHY_AUTO_RST2 in register PHY_CTL2.
+   * Default: false
+   */
+  bool hdmi_phy_auto_reset_tmds_detected;
+
+  /* Reset PHY automatically when TMDS clock passes 21 MHz.
+   * Sets PHY_AUTO_RST3 in register PHY_CTL2.
+   * Default: false
+   */
+  bool hdmi_phy_auto_reset_tmds_in_range;
+
+  /* Reset PHY automatically when TMDS clock is detected.
+   * Sets PHY_AUTO_RST4 in register PHY_CTL2.
+   * Default: false
+   */
+  bool hdmi_phy_auto_reset_tmds_valid;
+
+  /* Reset HDMI PHY automatically when hsync period is out of range.
+   * Sets H_PI_RST in register HV_RST.
+   * Default: false
+   */
+  bool hdmi_phy_auto_reset_hsync_out_of_range;
+
+  /* Reset HDMI PHY automatically when vsync period is out of range.
+   * Sets V_PI_RST in register HV_RST.
+   * Default: false
+   */
+  bool hdmi_phy_auto_reset_vsync_out_of_range;
+};
+
+/* custom controls */
+/* Audio sample rate in Hz */
+#define TC358743_CID_AUDIO_SAMPLING_RATE (V4L2_CID_USER_TC358743_BASE + 0)
+/* Audio present status */
+#define TC358743_CID_AUDIO_PRESENT (V4L2_CID_USER_TC358743_BASE + 1)
+
+#endif
\ No newline at end of file
diff --git a/nvidia-oot/include/media/tc358743_regs.h b/nvidia-oot/include/media/tc358743_regs.h
new file mode 100644
index 0000000..665c3d3
--- /dev/null
+++ b/nvidia-oot/include/media/tc358743_regs.h
@@ -0,0 +1,681 @@
+/*
+  * tc358743 - Toshiba HDMI to CSI-2 bridge - register names and bit masks
+ *
+ * Copyright 2015 Cisco Systems, Inc. and/or its affiliates. All rights
+ * reserved.
+ *
+ * This program is free software; you may redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ */
+
+/*
+ * References (c = chapter, p = page):
+ * REF_01 - Toshiba, TC358743XBG (H2C), Functional Specification, Rev 0.60
+ */
+
+/* Bit masks has prefix 'MASK_' and options after '_'. */
+
+#ifndef __TC358743_REGS_H
+#define __TC358743_REGS_H
+
+#define CHIPID                                0x0000
+#define MASK_CHIPID                           0xff00
+#define MASK_REVID                            0x00ff
+
+#define SYSCTL                                0x0002
+#define MASK_IRRST                            0x0800
+#define MASK_CECRST                           0x0400
+#define MASK_CTXRST                           0x0200
+#define MASK_HDMIRST                          0x0100
+#define MASK_SLEEP                            0x0001
+
+#define CONFCTL                               0x0004
+#define MASK_PWRISO                           0x8000
+#define MASK_ACLKOPT                          0x1000
+#define MASK_AUDCHNUM                         0x0c00
+#define MASK_AUDCHNUM_8                       0x0000
+#define MASK_AUDCHNUM_6                       0x0400
+#define MASK_AUDCHNUM_4                       0x0800
+#define MASK_AUDCHNUM_2                       0x0c00
+#define MASK_AUDCHSEL                         0x0200
+#define MASK_I2SDLYOPT                        0x0100
+#define MASK_YCBCRFMT                         0x00c0
+#define MASK_YCBCRFMT_444                     0x0000
+#define MASK_YCBCRFMT_422_12_BIT              0x0040
+#define MASK_YCBCRFMT_COLORBAR                0x0080
+#define MASK_YCBCRFMT_422_8_BIT               0x00c0
+#define MASK_INFRMEN                          0x0020
+#define MASK_AUDOUTSEL                        0x0018
+#define MASK_AUDOUTSEL_CSI                    0x0000
+#define MASK_AUDOUTSEL_I2S                    0x0010
+#define MASK_AUDOUTSEL_TDM                    0x0018
+#define MASK_AUTOINDEX                        0x0004
+#define MASK_ABUFEN                           0x0002
+#define MASK_VBUFEN                           0x0001
+
+#define FIFOCTL                               0x0006
+
+#define INTSTATUS                             0x0014
+#define MASK_AMUTE_INT                        0x0400
+#define MASK_HDMI_INT                         0x0200
+#define MASK_CSI_INT                          0x0100
+#define MASK_SYS_INT                          0x0020
+#define MASK_CEC_EINT                         0x0010
+#define MASK_CEC_TINT                         0x0008
+#define MASK_CEC_RINT                         0x0004
+#define MASK_IR_EINT                          0x0002
+#define MASK_IR_DINT                          0x0001
+
+#define INTMASK                               0x0016
+#define MASK_AMUTE_MSK                        0x0400
+#define MASK_HDMI_MSK                         0x0200
+#define MASK_CSI_MSK                          0x0100
+#define MASK_SYS_MSK                          0x0020
+#define MASK_CEC_EMSK                         0x0010
+#define MASK_CEC_TMSK                         0x0008
+#define MASK_CEC_RMSK                         0x0004
+#define MASK_IR_EMSK                          0x0002
+#define MASK_IR_DMSK                          0x0001
+
+#define INTFLAG                               0x0018
+#define INTSYSSTATUS                          0x001A
+
+#define PLLCTL0                               0x0020
+#define MASK_PLL_PRD                          0xf000
+#define SET_PLL_PRD(prd)                      ((((prd) - 1) << 12) &\
+						MASK_PLL_PRD)
+#define MASK_PLL_FBD                          0x01ff
+#define SET_PLL_FBD(fbd)                      (((fbd) - 1) & MASK_PLL_FBD)
+
+#define PLLCTL1                               0x0022
+#define MASK_PLL_FRS                          0x0c00
+#define SET_PLL_FRS(frs)                      (((frs) << 10) & MASK_PLL_FRS)
+#define MASK_PLL_LBWS                         0x0300
+#define MASK_LFBREN                           0x0040
+#define MASK_BYPCKEN                          0x0020
+#define MASK_CKEN                             0x0010
+#define MASK_RESETB                           0x0002
+#define MASK_PLL_EN                           0x0001
+
+#define CLW_CNTRL                             0x0140
+#define MASK_CLW_LANEDISABLE                  0x0001
+
+#define D0W_CNTRL                             0x0144
+#define MASK_D0W_LANEDISABLE                  0x0001
+
+#define D1W_CNTRL                             0x0148
+#define MASK_D1W_LANEDISABLE                  0x0001
+
+#define D2W_CNTRL                             0x014C
+#define MASK_D2W_LANEDISABLE                  0x0001
+
+#define D3W_CNTRL                             0x0150
+#define MASK_D3W_LANEDISABLE                  0x0001
+
+#define STARTCNTRL                            0x0204
+#define MASK_START                            0x00000001
+
+#define LINEINITCNT                           0x0210
+#define LPTXTIMECNT                           0x0214
+#define TCLK_HEADERCNT                        0x0218
+#define TCLK_TRAILCNT                         0x021C
+#define THS_HEADERCNT                         0x0220
+#define TWAKEUP                               0x0224
+#define TCLK_POSTCNT                          0x0228
+#define THS_TRAILCNT                          0x022C
+#define HSTXVREGCNT                           0x0230
+
+#define HSTXVREGEN                            0x0234
+#define MASK_D3M_HSTXVREGEN                   0x0010
+#define MASK_D2M_HSTXVREGEN                   0x0008
+#define MASK_D1M_HSTXVREGEN                   0x0004
+#define MASK_D0M_HSTXVREGEN                   0x0002
+#define MASK_CLM_HSTXVREGEN                   0x0001
+
+
+#define TXOPTIONCNTRL                         0x0238
+#define MASK_CONTCLKMODE                      0x00000001
+
+#define CSI_CONTROL                           0x040C
+#define MASK_CSI_MODE                         0x8000
+#define MASK_HTXTOEN                          0x0400
+#define MASK_TXHSMD                           0x0080
+#define MASK_HSCKMD                           0x0020
+#define MASK_NOL                              0x0006
+#define MASK_NOL_1                            0x0000
+#define MASK_NOL_2                            0x0002
+#define MASK_NOL_3                            0x0004
+#define MASK_NOL_4                            0x0006
+#define MASK_EOTDIS                           0x0001
+
+#define CSI_INT                               0x0414
+#define MASK_INTHLT                           0x00000008
+#define MASK_INTER                            0x00000004
+
+#define CSI_INT_ENA                           0x0418
+#define MASK_IENHLT                           0x00000008
+#define MASK_IENER                            0x00000004
+
+#define CSI_ERR                               0x044C
+#define MASK_INER                             0x00000200
+#define MASK_WCER                             0x00000100
+#define MASK_QUNK                             0x00000010
+#define MASK_TXBRK                            0x00000002
+
+#define CSI_ERR_INTENA                        0x0450
+#define CSI_ERR_HALT                          0x0454
+
+#define CSI_CONFW                             0x0500
+#define MASK_MODE                             0xe0000000
+#define MASK_MODE_SET                         0xa0000000
+#define MASK_MODE_CLEAR                       0xc0000000
+#define MASK_ADDRESS                          0x1f000000
+#define MASK_ADDRESS_CSI_CONTROL              0x03000000
+#define MASK_ADDRESS_CSI_INT_ENA              0x06000000
+#define MASK_ADDRESS_CSI_ERR_INTENA           0x14000000
+#define MASK_ADDRESS_CSI_ERR_HALT             0x15000000
+#define MASK_DATA                             0x0000ffff
+
+#define CSI_INT_CLR                           0x050C
+#define MASK_ICRER                            0x00000004
+
+#define CSI_START                             0x0518
+#define MASK_STRT                             0x00000001
+
+#define CECEN                                 0x0600
+#define MASK_CECEN                            0x0001
+
+#define HDMI_INT0                             0x8500
+#define MASK_I_KEY                            0x80
+#define MASK_I_MISC                           0x02
+#define MASK_I_PHYERR                         0x01
+
+#define HDMI_INT1                             0x8501
+#define MASK_I_GBD                            0x80
+#define MASK_I_HDCP                           0x40
+#define MASK_I_ERR                            0x20
+#define MASK_I_AUD                            0x10
+#define MASK_I_CBIT                           0x08
+#define MASK_I_PACKET                         0x04
+#define MASK_I_CLK                            0x02
+#define MASK_I_SYS                            0x01
+
+#define SYS_INT                               0x8502
+#define MASK_I_ACR_CTS                        0x80
+#define MASK_I_ACRN                           0x40
+#define MASK_I_DVI                            0x20
+#define MASK_I_HDMI                           0x10
+#define MASK_I_NOPMBDET                       0x08
+#define MASK_I_DPMBDET                        0x04
+#define MASK_I_TMDS                           0x02
+#define MASK_I_DDC                            0x01
+
+#define CLK_INT                               0x8503
+#define MASK_I_OUT_H_CHG                      0x40
+#define MASK_I_IN_DE_CHG                      0x20
+#define MASK_I_IN_HV_CHG                      0x10
+#define MASK_I_DC_CHG                         0x08
+#define MASK_I_PXCLK_CHG                      0x04
+#define MASK_I_PHYCLK_CHG                     0x02
+#define MASK_I_TMDSCLK_CHG                    0x01
+
+#define CBIT_INT                              0x8505
+#define MASK_I_AF_LOCK                        0x80
+#define MASK_I_AF_UNLOCK                      0x40
+#define MASK_I_CBIT_FS                        0x02
+
+#define AUDIO_INT                             0x8506
+
+#define ERR_INT                               0x8507
+#define MASK_I_EESS_ERR                       0x80
+
+#define HDCP_INT                              0x8508
+#define MASK_I_AVM_SET                        0x80
+#define MASK_I_AVM_CLR                        0x40
+#define MASK_I_LINKERR                        0x20
+#define MASK_I_SHA_END                        0x10
+#define MASK_I_R0_END                         0x08
+#define MASK_I_KM_END                         0x04
+#define MASK_I_AKSV_END                       0x02
+#define MASK_I_AN_END                         0x01
+
+#define MISC_INT                              0x850B
+#define MASK_I_AS_LAYOUT                      0x10
+#define MASK_I_NO_SPD                         0x08
+#define MASK_I_NO_VS                          0x03
+#define MASK_I_SYNC_CHG                       0x02
+#define MASK_I_AUDIO_MUTE                     0x01
+
+#define KEY_INT                               0x850F
+
+#define SYS_INTM                              0x8512
+#define MASK_M_ACR_CTS                        0x80
+#define MASK_M_ACR_N                          0x40
+#define MASK_M_DVI_DET                        0x20
+#define MASK_M_HDMI_DET                       0x10
+#define MASK_M_NOPMBDET                       0x08
+#define MASK_M_BPMBDET                        0x04
+#define MASK_M_TMDS                           0x02
+#define MASK_M_DDC                            0x01
+
+#define CLK_INTM                              0x8513
+#define MASK_M_OUT_H_CHG                      0x40
+#define MASK_M_IN_DE_CHG                      0x20
+#define MASK_M_IN_HV_CHG                      0x10
+#define MASK_M_DC_CHG                         0x08
+#define MASK_M_PXCLK_CHG                      0x04
+#define MASK_M_PHYCLK_CHG                     0x02
+#define MASK_M_TMDS_CHG                       0x01
+
+#define PACKET_INTM                           0x8514
+
+#define CBIT_INTM                             0x8515
+#define MASK_M_AF_LOCK                        0x80
+#define MASK_M_AF_UNLOCK                      0x40
+#define MASK_M_CBIT_FS                        0x02
+
+#define AUDIO_INTM                            0x8516
+#define MASK_M_BUFINIT_END                    0x01
+
+#define ERR_INTM                              0x8517
+#define MASK_M_EESS_ERR                       0x80
+
+#define HDCP_INTM                             0x8518
+#define MASK_M_AVM_SET                        0x80
+#define MASK_M_AVM_CLR                        0x40
+#define MASK_M_LINKERR                        0x20
+#define MASK_M_SHA_END                        0x10
+#define MASK_M_R0_END                         0x08
+#define MASK_M_KM_END                         0x04
+#define MASK_M_AKSV_END                       0x02
+#define MASK_M_AN_END                         0x01
+
+#define MISC_INTM                             0x851B
+#define MASK_M_AS_LAYOUT                      0x10
+#define MASK_M_NO_SPD                         0x08
+#define MASK_M_NO_VS                          0x03
+#define MASK_M_SYNC_CHG                       0x02
+#define MASK_M_AUDIO_MUTE                     0x01
+
+#define KEY_INTM                              0x851F
+
+#define SYS_STATUS                            0x8520
+#define MASK_S_SYNC                           0x80
+#define MASK_S_AVMUTE                         0x40
+#define MASK_S_HDCP                           0x20
+#define MASK_S_HDMI                           0x10
+#define MASK_S_PHY_SCDT                       0x08
+#define MASK_S_PHY_PLL                        0x04
+#define MASK_S_TMDS                           0x02
+#define MASK_S_DDC5V                          0x01
+
+#define CSI_STATUS                            0x0410
+#define MASK_S_WSYNC                          0x0400
+#define MASK_S_TXACT                          0x0200
+#define MASK_S_RXACT                          0x0100
+#define MASK_S_HLT                            0x0001
+
+#define VI_STATUS1                            0x8522
+#define MASK_S_V_GBD                          0x08
+#define MASK_S_DEEPCOLOR                      0x0c
+#define MASK_S_V_422                          0x02
+#define MASK_S_V_INTERLACE                    0x01
+
+#define AU_STATUS0                            0x8523
+#define MASK_S_A_SAMPLE                       0x01
+
+#define VI_STATUS3                            0x8528
+#define MASK_S_V_COLOR                        0x1e
+#define MASK_LIMITED                          0x01
+
+#define PHY_CTL0                              0x8531
+#define MASK_PHY_SYSCLK_IND                   0x02
+#define MASK_PHY_CTL                          0x01
+
+
+#define PHY_CTL1                              0x8532 /* Not in REF_01 */
+#define MASK_PHY_AUTO_RST1                    0xf0
+#define MASK_PHY_AUTO_RST1_OFF                0x00
+#define SET_PHY_AUTO_RST1_US(us)             ((((us) / 200) << 4) & \
+						MASK_PHY_AUTO_RST1)
+#define MASK_FREQ_RANGE_MODE                  0x0f
+#define SET_FREQ_RANGE_MODE_CYCLES(cycles)   (((cycles) - 1) & \
+						MASK_FREQ_RANGE_MODE)
+
+#define PHY_CTL2                              0x8533 /* Not in REF_01 */
+#define MASK_PHY_AUTO_RST4                    0x04
+#define MASK_PHY_AUTO_RST3                    0x02
+#define MASK_PHY_AUTO_RST2                    0x01
+#define MASK_PHY_AUTO_RSTn                    (MASK_PHY_AUTO_RST4 | \
+						MASK_PHY_AUTO_RST3 | \
+						MASK_PHY_AUTO_RST2)
+
+#define PHY_EN                                0x8534
+#define MASK_ENABLE_PHY                       0x01
+
+#define PHY_RST                               0x8535
+#define MASK_RESET_CTRL                       0x01   /* Reset active low */
+
+#define PHY_BIAS                              0x8536 /* Not in REF_01 */
+
+#define PHY_CSQ                               0x853F /* Not in REF_01 */
+#define MASK_CSQ_CNT                          0x0f
+#define SET_CSQ_CNT_LEVEL(n)                 (n & MASK_CSQ_CNT)
+
+#define SYS_FREQ0                             0x8540
+#define SYS_FREQ1                             0x8541
+
+#define SYS_CLK                               0x8542 /* Not in REF_01 */
+#define MASK_CLK_DIFF                         0x0C
+#define MASK_CLK_DIV                          0x03
+
+#define DDC_CTL                               0x8543
+#define MASK_DDC_ACK_POL                      0x08
+#define MASK_DDC_ACTION                       0x04
+#define MASK_DDC5V_MODE                       0x03
+#define MASK_DDC5V_MODE_0MS                   0x00
+#define MASK_DDC5V_MODE_50MS                  0x01
+#define MASK_DDC5V_MODE_100MS                 0x02
+#define MASK_DDC5V_MODE_200MS                 0x03
+
+#define HPD_CTL                               0x8544
+#define MASK_HPD_CTL0                         0x10
+#define MASK_HPD_OUT0                         0x01
+
+#define ANA_CTL                               0x8545
+#define MASK_APPL_PCSX                        0x30
+#define MASK_APPL_PCSX_HIZ                    0x00
+#define MASK_APPL_PCSX_L_FIX                  0x10
+#define MASK_APPL_PCSX_H_FIX                  0x20
+#define MASK_APPL_PCSX_NORMAL                 0x30
+#define MASK_ANALOG_ON                        0x01
+
+#define AVM_CTL                               0x8546
+
+#define INIT_END                              0x854A
+#define MASK_INIT_END                         0x01
+
+#define HDMI_DET                              0x8552 /* Not in REF_01 */
+#define MASK_HDMI_DET_MOD1                    0x80
+#define MASK_HDMI_DET_MOD0                    0x40
+#define MASK_HDMI_DET_V                       0x30
+#define MASK_HDMI_DET_V_SYNC                  0x00
+#define MASK_HDMI_DET_V_ASYNC_25MS            0x10
+#define MASK_HDMI_DET_V_ASYNC_50MS            0x20
+#define MASK_HDMI_DET_V_ASYNC_100MS           0x30
+#define MASK_HDMI_DET_NUM                     0x0f
+
+#define HDCP_MODE                             0x8560
+#define MASK_MODE_RST_TN                      0x20
+#define MASK_LINE_REKEY                       0x10
+#define MASK_AUTO_CLR                         0x04
+
+#define HDCP_REG1                             0x8563 /* Not in REF_01 */
+#define MASK_AUTH_UNAUTH_SEL                  0x70
+#define MASK_AUTH_UNAUTH_SEL_12_FRAMES        0x70
+#define MASK_AUTH_UNAUTH_SEL_8_FRAMES         0x60
+#define MASK_AUTH_UNAUTH_SEL_4_FRAMES         0x50
+#define MASK_AUTH_UNAUTH_SEL_2_FRAMES         0x40
+#define MASK_AUTH_UNAUTH_SEL_64_FRAMES        0x30
+#define MASK_AUTH_UNAUTH_SEL_32_FRAMES        0x20
+#define MASK_AUTH_UNAUTH_SEL_16_FRAMES        0x10
+#define MASK_AUTH_UNAUTH_SEL_ONCE             0x00
+#define MASK_AUTH_UNAUTH                      0x01
+#define MASK_AUTH_UNAUTH_AUTO                 0x01
+
+#define HDCP_REG2                             0x8564 /* Not in REF_01 */
+#define MASK_AUTO_P3_RESET                    0x0F
+#define SET_AUTO_P3_RESET_FRAMES(n)          (n & MASK_AUTO_P3_RESET)
+#define MASK_AUTO_P3_RESET_OFF                0x00
+
+#define VI_MODE                               0x8570
+#define MASK_RGB_DVI                          0x08 /* Not in REF_01 */
+
+#define VOUT_SET2                             0x8573
+#define MASK_SEL422                           0x80
+#define MASK_VOUT_422FIL_100                  0x40
+#define MASK_VOUTCOLORMODE                    0x03
+#define MASK_VOUTCOLORMODE_THROUGH            0x00
+#define MASK_VOUTCOLORMODE_AUTO               0x01
+#define MASK_VOUTCOLORMODE_MANUAL             0x03
+
+#define VOUT_SET3                             0x8574
+#define MASK_VOUT_EXTCNT                      0x08
+
+#define VI_REP                                0x8576
+#define MASK_VOUT_COLOR_SEL                   0xe0
+#define MASK_VOUT_COLOR_RGB_FULL              0x00
+#define MASK_VOUT_COLOR_RGB_LIMITED           0x20
+#define MASK_VOUT_COLOR_601_YCBCR_FULL        0x40
+#define MASK_VOUT_COLOR_601_YCBCR_LIMITED     0x60
+#define MASK_VOUT_COLOR_709_YCBCR_FULL        0x80
+#define MASK_VOUT_COLOR_709_YCBCR_LIMITED     0xa0
+#define MASK_VOUT_COLOR_FULL_TO_LIMITED       0xc0
+#define MASK_VOUT_COLOR_LIMITED_TO_FULL       0xe0
+#define MASK_IN_REP_HEN                       0x10
+#define MASK_IN_REP                           0x0f
+
+#define VI_MUTE                               0x857F
+#define MASK_AUTO_MUTE                        0xc0
+#define MASK_VI_MUTE                          0x10
+
+#define DE_WIDTH_H_LO                         0x8582 /* Not in REF_01 */
+#define DE_WIDTH_H_HI                         0x8583 /* Not in REF_01 */
+#define DE_WIDTH_V_LO                         0x8588 /* Not in REF_01 */
+#define DE_WIDTH_V_HI                         0x8589 /* Not in REF_01 */
+#define H_SIZE_LO                             0x858A /* Not in REF_01 */
+#define H_SIZE_HI                             0x858B /* Not in REF_01 */
+#define V_SIZE_LO                             0x858C /* Not in REF_01 */
+#define V_SIZE_HI                             0x858D /* Not in REF_01 */
+#define FV_CNT_LO                             0x85A1 /* Not in REF_01 */
+#define FV_CNT_HI                             0x85A2 /* Not in REF_01 */
+
+#define FH_MIN0                               0x85AA /* Not in REF_01 */
+#define FH_MIN1                               0x85AB /* Not in REF_01 */
+#define FH_MAX0                               0x85AC /* Not in REF_01 */
+#define FH_MAX1                               0x85AD /* Not in REF_01 */
+
+#define HV_RST                                0x85AF /* Not in REF_01 */
+#define MASK_H_PI_RST                         0x20
+#define MASK_V_PI_RST                         0x10
+
+#define EDID_MODE                             0x85C7
+#define MASK_EDID_SPEED                       0x40
+#define MASK_EDID_MODE                        0x03
+#define MASK_EDID_MODE_DISABLE                0x00
+#define MASK_EDID_MODE_DDC2B                  0x01
+#define MASK_EDID_MODE_E_DDC                  0x02
+
+#define EDID_LEN1                             0x85CA
+#define EDID_LEN2                             0x85CB
+
+#define HDCP_REG3                             0x85D1 /* Not in REF_01 */
+#define KEY_RD_CMD                            0x01
+
+#define FORCE_MUTE                            0x8600
+#define MASK_FORCE_AMUTE                      0x10
+#define MASK_FORCE_DMUTE                      0x01
+
+#define CMD_AUD                               0x8601
+#define MASK_CMD_BUFINIT                      0x04
+#define MASK_CMD_LOCKDET                      0x02
+#define MASK_CMD_MUTE                         0x01
+
+#define AUTO_CMD0                             0x8602
+#define MASK_AUTO_MUTE7                       0x80
+#define MASK_AUTO_MUTE6                       0x40
+#define MASK_AUTO_MUTE5                       0x20
+#define MASK_AUTO_MUTE4                       0x10
+#define MASK_AUTO_MUTE3                       0x08
+#define MASK_AUTO_MUTE2                       0x04
+#define MASK_AUTO_MUTE1                       0x02
+#define MASK_AUTO_MUTE0                       0x01
+
+#define AUTO_CMD1                             0x8603
+#define MASK_AUTO_MUTE10                      0x04
+#define MASK_AUTO_MUTE9                       0x02
+#define MASK_AUTO_MUTE8                       0x01
+
+#define AUTO_CMD2                             0x8604
+#define MASK_AUTO_PLAY3                       0x08
+#define MASK_AUTO_PLAY2                       0x04
+
+#define BUFINIT_START                         0x8606
+#define SET_BUFINIT_START_MS(milliseconds)   ((milliseconds) / 100)
+
+#define FS_MUTE                               0x8607
+#define MASK_FS_ELSE_MUTE                     0x80
+#define MASK_FS22_MUTE                        0x40
+#define MASK_FS24_MUTE                        0x20
+#define MASK_FS88_MUTE                        0x10
+#define MASK_FS96_MUTE                        0x08
+#define MASK_FS176_MUTE                       0x04
+#define MASK_FS192_MUTE                       0x02
+#define MASK_FS_NO_MUTE                       0x01
+
+#define FS_IMODE                              0x8620
+#define MASK_NLPCM_HMODE                      0x40
+#define MASK_NLPCM_SMODE                      0x20
+#define MASK_NLPCM_IMODE                      0x10
+#define MASK_FS_HMODE                         0x08
+#define MASK_FS_AMODE                         0x04
+#define MASK_FS_SMODE                         0x02
+#define MASK_FS_IMODE                         0x01
+
+#define FS_SET                                0x8621
+#define MASK_FS                               0x0f
+
+#define LOCKDET_REF0                          0x8630
+#define LOCKDET_REF1                          0x8631
+#define LOCKDET_REF2                          0x8632
+
+#define ACR_MODE                              0x8640
+#define MASK_ACR_LOAD                         0x10
+#define MASK_N_MODE                           0x04
+#define MASK_CTS_MODE                         0x01
+
+#define ACR_MDF0                              0x8641
+#define MASK_ACR_L2MDF                        0x70
+#define MASK_ACR_L2MDF_0_PPM                  0x00
+#define MASK_ACR_L2MDF_61_PPM                 0x10
+#define MASK_ACR_L2MDF_122_PPM                0x20
+#define MASK_ACR_L2MDF_244_PPM                0x30
+#define MASK_ACR_L2MDF_488_PPM                0x40
+#define MASK_ACR_L2MDF_976_PPM                0x50
+#define MASK_ACR_L2MDF_1976_PPM               0x60
+#define MASK_ACR_L2MDF_3906_PPM               0x70
+#define MASK_ACR_L1MDF                        0x07
+#define MASK_ACR_L1MDF_0_PPM                  0x00
+#define MASK_ACR_L1MDF_61_PPM                 0x01
+#define MASK_ACR_L1MDF_122_PPM                0x02
+#define MASK_ACR_L1MDF_244_PPM                0x03
+#define MASK_ACR_L1MDF_488_PPM                0x04
+#define MASK_ACR_L1MDF_976_PPM                0x05
+#define MASK_ACR_L1MDF_1976_PPM               0x06
+#define MASK_ACR_L1MDF_3906_PPM               0x07
+
+#define ACR_MDF1                              0x8642
+#define MASK_ACR_L3MDF                        0x07
+#define MASK_ACR_L3MDF_0_PPM                  0x00
+#define MASK_ACR_L3MDF_61_PPM                 0x01
+#define MASK_ACR_L3MDF_122_PPM                0x02
+#define MASK_ACR_L3MDF_244_PPM                0x03
+#define MASK_ACR_L3MDF_488_PPM                0x04
+#define MASK_ACR_L3MDF_976_PPM                0x05
+#define MASK_ACR_L3MDF_1976_PPM               0x06
+#define MASK_ACR_L3MDF_3906_PPM               0x07
+
+#define SDO_MODE1                             0x8652
+#define MASK_SDO_BIT_LENG                     0x70
+#define MASK_SDO_FMT                          0x03
+#define MASK_SDO_FMT_RIGHT                    0x00
+#define MASK_SDO_FMT_LEFT                     0x01
+#define MASK_SDO_FMT_I2S                      0x02
+
+#define DIV_MODE                              0x8665 /* Not in REF_01 */
+#define MASK_DIV_DLY                          0xf0
+#define SET_DIV_DLY_MS(milliseconds)         ((((milliseconds) / 100) << 4) & \
+						MASK_DIV_DLY)
+#define MASK_DIV_MODE                         0x01
+
+#define NCO_F0_MOD                            0x8670
+#define MASK_NCO_F0_MOD                       0x03
+#define MASK_NCO_F0_MOD_42MHZ                 0x00
+#define MASK_NCO_F0_MOD_27MHZ                 0x01
+
+#define PK_INT_MODE                           0x8709
+#define MASK_ISRC2_INT_MODE                   0x80
+#define MASK_ISRC_INT_MODE                    0x40
+#define MASK_ACP_INT_MODE                     0x20
+#define MASK_VS_INT_MODE                      0x10
+#define MASK_SPD_INT_MODE                     0x08
+#define MASK_MS_INT_MODE                      0x04
+#define MASK_AUD_INT_MODE                     0x02
+#define MASK_AVI_INT_MODE                     0x01
+
+#define NO_PKT_LIMIT                          0x870B
+#define MASK_NO_ACP_LIMIT                     0xf0
+#define SET_NO_ACP_LIMIT_MS(milliseconds)    ((((milliseconds) / 80) << 4) & \
+						MASK_NO_ACP_LIMIT)
+#define MASK_NO_AVI_LIMIT                     0x0f
+#define SET_NO_AVI_LIMIT_MS(milliseconds)    (((milliseconds) / 80) & \
+						MASK_NO_AVI_LIMIT)
+
+#define NO_PKT_CLR                            0x870C
+#define MASK_NO_VS_CLR                        0x40
+#define MASK_NO_SPD_CLR                       0x20
+#define MASK_NO_ACP_CLR                       0x10
+#define MASK_NO_AVI_CLR1                      0x02
+#define MASK_NO_AVI_CLR0                      0x01
+
+#define ERR_PK_LIMIT                          0x870D
+#define NO_PKT_LIMIT2                         0x870E
+#define PK_AVI_0HEAD                          0x8710
+#define PK_AVI_1HEAD                          0x8711
+#define PK_AVI_2HEAD                          0x8712
+#define PK_AVI_0BYTE                          0x8713
+#define PK_AVI_1BYTE                          0x8714
+#define PK_AVI_2BYTE                          0x8715
+#define PK_AVI_3BYTE                          0x8716
+#define PK_AVI_4BYTE                          0x8717
+#define PK_AVI_5BYTE                          0x8718
+#define PK_AVI_6BYTE                          0x8719
+#define PK_AVI_7BYTE                          0x871A
+#define PK_AVI_8BYTE                          0x871B
+#define PK_AVI_9BYTE                          0x871C
+#define PK_AVI_10BYTE                         0x871D
+#define PK_AVI_11BYTE                         0x871E
+#define PK_AVI_12BYTE                         0x871F
+#define PK_AVI_13BYTE                         0x8720
+#define PK_AVI_14BYTE                         0x8721
+#define PK_AVI_15BYTE                         0x8722
+#define PK_AVI_16BYTE                         0x8723
+
+#define BKSV                                  0x8800
+
+#define BCAPS                                 0x8840
+#define MASK_HDMI_RSVD                        0x80
+#define MASK_REPEATER                         0x40
+#define MASK_READY                            0x20
+#define MASK_FASTI2C                          0x10
+#define MASK_1_1_FEA                          0x02
+#define MASK_FAST_REAU                        0x01
+
+#define BSTATUS1                              0x8842
+#define MASK_MAX_EXCED                        0x08
+
+#define EDID_RAM                              0x8C00
+#define NO_GDB_LIMIT                          0x9007
+
+#endif
\ No newline at end of file
-- 
2.47.2

